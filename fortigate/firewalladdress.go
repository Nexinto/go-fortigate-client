// WARNING: This file was generated by gen/generator.go

package fortigate

import (
	"fmt"
)

// Enable/disable use of this address in the static route configuration.
type FirewallAddressAllowRouting string

// IP address list.
type FirewallAddressList struct {

	// IP.
	Ip string `json:"ip,omitempty"`
}

// SDN.
type FirewallAddressSdn string

// Names of object-tags applied to address.
type FirewallAddressTags struct {

	// Tag name.
	Name string `json:"name,omitempty"`
}

// Type of address.
type FirewallAddressType string

// Enable/disable address visibility in the GUI.
type FirewallAddressVisibility string

const (

	// Enable use of this address in the static route configuration.
	FirewallAddressAllowRoutingEnable FirewallAddressAllowRouting = "enable"

	// Disable use of this address in the static route configuration.
	FirewallAddressAllowRoutingDisable FirewallAddressAllowRouting = "disable"

	// Application Centric Infrastructure.
	FirewallAddressSdnAci FirewallAddressSdn = "aci"

	// Amazon Web Services.
	FirewallAddressSdnAws FirewallAddressSdn = "aws"

	// VMware NSX.
	FirewallAddressSdnNsx FirewallAddressSdn = "nsx"

	// Nuage Virtualized Services Platform.
	FirewallAddressSdnNuage FirewallAddressSdn = "nuage"

	// Standard IPv4 address with subnet mask.
	FirewallAddressTypeIpmask FirewallAddressType = "ipmask"

	// Range of IPv4 addresses between two specified addresses (inclusive).
	FirewallAddressTypeIprange FirewallAddressType = "iprange"

	// Fully Qualified Domain Name address.
	FirewallAddressTypeFqdn FirewallAddressType = "fqdn"

	// IP addresses from a specified country.
	FirewallAddressTypeGeography FirewallAddressType = "geography"

	// Standard IPv4 using a wildcard subnet mask.
	FirewallAddressTypeWildcard FirewallAddressType = "wildcard"

	// Fully Qualified Domain Name with wildcard characters.
	FirewallAddressTypeWildcardFqdn FirewallAddressType = "wildcard-fqdn"

	// Dynamic address object for SDN.
	FirewallAddressTypeDynamic FirewallAddressType = "dynamic"

	// Show in address4 selection.
	FirewallAddressVisibilityEnable FirewallAddressVisibility = "enable"

	// Hide from address4 selection.
	FirewallAddressVisibilityDisable FirewallAddressVisibility = "disable"
)

// Configure IPv4 addresses.
type FirewallAddress struct {

	// Enable/disable use of this address in the static route configuration.
	AllowRouting FirewallAddressAllowRouting `json:"allow-routing,omitempty"`

	// Network interface associated with address.
	AssociatedInterface string `json:"associated-interface,omitempty"`

	// Defines the minimal TTL of individual IP addresses in FQDN cache measured in seconds.
	CacheTtl int `json:"cache-ttl,omitempty"`

	// Color of icon on the GUI.
	Color int `json:"color,omitempty"`

	// Comment.
	Comment string `json:"comment,omitempty"`

	// IP addresses associated to a specific country.
	Country string `json:"country,omitempty"`

	// Final IP address (inclusive) in the range for the address.
	EndIp string `json:"end-ip,omitempty"`

	// Endpoint group name.
	EpgName string `json:"epg-name,omitempty"`

	// Fully Qualified Domain Name address.
	Fqdn string `json:"fqdn,omitempty"`

	// IP address list.
	List []FirewallAddressList `json:"list,omitempty"`

	// Address name.
	Name string `json:"name,omitempty"`

	// Object ID for NSX.
	ObjId int `json:"obj-id,omitempty"`

	// Organization domain name (Syntax: organization/domain).
	Organization string `json:"organization,omitempty"`

	// Policy group name.
	PolicyGroup string `json:"policy-group,omitempty"`

	// SDN.
	Sdn FirewallAddressSdn `json:"sdn,omitempty"`

	// SDN Tag.
	SdnTag string `json:"sdn-tag,omitempty"`

	// First IP address (inclusive) in the range for the address.
	StartIp string `json:"start-ip,omitempty"`

	// IP address and subnet mask of address.
	Subnet string `json:"subnet,omitempty"`

	// Subnet name.
	SubnetName string `json:"subnet-name,omitempty"`

	// Names of object-tags applied to address.
	Tags []FirewallAddressTags `json:"tags,omitempty"`

	// Tenant.
	Tenant string `json:"tenant,omitempty"`

	// Type of address.
	Type FirewallAddressType `json:"type,omitempty"`

	// Universally Unique Identifier (UUID; automatically assigned but can be manually reset).
	Uuid string `json:"uuid,omitempty"`

	// Enable/disable address visibility in the GUI.
	Visibility FirewallAddressVisibility `json:"visibility,omitempty"`

	// IP address and wildcard netmask.
	Wildcard string `json:"wildcard,omitempty"`

	// Fully Qualified Domain Name with wildcard characters.
	WildcardFqdn string `json:"wildcard-fqdn,omitempty"`
}

// The results of a Get or List operation
type FirewallAddressResults struct {
	Results []*FirewallAddress `json:"results"`
	Mkey    string             `json:"mkey"`
	Result
}

// List all FirewallAddresss
func (c *WebClient) ListFirewallAddresss() (res []*FirewallAddress, err error) {
	var errmsg Result
	var results FirewallAddressResults
	_, err = c.napping.Get(c.URL+"/api/v2/cmdb/firewall/address", nil, &results, nil)
	if err != nil {
		return []*FirewallAddress{}, fmt.Errorf("error listing FirewallAddresss: %s", err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return []*FirewallAddress{}, fmt.Errorf("error listing FirewallAddress: not found")
		} else {
			return []*FirewallAddress{}, fmt.Errorf("error listing FirewallAddress: %s", errmsg.Status)
		}
	}
	res = results.Results
	return
}

// Get a FirewallAddress by name
func (c *WebClient) GetFirewallAddress(name string) (res *FirewallAddress, err error) {
	var errmsg Result
	var results FirewallAddressResults
	_, err = c.napping.Get(c.URL+"/api/v2/cmdb/firewall/address/"+name, nil, &results, &errmsg)
	if err != nil {
		return &FirewallAddress{}, fmt.Errorf("error getting FirewallAddress '%s': %s", name, err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return &FirewallAddress{}, fmt.Errorf("error getting FirewallAddress '%s': not found", name)
		} else {
			return &FirewallAddress{}, fmt.Errorf("error getting FirewallAddress '%s': %s", name, errmsg.Status)
		}
	}
	if len(results.Results) == 0 {
		return &FirewallAddress{}, fmt.Errorf("error getting FirewallAddress '%s': not found", name)
	}

	res = results.Results[0]
	return
}

// Create a new FirewallAddress
func (c *WebClient) CreateFirewallAddress(obj *FirewallAddress) (id string, err error) {
	var errmsg Result
	var results FirewallAddressResults
	_, err = c.napping.Post(c.URL+"/api/v2/cmdb/firewall/address", obj, &results, &errmsg)
	if err != nil {
		return "", fmt.Errorf("error creating FirewallAddress '%s': %s", obj.Name, err.Error())
	}
	if results.HTTPStatus == 200 {
		return
	}
	if errmsg.HTTPStatus != 200 {
		return "", fmt.Errorf("error creating FirewallAddress '%s': %s", obj.Name, errmsg.Status)
	}

	return
}

// Update a FirewallAddress
func (c *WebClient) UpdateFirewallAddress(obj *FirewallAddress) (err error) {
	var errmsg Result
	var results FirewallAddressResults
	_, err = c.napping.Put(c.URL+"/api/v2/cmdb/firewall/address/"+obj.Name, obj, &results, &errmsg)
	if err != nil {
		return fmt.Errorf("error updating FirewallAddress '%s': %s", obj.Name, err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return fmt.Errorf("error updating FirewallAddress '%s': not found", obj.Name)
		} else {
			return fmt.Errorf("error updating FirewallAddress '%s': %s", obj.Name, errmsg.Status)
		}
	}

	return
}

// Delete a FirewallAddress by name
func (c *WebClient) DeleteFirewallAddress(name string) (err error) {
	var errmsg Result
	var results FirewallAddressResults
	_, err = c.napping.Delete(c.URL+"/api/v2/cmdb/firewall/address/"+name, nil, &results, &errmsg)
	if err != nil {
		return fmt.Errorf("error deleting FirewallAddress '%s': %s", name, err.Error())
	}
	if results.HTTPStatus == 200 {
		return
	}
	if errmsg.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return fmt.Errorf("error deleting FirewallAddress '%s': not found", name)
		}
		return fmt.Errorf("error deleting FirewallAddress '%s': %s", name, errmsg.Status)
	}

	return
}

// List all FirewallAddresss
func (c *FakeClient) ListFirewallAddresss() (res []*FirewallAddress, err error) {
	for _, r := range c.FirewallAddresss {
		res = append(res, r)
	}
	return
}

// Get a FirewallAddress by name
func (c *FakeClient) GetFirewallAddress(name string) (*FirewallAddress, error) {
	if res, ok := c.FirewallAddresss[name]; ok {
		return res, nil
	} else {
		return &FirewallAddress{}, fmt.Errorf("error getting FirewallAddress '%s': not found", name)
	}
}

// Create a new FirewallAddress
func (c *FakeClient) CreateFirewallAddress(obj *FirewallAddress) (id string, err error) {
	c.FirewallAddresss[obj.Name] = obj
	return "", nil
}

// Update a FirewallAddress
func (c *FakeClient) UpdateFirewallAddress(obj *FirewallAddress) (err error) {
	c.FirewallAddresss[obj.Name] = obj
	return nil
}

// Delete a FirewallAddress by name
func (c *FakeClient) DeleteFirewallAddress(name string) (err error) {
	delete(c.FirewallAddresss, name)
	return nil
}
