// WARNING: This file was generated by generator.go

package fortigate

import (
	"fmt"
	"strconv"
)

// A fortigate API client
type Client interface {

	// List all FirewallAddresss
	ListFirewallAddresss() ([]*FirewallAddress, error)

	// Get a FirewallAddress by name
	GetFirewallAddress(mkey string) (*FirewallAddress, error)

	// Create a new FirewallAddress
	CreateFirewallAddress(*FirewallAddress) (string, error)

	// Update a FirewallAddress
	UpdateFirewallAddress(*FirewallAddress) error

	// Delete a FirewallAddress by name
	DeleteFirewallAddress(mkey string) error

	// List all FirewallMulticastAddresss
	ListFirewallMulticastAddresss() ([]*FirewallMulticastAddress, error)

	// Get a FirewallMulticastAddress by name
	GetFirewallMulticastAddress(mkey string) (*FirewallMulticastAddress, error)

	// Create a new FirewallMulticastAddress
	CreateFirewallMulticastAddress(*FirewallMulticastAddress) (string, error)

	// Update a FirewallMulticastAddress
	UpdateFirewallMulticastAddress(*FirewallMulticastAddress) error

	// Delete a FirewallMulticastAddress by name
	DeleteFirewallMulticastAddress(mkey string) error

	// List all FirewallAddress6s
	ListFirewallAddress6s() ([]*FirewallAddress6, error)

	// Get a FirewallAddress6 by name
	GetFirewallAddress6(mkey string) (*FirewallAddress6, error)

	// Create a new FirewallAddress6
	CreateFirewallAddress6(*FirewallAddress6) (string, error)

	// Update a FirewallAddress6
	UpdateFirewallAddress6(*FirewallAddress6) error

	// Delete a FirewallAddress6 by name
	DeleteFirewallAddress6(mkey string) error

	// List all FirewallMulticastAddress6s
	ListFirewallMulticastAddress6s() ([]*FirewallMulticastAddress6, error)

	// Get a FirewallMulticastAddress6 by name
	GetFirewallMulticastAddress6(mkey string) (*FirewallMulticastAddress6, error)

	// Create a new FirewallMulticastAddress6
	CreateFirewallMulticastAddress6(*FirewallMulticastAddress6) (string, error)

	// Update a FirewallMulticastAddress6
	UpdateFirewallMulticastAddress6(*FirewallMulticastAddress6) error

	// Delete a FirewallMulticastAddress6 by name
	DeleteFirewallMulticastAddress6(mkey string) error

	// List all FirewallAddrgrps
	ListFirewallAddrgrps() ([]*FirewallAddrgrp, error)

	// Get a FirewallAddrgrp by name
	GetFirewallAddrgrp(mkey string) (*FirewallAddrgrp, error)

	// Create a new FirewallAddrgrp
	CreateFirewallAddrgrp(*FirewallAddrgrp) (string, error)

	// Update a FirewallAddrgrp
	UpdateFirewallAddrgrp(*FirewallAddrgrp) error

	// Delete a FirewallAddrgrp by name
	DeleteFirewallAddrgrp(mkey string) error

	// List all FirewallAddrgrp6s
	ListFirewallAddrgrp6s() ([]*FirewallAddrgrp6, error)

	// Get a FirewallAddrgrp6 by name
	GetFirewallAddrgrp6(mkey string) (*FirewallAddrgrp6, error)

	// Create a new FirewallAddrgrp6
	CreateFirewallAddrgrp6(*FirewallAddrgrp6) (string, error)

	// Update a FirewallAddrgrp6
	UpdateFirewallAddrgrp6(*FirewallAddrgrp6) error

	// Delete a FirewallAddrgrp6 by name
	DeleteFirewallAddrgrp6(mkey string) error

	// List all FirewallInternetServices
	ListFirewallInternetServices() ([]*FirewallInternetService, error)

	// Get a FirewallInternetService by name
	GetFirewallInternetService(mkey int) (*FirewallInternetService, error)

	// Create a new FirewallInternetService
	CreateFirewallInternetService(*FirewallInternetService) (int, error)

	// Update a FirewallInternetService
	UpdateFirewallInternetService(*FirewallInternetService) error

	// Delete a FirewallInternetService by name
	DeleteFirewallInternetService(mkey int) error

	// List all FirewallInternetServiceCustoms
	ListFirewallInternetServiceCustoms() ([]*FirewallInternetServiceCustom, error)

	// Get a FirewallInternetServiceCustom by name
	GetFirewallInternetServiceCustom(mkey string) (*FirewallInternetServiceCustom, error)

	// Create a new FirewallInternetServiceCustom
	CreateFirewallInternetServiceCustom(*FirewallInternetServiceCustom) (string, error)

	// Update a FirewallInternetServiceCustom
	UpdateFirewallInternetServiceCustom(*FirewallInternetServiceCustom) error

	// Delete a FirewallInternetServiceCustom by name
	DeleteFirewallInternetServiceCustom(mkey string) error

	// List all FirewallIppools
	ListFirewallIppools() ([]*FirewallIppool, error)

	// Get a FirewallIppool by name
	GetFirewallIppool(mkey string) (*FirewallIppool, error)

	// Create a new FirewallIppool
	CreateFirewallIppool(*FirewallIppool) (string, error)

	// Update a FirewallIppool
	UpdateFirewallIppool(*FirewallIppool) error

	// Delete a FirewallIppool by name
	DeleteFirewallIppool(mkey string) error

	// List all FirewallIppool6s
	ListFirewallIppool6s() ([]*FirewallIppool6, error)

	// Get a FirewallIppool6 by name
	GetFirewallIppool6(mkey string) (*FirewallIppool6, error)

	// Create a new FirewallIppool6
	CreateFirewallIppool6(*FirewallIppool6) (string, error)

	// Update a FirewallIppool6
	UpdateFirewallIppool6(*FirewallIppool6) error

	// Delete a FirewallIppool6 by name
	DeleteFirewallIppool6(mkey string) error

	// List all FirewallLdbMonitors
	ListFirewallLdbMonitors() ([]*FirewallLdbMonitor, error)

	// Get a FirewallLdbMonitor by name
	GetFirewallLdbMonitor(mkey string) (*FirewallLdbMonitor, error)

	// Create a new FirewallLdbMonitor
	CreateFirewallLdbMonitor(*FirewallLdbMonitor) (string, error)

	// Update a FirewallLdbMonitor
	UpdateFirewallLdbMonitor(*FirewallLdbMonitor) error

	// Delete a FirewallLdbMonitor by name
	DeleteFirewallLdbMonitor(mkey string) error

	// List all FirewallVips
	ListFirewallVips() ([]*FirewallVip, error)

	// Get a FirewallVip by name
	GetFirewallVip(mkey string) (*FirewallVip, error)

	// Create a new FirewallVip
	CreateFirewallVip(*FirewallVip) (string, error)

	// Update a FirewallVip
	UpdateFirewallVip(*FirewallVip) error

	// Delete a FirewallVip by name
	DeleteFirewallVip(mkey string) error

	// List all VIPs
	ListVIPs() ([]*VIP, error)

	// Get a VIP by name
	GetVIP(mkey string) (*VIP, error)

	// Create a new VIP
	CreateVIP(*VIP) (string, error)

	// Update a VIP
	UpdateVIP(*VIP) error

	// Delete a VIP by name
	DeleteVIP(mkey string) error

	// List all FirewallVip46s
	ListFirewallVip46s() ([]*FirewallVip46, error)

	// Get a FirewallVip46 by name
	GetFirewallVip46(mkey string) (*FirewallVip46, error)

	// Create a new FirewallVip46
	CreateFirewallVip46(*FirewallVip46) (string, error)

	// Update a FirewallVip46
	UpdateFirewallVip46(*FirewallVip46) error

	// Delete a FirewallVip46 by name
	DeleteFirewallVip46(mkey string) error

	// List all FirewallVip6s
	ListFirewallVip6s() ([]*FirewallVip6, error)

	// Get a FirewallVip6 by name
	GetFirewallVip6(mkey string) (*FirewallVip6, error)

	// Create a new FirewallVip6
	CreateFirewallVip6(*FirewallVip6) (string, error)

	// Update a FirewallVip6
	UpdateFirewallVip6(*FirewallVip6) error

	// Delete a FirewallVip6 by name
	DeleteFirewallVip6(mkey string) error

	// List all FirewallVip64s
	ListFirewallVip64s() ([]*FirewallVip64, error)

	// Get a FirewallVip64 by name
	GetFirewallVip64(mkey string) (*FirewallVip64, error)

	// Create a new FirewallVip64
	CreateFirewallVip64(*FirewallVip64) (string, error)

	// Update a FirewallVip64
	UpdateFirewallVip64(*FirewallVip64) error

	// Delete a FirewallVip64 by name
	DeleteFirewallVip64(mkey string) error

	// List all FirewallVipgrps
	ListFirewallVipgrps() ([]*FirewallVipgrp, error)

	// Get a FirewallVipgrp by name
	GetFirewallVipgrp(mkey string) (*FirewallVipgrp, error)

	// Create a new FirewallVipgrp
	CreateFirewallVipgrp(*FirewallVipgrp) (string, error)

	// Update a FirewallVipgrp
	UpdateFirewallVipgrp(*FirewallVipgrp) error

	// Delete a FirewallVipgrp by name
	DeleteFirewallVipgrp(mkey string) error

	// List all FirewallVipgrp46s
	ListFirewallVipgrp46s() ([]*FirewallVipgrp46, error)

	// Get a FirewallVipgrp46 by name
	GetFirewallVipgrp46(mkey string) (*FirewallVipgrp46, error)

	// Create a new FirewallVipgrp46
	CreateFirewallVipgrp46(*FirewallVipgrp46) (string, error)

	// Update a FirewallVipgrp46
	UpdateFirewallVipgrp46(*FirewallVipgrp46) error

	// Delete a FirewallVipgrp46 by name
	DeleteFirewallVipgrp46(mkey string) error

	// List all FirewallVipgrp6s
	ListFirewallVipgrp6s() ([]*FirewallVipgrp6, error)

	// Get a FirewallVipgrp6 by name
	GetFirewallVipgrp6(mkey string) (*FirewallVipgrp6, error)

	// Create a new FirewallVipgrp6
	CreateFirewallVipgrp6(*FirewallVipgrp6) (string, error)

	// Update a FirewallVipgrp6
	UpdateFirewallVipgrp6(*FirewallVipgrp6) error

	// Delete a FirewallVipgrp6 by name
	DeleteFirewallVipgrp6(mkey string) error

	// List all FirewallVipgrp64s
	ListFirewallVipgrp64s() ([]*FirewallVipgrp64, error)

	// Get a FirewallVipgrp64 by name
	GetFirewallVipgrp64(mkey string) (*FirewallVipgrp64, error)

	// Create a new FirewallVipgrp64
	CreateFirewallVipgrp64(*FirewallVipgrp64) (string, error)

	// Update a FirewallVipgrp64
	UpdateFirewallVipgrp64(*FirewallVipgrp64) error

	// Delete a FirewallVipgrp64 by name
	DeleteFirewallVipgrp64(mkey string) error

	// List all FirewallProfileProtocolOptionss
	ListFirewallProfileProtocolOptionss() ([]*FirewallProfileProtocolOptions, error)

	// Get a FirewallProfileProtocolOptions by name
	GetFirewallProfileProtocolOptions(mkey string) (*FirewallProfileProtocolOptions, error)

	// Create a new FirewallProfileProtocolOptions
	CreateFirewallProfileProtocolOptions(*FirewallProfileProtocolOptions) (string, error)

	// Update a FirewallProfileProtocolOptions
	UpdateFirewallProfileProtocolOptions(*FirewallProfileProtocolOptions) error

	// Delete a FirewallProfileProtocolOptions by name
	DeleteFirewallProfileProtocolOptions(mkey string) error

	// List all FirewallSslSshProfiles
	ListFirewallSslSshProfiles() ([]*FirewallSslSshProfile, error)

	// Get a FirewallSslSshProfile by name
	GetFirewallSslSshProfile(mkey string) (*FirewallSslSshProfile, error)

	// Create a new FirewallSslSshProfile
	CreateFirewallSslSshProfile(*FirewallSslSshProfile) (string, error)

	// Update a FirewallSslSshProfile
	UpdateFirewallSslSshProfile(*FirewallSslSshProfile) error

	// Delete a FirewallSslSshProfile by name
	DeleteFirewallSslSshProfile(mkey string) error

	// List all FirewallProfileGroups
	ListFirewallProfileGroups() ([]*FirewallProfileGroup, error)

	// Get a FirewallProfileGroup by name
	GetFirewallProfileGroup(mkey string) (*FirewallProfileGroup, error)

	// Create a new FirewallProfileGroup
	CreateFirewallProfileGroup(*FirewallProfileGroup) (string, error)

	// Update a FirewallProfileGroup
	UpdateFirewallProfileGroup(*FirewallProfileGroup) error

	// Delete a FirewallProfileGroup by name
	DeleteFirewallProfileGroup(mkey string) error

	// List all FirewallSslServers
	ListFirewallSslServers() ([]*FirewallSslServer, error)

	// Get a FirewallSslServer by name
	GetFirewallSslServer(mkey string) (*FirewallSslServer, error)

	// Create a new FirewallSslServer
	CreateFirewallSslServer(*FirewallSslServer) (string, error)

	// Update a FirewallSslServer
	UpdateFirewallSslServer(*FirewallSslServer) error

	// Delete a FirewallSslServer by name
	DeleteFirewallSslServer(mkey string) error

	// List all FirewallIdentityBasedRoutes
	ListFirewallIdentityBasedRoutes() ([]*FirewallIdentityBasedRoute, error)

	// Get a FirewallIdentityBasedRoute by name
	GetFirewallIdentityBasedRoute(mkey string) (*FirewallIdentityBasedRoute, error)

	// Create a new FirewallIdentityBasedRoute
	CreateFirewallIdentityBasedRoute(*FirewallIdentityBasedRoute) (string, error)

	// Update a FirewallIdentityBasedRoute
	UpdateFirewallIdentityBasedRoute(*FirewallIdentityBasedRoute) error

	// Delete a FirewallIdentityBasedRoute by name
	DeleteFirewallIdentityBasedRoute(mkey string) error

	// List all FirewallPolicys
	ListFirewallPolicys() ([]*FirewallPolicy, error)

	// Get a FirewallPolicy by name
	GetFirewallPolicy(mkey int) (*FirewallPolicy, error)

	// Create a new FirewallPolicy
	CreateFirewallPolicy(*FirewallPolicy) (int, error)

	// Update a FirewallPolicy
	UpdateFirewallPolicy(*FirewallPolicy) error

	// Delete a FirewallPolicy by name
	DeleteFirewallPolicy(mkey int) error

	// List all FirewallShapingPolicys
	ListFirewallShapingPolicys() ([]*FirewallShapingPolicy, error)

	// Get a FirewallShapingPolicy by name
	GetFirewallShapingPolicy(mkey int) (*FirewallShapingPolicy, error)

	// Create a new FirewallShapingPolicy
	CreateFirewallShapingPolicy(*FirewallShapingPolicy) (int, error)

	// Update a FirewallShapingPolicy
	UpdateFirewallShapingPolicy(*FirewallShapingPolicy) error

	// Delete a FirewallShapingPolicy by name
	DeleteFirewallShapingPolicy(mkey int) error

	// List all FirewallLocalInPolicys
	ListFirewallLocalInPolicys() ([]*FirewallLocalInPolicy, error)

	// Get a FirewallLocalInPolicy by name
	GetFirewallLocalInPolicy(mkey int) (*FirewallLocalInPolicy, error)

	// Create a new FirewallLocalInPolicy
	CreateFirewallLocalInPolicy(*FirewallLocalInPolicy) (int, error)

	// Update a FirewallLocalInPolicy
	UpdateFirewallLocalInPolicy(*FirewallLocalInPolicy) error

	// Delete a FirewallLocalInPolicy by name
	DeleteFirewallLocalInPolicy(mkey int) error

	// List all FirewallPolicy6s
	ListFirewallPolicy6s() ([]*FirewallPolicy6, error)

	// Get a FirewallPolicy6 by name
	GetFirewallPolicy6(mkey int) (*FirewallPolicy6, error)

	// Create a new FirewallPolicy6
	CreateFirewallPolicy6(*FirewallPolicy6) (int, error)

	// Update a FirewallPolicy6
	UpdateFirewallPolicy6(*FirewallPolicy6) error

	// Delete a FirewallPolicy6 by name
	DeleteFirewallPolicy6(mkey int) error

	// List all FirewallLocalInPolicy6s
	ListFirewallLocalInPolicy6s() ([]*FirewallLocalInPolicy6, error)

	// Get a FirewallLocalInPolicy6 by name
	GetFirewallLocalInPolicy6(mkey int) (*FirewallLocalInPolicy6, error)

	// Create a new FirewallLocalInPolicy6
	CreateFirewallLocalInPolicy6(*FirewallLocalInPolicy6) (int, error)

	// Update a FirewallLocalInPolicy6
	UpdateFirewallLocalInPolicy6(*FirewallLocalInPolicy6) error

	// Delete a FirewallLocalInPolicy6 by name
	DeleteFirewallLocalInPolicy6(mkey int) error

	// List all FirewallTtlPolicys
	ListFirewallTtlPolicys() ([]*FirewallTtlPolicy, error)

	// Get a FirewallTtlPolicy by name
	GetFirewallTtlPolicy(mkey int) (*FirewallTtlPolicy, error)

	// Create a new FirewallTtlPolicy
	CreateFirewallTtlPolicy(*FirewallTtlPolicy) (int, error)

	// Update a FirewallTtlPolicy
	UpdateFirewallTtlPolicy(*FirewallTtlPolicy) error

	// Delete a FirewallTtlPolicy by name
	DeleteFirewallTtlPolicy(mkey int) error

	// List all FirewallPolicy64s
	ListFirewallPolicy64s() ([]*FirewallPolicy64, error)

	// Get a FirewallPolicy64 by name
	GetFirewallPolicy64(mkey int) (*FirewallPolicy64, error)

	// Create a new FirewallPolicy64
	CreateFirewallPolicy64(*FirewallPolicy64) (int, error)

	// Update a FirewallPolicy64
	UpdateFirewallPolicy64(*FirewallPolicy64) error

	// Delete a FirewallPolicy64 by name
	DeleteFirewallPolicy64(mkey int) error

	// List all FirewallPolicy46s
	ListFirewallPolicy46s() ([]*FirewallPolicy46, error)

	// Get a FirewallPolicy46 by name
	GetFirewallPolicy46(mkey int) (*FirewallPolicy46, error)

	// Create a new FirewallPolicy46
	CreateFirewallPolicy46(*FirewallPolicy46) (int, error)

	// Update a FirewallPolicy46
	UpdateFirewallPolicy46(*FirewallPolicy46) error

	// Delete a FirewallPolicy46 by name
	DeleteFirewallPolicy46(mkey int) error

	// List all FirewallProxyAddresss
	ListFirewallProxyAddresss() ([]*FirewallProxyAddress, error)

	// Get a FirewallProxyAddress by name
	GetFirewallProxyAddress(mkey string) (*FirewallProxyAddress, error)

	// Create a new FirewallProxyAddress
	CreateFirewallProxyAddress(*FirewallProxyAddress) (string, error)

	// Update a FirewallProxyAddress
	UpdateFirewallProxyAddress(*FirewallProxyAddress) error

	// Delete a FirewallProxyAddress by name
	DeleteFirewallProxyAddress(mkey string) error

	// List all FirewallProxyAddrgrps
	ListFirewallProxyAddrgrps() ([]*FirewallProxyAddrgrp, error)

	// Get a FirewallProxyAddrgrp by name
	GetFirewallProxyAddrgrp(mkey string) (*FirewallProxyAddrgrp, error)

	// Create a new FirewallProxyAddrgrp
	CreateFirewallProxyAddrgrp(*FirewallProxyAddrgrp) (string, error)

	// Update a FirewallProxyAddrgrp
	UpdateFirewallProxyAddrgrp(*FirewallProxyAddrgrp) error

	// Delete a FirewallProxyAddrgrp by name
	DeleteFirewallProxyAddrgrp(mkey string) error

	// List all FirewallProxyPolicys
	ListFirewallProxyPolicys() ([]*FirewallProxyPolicy, error)

	// Get a FirewallProxyPolicy by name
	GetFirewallProxyPolicy(mkey int) (*FirewallProxyPolicy, error)

	// Create a new FirewallProxyPolicy
	CreateFirewallProxyPolicy(*FirewallProxyPolicy) (int, error)

	// Update a FirewallProxyPolicy
	UpdateFirewallProxyPolicy(*FirewallProxyPolicy) error

	// Delete a FirewallProxyPolicy by name
	DeleteFirewallProxyPolicy(mkey int) error

	// List all FirewallDnstranslations
	ListFirewallDnstranslations() ([]*FirewallDnstranslation, error)

	// Get a FirewallDnstranslation by name
	GetFirewallDnstranslation(mkey int) (*FirewallDnstranslation, error)

	// Create a new FirewallDnstranslation
	CreateFirewallDnstranslation(*FirewallDnstranslation) (int, error)

	// Update a FirewallDnstranslation
	UpdateFirewallDnstranslation(*FirewallDnstranslation) error

	// Delete a FirewallDnstranslation by name
	DeleteFirewallDnstranslation(mkey int) error

	// List all FirewallMulticastPolicys
	ListFirewallMulticastPolicys() ([]*FirewallMulticastPolicy, error)

	// Get a FirewallMulticastPolicy by name
	GetFirewallMulticastPolicy(mkey int) (*FirewallMulticastPolicy, error)

	// Create a new FirewallMulticastPolicy
	CreateFirewallMulticastPolicy(*FirewallMulticastPolicy) (int, error)

	// Update a FirewallMulticastPolicy
	UpdateFirewallMulticastPolicy(*FirewallMulticastPolicy) error

	// Delete a FirewallMulticastPolicy by name
	DeleteFirewallMulticastPolicy(mkey int) error

	// List all FirewallMulticastPolicy6s
	ListFirewallMulticastPolicy6s() ([]*FirewallMulticastPolicy6, error)

	// Get a FirewallMulticastPolicy6 by name
	GetFirewallMulticastPolicy6(mkey int) (*FirewallMulticastPolicy6, error)

	// Create a new FirewallMulticastPolicy6
	CreateFirewallMulticastPolicy6(*FirewallMulticastPolicy6) (int, error)

	// Update a FirewallMulticastPolicy6
	UpdateFirewallMulticastPolicy6(*FirewallMulticastPolicy6) error

	// Delete a FirewallMulticastPolicy6 by name
	DeleteFirewallMulticastPolicy6(mkey int) error

	// List all FirewallInterfacePolicys
	ListFirewallInterfacePolicys() ([]*FirewallInterfacePolicy, error)

	// Get a FirewallInterfacePolicy by name
	GetFirewallInterfacePolicy(mkey int) (*FirewallInterfacePolicy, error)

	// Create a new FirewallInterfacePolicy
	CreateFirewallInterfacePolicy(*FirewallInterfacePolicy) (int, error)

	// Update a FirewallInterfacePolicy
	UpdateFirewallInterfacePolicy(*FirewallInterfacePolicy) error

	// Delete a FirewallInterfacePolicy by name
	DeleteFirewallInterfacePolicy(mkey int) error

	// List all FirewallInterfacePolicy6s
	ListFirewallInterfacePolicy6s() ([]*FirewallInterfacePolicy6, error)

	// Get a FirewallInterfacePolicy6 by name
	GetFirewallInterfacePolicy6(mkey int) (*FirewallInterfacePolicy6, error)

	// Create a new FirewallInterfacePolicy6
	CreateFirewallInterfacePolicy6(*FirewallInterfacePolicy6) (int, error)

	// Update a FirewallInterfacePolicy6
	UpdateFirewallInterfacePolicy6(*FirewallInterfacePolicy6) error

	// Delete a FirewallInterfacePolicy6 by name
	DeleteFirewallInterfacePolicy6(mkey int) error

	// List all FirewallDoSPolicys
	ListFirewallDoSPolicys() ([]*FirewallDoSPolicy, error)

	// Get a FirewallDoSPolicy by name
	GetFirewallDoSPolicy(mkey int) (*FirewallDoSPolicy, error)

	// Create a new FirewallDoSPolicy
	CreateFirewallDoSPolicy(*FirewallDoSPolicy) (int, error)

	// Update a FirewallDoSPolicy
	UpdateFirewallDoSPolicy(*FirewallDoSPolicy) error

	// Delete a FirewallDoSPolicy by name
	DeleteFirewallDoSPolicy(mkey int) error

	// List all FirewallDoSPolicy6s
	ListFirewallDoSPolicy6s() ([]*FirewallDoSPolicy6, error)

	// Get a FirewallDoSPolicy6 by name
	GetFirewallDoSPolicy6(mkey int) (*FirewallDoSPolicy6, error)

	// Create a new FirewallDoSPolicy6
	CreateFirewallDoSPolicy6(*FirewallDoSPolicy6) (int, error)

	// Update a FirewallDoSPolicy6
	UpdateFirewallDoSPolicy6(*FirewallDoSPolicy6) error

	// Delete a FirewallDoSPolicy6 by name
	DeleteFirewallDoSPolicy6(mkey int) error

	// List all FirewallSniffers
	ListFirewallSniffers() ([]*FirewallSniffer, error)

	// Get a FirewallSniffer by name
	GetFirewallSniffer(mkey int) (*FirewallSniffer, error)

	// Create a new FirewallSniffer
	CreateFirewallSniffer(*FirewallSniffer) (int, error)

	// Update a FirewallSniffer
	UpdateFirewallSniffer(*FirewallSniffer) error

	// Delete a FirewallSniffer by name
	DeleteFirewallSniffer(mkey int) error

	// List all FirewallCentralSnatMaps
	ListFirewallCentralSnatMaps() ([]*FirewallCentralSnatMap, error)

	// Get a FirewallCentralSnatMap by name
	GetFirewallCentralSnatMap(mkey int) (*FirewallCentralSnatMap, error)

	// Create a new FirewallCentralSnatMap
	CreateFirewallCentralSnatMap(*FirewallCentralSnatMap) (int, error)

	// Update a FirewallCentralSnatMap
	UpdateFirewallCentralSnatMap(*FirewallCentralSnatMap) error

	// Delete a FirewallCentralSnatMap by name
	DeleteFirewallCentralSnatMap(mkey int) error

	// List all FirewallIpTranslations
	ListFirewallIpTranslations() ([]*FirewallIpTranslation, error)

	// Get a FirewallIpTranslation by name
	GetFirewallIpTranslation(mkey int) (*FirewallIpTranslation, error)

	// Create a new FirewallIpTranslation
	CreateFirewallIpTranslation(*FirewallIpTranslation) (int, error)

	// Update a FirewallIpTranslation
	UpdateFirewallIpTranslation(*FirewallIpTranslation) error

	// Delete a FirewallIpTranslation by name
	DeleteFirewallIpTranslation(mkey int) error

	// List all CertificateCas
	ListCertificateCas() ([]*CertificateCa, error)

	// Get a CertificateCa by name
	GetCertificateCa(mkey string) (*CertificateCa, error)

	// Create a new CertificateCa
	CreateCertificateCa(*CertificateCa) (string, error)

	// Update a CertificateCa
	UpdateCertificateCa(*CertificateCa) error

	// Delete a CertificateCa by name
	DeleteCertificateCa(mkey string) error

	// List all CertificateLocals
	ListCertificateLocals() ([]*CertificateLocal, error)

	// Get a CertificateLocal by name
	GetCertificateLocal(mkey string) (*CertificateLocal, error)

	// Create a new CertificateLocal
	CreateCertificateLocal(*CertificateLocal) (string, error)

	// Update a CertificateLocal
	UpdateCertificateLocal(*CertificateLocal) error

	// Delete a CertificateLocal by name
	DeleteCertificateLocal(mkey string) error

	// List all CertificateCrls
	ListCertificateCrls() ([]*CertificateCrl, error)

	// Get a CertificateCrl by name
	GetCertificateCrl(mkey string) (*CertificateCrl, error)

	// Create a new CertificateCrl
	CreateCertificateCrl(*CertificateCrl) (string, error)

	// Update a CertificateCrl
	UpdateCertificateCrl(*CertificateCrl) error

	// Delete a CertificateCrl by name
	DeleteCertificateCrl(mkey string) error
}

// Fake Fortigate Client
type FakeClient struct {
	FirewallAddresss map[string]*FirewallAddress

	FirewallMulticastAddresss map[string]*FirewallMulticastAddress

	FirewallAddress6s map[string]*FirewallAddress6

	FirewallMulticastAddress6s map[string]*FirewallMulticastAddress6

	FirewallAddrgrps map[string]*FirewallAddrgrp

	FirewallAddrgrp6s map[string]*FirewallAddrgrp6

	FirewallInternetServices map[int]*FirewallInternetService

	FirewallInternetServiceCounter int

	FirewallInternetServiceCustoms map[string]*FirewallInternetServiceCustom

	FirewallIppools map[string]*FirewallIppool

	FirewallIppool6s map[string]*FirewallIppool6

	FirewallLdbMonitors map[string]*FirewallLdbMonitor

	FirewallVips map[string]*FirewallVip

	VIPs map[string]*VIP

	FirewallVip46s map[string]*FirewallVip46

	FirewallVip6s map[string]*FirewallVip6

	FirewallVip64s map[string]*FirewallVip64

	FirewallVipgrps map[string]*FirewallVipgrp

	FirewallVipgrp46s map[string]*FirewallVipgrp46

	FirewallVipgrp6s map[string]*FirewallVipgrp6

	FirewallVipgrp64s map[string]*FirewallVipgrp64

	FirewallProfileProtocolOptionss map[string]*FirewallProfileProtocolOptions

	FirewallSslSshProfiles map[string]*FirewallSslSshProfile

	FirewallProfileGroups map[string]*FirewallProfileGroup

	FirewallSslServers map[string]*FirewallSslServer

	FirewallIdentityBasedRoutes map[string]*FirewallIdentityBasedRoute

	FirewallPolicys map[int]*FirewallPolicy

	FirewallPolicyCounter int

	FirewallShapingPolicys map[int]*FirewallShapingPolicy

	FirewallShapingPolicyCounter int

	FirewallLocalInPolicys map[int]*FirewallLocalInPolicy

	FirewallLocalInPolicyCounter int

	FirewallPolicy6s map[int]*FirewallPolicy6

	FirewallPolicy6Counter int

	FirewallLocalInPolicy6s map[int]*FirewallLocalInPolicy6

	FirewallLocalInPolicy6Counter int

	FirewallTtlPolicys map[int]*FirewallTtlPolicy

	FirewallTtlPolicyCounter int

	FirewallPolicy64s map[int]*FirewallPolicy64

	FirewallPolicy64Counter int

	FirewallPolicy46s map[int]*FirewallPolicy46

	FirewallPolicy46Counter int

	FirewallProxyAddresss map[string]*FirewallProxyAddress

	FirewallProxyAddrgrps map[string]*FirewallProxyAddrgrp

	FirewallProxyPolicys map[int]*FirewallProxyPolicy

	FirewallProxyPolicyCounter int

	FirewallDnstranslations map[int]*FirewallDnstranslation

	FirewallDnstranslationCounter int

	FirewallMulticastPolicys map[int]*FirewallMulticastPolicy

	FirewallMulticastPolicyCounter int

	FirewallMulticastPolicy6s map[int]*FirewallMulticastPolicy6

	FirewallMulticastPolicy6Counter int

	FirewallInterfacePolicys map[int]*FirewallInterfacePolicy

	FirewallInterfacePolicyCounter int

	FirewallInterfacePolicy6s map[int]*FirewallInterfacePolicy6

	FirewallInterfacePolicy6Counter int

	FirewallDoSPolicys map[int]*FirewallDoSPolicy

	FirewallDoSPolicyCounter int

	FirewallDoSPolicy6s map[int]*FirewallDoSPolicy6

	FirewallDoSPolicy6Counter int

	FirewallSniffers map[int]*FirewallSniffer

	FirewallSnifferCounter int

	FirewallCentralSnatMaps map[int]*FirewallCentralSnatMap

	FirewallCentralSnatMapCounter int

	FirewallIpTranslations map[int]*FirewallIpTranslation

	FirewallIpTranslationCounter int

	CertificateCas map[string]*CertificateCa

	CertificateLocals map[string]*CertificateLocal

	CertificateCrls map[string]*CertificateCrl
}

// Create a new fake client
func NewFakeClient() *FakeClient {
	return &FakeClient{

		FirewallAddresss: map[string]*FirewallAddress{},

		FirewallMulticastAddresss: map[string]*FirewallMulticastAddress{},

		FirewallAddress6s: map[string]*FirewallAddress6{},

		FirewallMulticastAddress6s: map[string]*FirewallMulticastAddress6{},

		FirewallAddrgrps: map[string]*FirewallAddrgrp{},

		FirewallAddrgrp6s: map[string]*FirewallAddrgrp6{},

		FirewallInternetServices:       map[int]*FirewallInternetService{},
		FirewallInternetServiceCounter: 1,

		FirewallInternetServiceCustoms: map[string]*FirewallInternetServiceCustom{},

		FirewallIppools: map[string]*FirewallIppool{},

		FirewallIppool6s: map[string]*FirewallIppool6{},

		FirewallLdbMonitors: map[string]*FirewallLdbMonitor{},

		FirewallVips: map[string]*FirewallVip{},

		VIPs: map[string]*VIP{},

		FirewallVip46s: map[string]*FirewallVip46{},

		FirewallVip6s: map[string]*FirewallVip6{},

		FirewallVip64s: map[string]*FirewallVip64{},

		FirewallVipgrps: map[string]*FirewallVipgrp{},

		FirewallVipgrp46s: map[string]*FirewallVipgrp46{},

		FirewallVipgrp6s: map[string]*FirewallVipgrp6{},

		FirewallVipgrp64s: map[string]*FirewallVipgrp64{},

		FirewallProfileProtocolOptionss: map[string]*FirewallProfileProtocolOptions{},

		FirewallSslSshProfiles: map[string]*FirewallSslSshProfile{},

		FirewallProfileGroups: map[string]*FirewallProfileGroup{},

		FirewallSslServers: map[string]*FirewallSslServer{},

		FirewallIdentityBasedRoutes: map[string]*FirewallIdentityBasedRoute{},

		FirewallPolicys:       map[int]*FirewallPolicy{},
		FirewallPolicyCounter: 1,

		FirewallShapingPolicys:       map[int]*FirewallShapingPolicy{},
		FirewallShapingPolicyCounter: 1,

		FirewallLocalInPolicys:       map[int]*FirewallLocalInPolicy{},
		FirewallLocalInPolicyCounter: 1,

		FirewallPolicy6s:       map[int]*FirewallPolicy6{},
		FirewallPolicy6Counter: 1,

		FirewallLocalInPolicy6s:       map[int]*FirewallLocalInPolicy6{},
		FirewallLocalInPolicy6Counter: 1,

		FirewallTtlPolicys:       map[int]*FirewallTtlPolicy{},
		FirewallTtlPolicyCounter: 1,

		FirewallPolicy64s:       map[int]*FirewallPolicy64{},
		FirewallPolicy64Counter: 1,

		FirewallPolicy46s:       map[int]*FirewallPolicy46{},
		FirewallPolicy46Counter: 1,

		FirewallProxyAddresss: map[string]*FirewallProxyAddress{},

		FirewallProxyAddrgrps: map[string]*FirewallProxyAddrgrp{},

		FirewallProxyPolicys:       map[int]*FirewallProxyPolicy{},
		FirewallProxyPolicyCounter: 1,

		FirewallDnstranslations:       map[int]*FirewallDnstranslation{},
		FirewallDnstranslationCounter: 1,

		FirewallMulticastPolicys:       map[int]*FirewallMulticastPolicy{},
		FirewallMulticastPolicyCounter: 1,

		FirewallMulticastPolicy6s:       map[int]*FirewallMulticastPolicy6{},
		FirewallMulticastPolicy6Counter: 1,

		FirewallInterfacePolicys:       map[int]*FirewallInterfacePolicy{},
		FirewallInterfacePolicyCounter: 1,

		FirewallInterfacePolicy6s:       map[int]*FirewallInterfacePolicy6{},
		FirewallInterfacePolicy6Counter: 1,

		FirewallDoSPolicys:       map[int]*FirewallDoSPolicy{},
		FirewallDoSPolicyCounter: 1,

		FirewallDoSPolicy6s:       map[int]*FirewallDoSPolicy6{},
		FirewallDoSPolicy6Counter: 1,

		FirewallSniffers:       map[int]*FirewallSniffer{},
		FirewallSnifferCounter: 1,

		FirewallCentralSnatMaps:       map[int]*FirewallCentralSnatMap{},
		FirewallCentralSnatMapCounter: 1,

		FirewallIpTranslations:       map[int]*FirewallIpTranslation{},
		FirewallIpTranslationCounter: 1,

		CertificateCas: map[string]*CertificateCa{},

		CertificateLocals: map[string]*CertificateLocal{},

		CertificateCrls: map[string]*CertificateCrl{},
	}
}

// Enable/disable use of this address in the static route configuration.
type FirewallAddressAllowRouting string

// IP address list.
type FirewallAddressList struct {

	// IP.
	Ip string `json:"ip,omitempty"`
}

// SDN.
type FirewallAddressSdn string

// Names of object-tags applied to address.
type FirewallAddressTags struct {

	// Tag name.
	Name string `json:"name,omitempty"`
}

// Type of address.
type FirewallAddressType string

// Enable/disable address visibility in the GUI.
type FirewallAddressVisibility string

const (
	// Enable use of this address in the static route configuration.
	FirewallAddressAllowRoutingEnable FirewallAddressAllowRouting = "enable"

	// Disable use of this address in the static route configuration.
	FirewallAddressAllowRoutingDisable FirewallAddressAllowRouting = "disable"
)

const (
	// Application Centric Infrastructure.
	FirewallAddressSdnAci FirewallAddressSdn = "aci"

	// Amazon Web Services.
	FirewallAddressSdnAws FirewallAddressSdn = "aws"

	// VMware NSX.
	FirewallAddressSdnNsx FirewallAddressSdn = "nsx"

	// Nuage Virtualized Services Platform.
	FirewallAddressSdnNuage FirewallAddressSdn = "nuage"
)

const (
	// Standard IPv4 address with subnet mask.
	FirewallAddressTypeIpmask FirewallAddressType = "ipmask"

	// Range of IPv4 addresses between two specified addresses (inclusive).
	FirewallAddressTypeIprange FirewallAddressType = "iprange"

	// Fully Qualified Domain Name address.
	FirewallAddressTypeFqdn FirewallAddressType = "fqdn"

	// IP addresses from a specified country.
	FirewallAddressTypeGeography FirewallAddressType = "geography"

	// Standard IPv4 using a wildcard subnet mask.
	FirewallAddressTypeWildcard FirewallAddressType = "wildcard"

	// Fully Qualified Domain Name with wildcard characters.
	FirewallAddressTypeWildcardFqdn FirewallAddressType = "wildcard-fqdn"

	// Dynamic address object for SDN.
	FirewallAddressTypeDynamic FirewallAddressType = "dynamic"
)

const (
	// Show in address4 selection.
	FirewallAddressVisibilityEnable FirewallAddressVisibility = "enable"

	// Hide from address4 selection.
	FirewallAddressVisibilityDisable FirewallAddressVisibility = "disable"
)

// Configure IPv4 addresses.
type FirewallAddress struct {

	// Enable/disable use of this address in the static route configuration.
	AllowRouting FirewallAddressAllowRouting `json:"allow-routing,omitempty"`

	// Network interface associated with address.
	AssociatedInterface string `json:"associated-interface,omitempty"`

	// Defines the minimal TTL of individual IP addresses in FQDN cache measured in seconds.
	CacheTtl int `json:"cache-ttl,omitempty"`

	// Color of icon on the GUI.
	Color int `json:"color,omitempty"`

	// Comment.
	Comment string `json:"comment,omitempty"`

	// IP addresses associated to a specific country.
	Country string `json:"country,omitempty"`

	// Final IP address (inclusive) in the range for the address.
	EndIp string `json:"end-ip,omitempty"`

	// Endpoint group name.
	EpgName string `json:"epg-name,omitempty"`

	// Fully Qualified Domain Name address.
	Fqdn string `json:"fqdn,omitempty"`

	// IP address list.
	List []FirewallAddressList `json:"list,omitempty"`

	// Address name.
	Name string `json:"name,omitempty"`

	// Object ID for NSX.
	ObjId int `json:"obj-id,omitempty"`

	// Organization domain name (Syntax: organization/domain).
	Organization string `json:"organization,omitempty"`

	// Policy group name.
	PolicyGroup string `json:"policy-group,omitempty"`

	// SDN.
	Sdn FirewallAddressSdn `json:"sdn,omitempty"`

	// SDN Tag.
	SdnTag string `json:"sdn-tag,omitempty"`

	// First IP address (inclusive) in the range for the address.
	StartIp string `json:"start-ip,omitempty"`

	// IP address and subnet mask of address.
	Subnet string `json:"subnet,omitempty"`

	// Subnet name.
	SubnetName string `json:"subnet-name,omitempty"`

	// Names of object-tags applied to address.
	Tags []FirewallAddressTags `json:"tags,omitempty"`

	// Tenant.
	Tenant string `json:"tenant,omitempty"`

	// Type of address.
	Type FirewallAddressType `json:"type,omitempty"`

	// Universally Unique Identifier (UUID; automatically assigned but can be manually reset).
	Uuid string `json:"uuid,omitempty"`

	// Enable/disable address visibility in the GUI.
	Visibility FirewallAddressVisibility `json:"visibility,omitempty"`

	// IP address and wildcard netmask.
	Wildcard string `json:"wildcard,omitempty"`

	// Fully Qualified Domain Name with wildcard characters.
	WildcardFqdn string `json:"wildcard-fqdn,omitempty"`
}

// Returns the value that identifies a FirewallAddress
func (x *FirewallAddress) MKey() string {
	return x.Name
}

// The results of a Get or List operation
type FirewallAddressResults struct {
	Results []*FirewallAddress `json:"results"`
	Mkey    string             `json:"mkey"`
	Result
}

// List all FirewallAddresss
func (c *WebClient) ListFirewallAddresss() (res []*FirewallAddress, err error) {
	var errmsg Result
	var results FirewallAddressResults
	_, err = c.napping.Get(c.URL+"/api/v2/firewall/address", nil, &results, nil)
	if err != nil {
		return []*FirewallAddress{}, fmt.Errorf("error listing FirewallAddresss: %s", err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return []*FirewallAddress{}, fmt.Errorf("error listing FirewallAddress: not found")
		} else {
			return []*FirewallAddress{}, fmt.Errorf("error listing FirewallAddress: %s", errmsg.Status)
		}
	}
	res = results.Results
	return
}

// Get a FirewallAddress by name
func (c *WebClient) GetFirewallAddress(mkey string) (res *FirewallAddress, err error) {
	var errmsg Result
	var results FirewallAddressResults
	_, err = c.napping.Get(c.URL+"/api/v2/firewall/address/"+mkey, nil, &results, &errmsg)
	if err != nil {
		return &FirewallAddress{}, fmt.Errorf("error getting FirewallAddress '%s': %s", mkey, err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return &FirewallAddress{}, fmt.Errorf("error getting FirewallAddress '%s': not found", mkey)
		} else {
			return &FirewallAddress{}, fmt.Errorf("error getting FirewallAddress '%s': %s", mkey, errmsg.Status)
		}
	}
	if len(results.Results) == 0 {
		return &FirewallAddress{}, fmt.Errorf("error getting FirewallAddress '%s': not found", mkey)
	}

	res = results.Results[0]
	return
}

// Create a new FirewallAddress
func (c *WebClient) CreateFirewallAddress(obj *FirewallAddress) (id string, err error) {
	var errmsg Result
	var results FirewallAddressResults
	_, err = c.napping.Post(c.URL+"/api/v2/firewall/address", obj, &results, &errmsg)
	if err != nil {
		return "", fmt.Errorf("error creating FirewallAddress '%s': %s", obj.Name, err.Error())
	}
	if results.HTTPStatus == 200 {
		return
	}
	if errmsg.HTTPStatus != 200 {
		return "", fmt.Errorf("error creating FirewallAddress '%s': %s", obj.Name, errmsg.Status)
	}

	return
}

// Update a FirewallAddress
func (c *WebClient) UpdateFirewallAddress(obj *FirewallAddress) (err error) {
	var errmsg Result
	var results FirewallAddressResults
	_, err = c.napping.Put(c.URL+"/api/v2/firewall/address/"+obj.Name, obj, &results, &errmsg)
	if err != nil {
		return fmt.Errorf("error updating FirewallAddress '%s': %s", obj.Name, err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return fmt.Errorf("error updating FirewallAddress '%s': not found", obj.Name)
		} else {
			return fmt.Errorf("error updating FirewallAddress '%s': %s", obj.Name, errmsg.Status)
		}
	}

	return
}

// Delete a FirewallAddress by name
func (c *WebClient) DeleteFirewallAddress(mkey string) (err error) {
	var errmsg Result
	var results FirewallAddressResults
	_, err = c.napping.Delete(c.URL+"/api/v2/firewall/address/"+mkey, nil, &results, &errmsg)
	if err != nil {
		return fmt.Errorf("error deleting FirewallAddress '%s': %s", mkey, err.Error())
	}
	if results.HTTPStatus == 200 {
		return
	}
	if errmsg.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return fmt.Errorf("error deleting FirewallAddress '%s': not found", mkey)
		}
		return fmt.Errorf("error deleting FirewallAddress '%s': %s", mkey, errmsg.Status)
	}

	return
}

// List all FirewallAddresss
func (c *FakeClient) ListFirewallAddresss() (res []*FirewallAddress, err error) {
	for _, r := range c.FirewallAddresss {
		res = append(res, r)
	}
	return
}

// Get a FirewallAddress by name
func (c *FakeClient) GetFirewallAddress(mkey string) (*FirewallAddress, error) {
	if res, ok := c.FirewallAddresss[mkey]; ok {
		return res, nil
	} else {
		return &FirewallAddress{}, fmt.Errorf("error getting FirewallAddress '%s': not found", mkey)
	}
}

// Create a new FirewallAddress
func (c *FakeClient) CreateFirewallAddress(obj *FirewallAddress) (id string, err error) {
	id = obj.Name
	c.FirewallAddresss[id] = obj
	return
}

// Update a FirewallAddress
func (c *FakeClient) UpdateFirewallAddress(obj *FirewallAddress) (err error) {
	c.FirewallAddresss[obj.Name] = obj
	return nil
}

// Delete a FirewallAddress by name
func (c *FakeClient) DeleteFirewallAddress(mkey string) (err error) {
	delete(c.FirewallAddresss, mkey)
	return nil
}

// Names of object-tags (as configured in config system object-tag) applied to address.
type FirewallMulticastAddressTags struct {

	// Tag name.
	Name string `json:"name,omitempty"`
}

// Type of address object: multicast IP address range or broadcast IP/mask to be treated as a multicast address.
type FirewallMulticastAddressType string

// Enable/disable visibility of the multicast address on the GUI.
type FirewallMulticastAddressVisibility string

const (
	// Multicast range.
	FirewallMulticastAddressTypeMulticastrange FirewallMulticastAddressType = "multicastrange"

	// Broadcast IP/mask.
	FirewallMulticastAddressTypeBroadcastmask FirewallMulticastAddressType = "broadcastmask"
)

const (
	// Show the multicast address on the GUI.
	FirewallMulticastAddressVisibilityEnable FirewallMulticastAddressVisibility = "enable"

	// Hide the multicast address from the GUI.
	FirewallMulticastAddressVisibilityDisable FirewallMulticastAddressVisibility = "disable"
)

// Configure multicast addresses.
type FirewallMulticastAddress struct {

	// Interface associated with the address object. When setting up a policy, only addresses associated with this interface are available.
	AssociatedInterface string `json:"associated-interface,omitempty"`

	// Integer value to determine the color of the icon in the GUI (1 - 32, default = 0, which sets value to 1).
	Color int `json:"color,omitempty"`

	// Comment.
	Comment string `json:"comment,omitempty"`

	// Final IPv4 address (inclusive) in the range for the address.
	EndIp string `json:"end-ip,omitempty"`

	// Multicast address name.
	Name string `json:"name,omitempty"`

	// First IPv4 address (inclusive) in the range for the address.
	StartIp string `json:"start-ip,omitempty"`

	// Broadcast address and subnet.
	Subnet string `json:"subnet,omitempty"`

	// Names of object-tags (as configured in config system object-tag) applied to address.
	Tags []FirewallMulticastAddressTags `json:"tags,omitempty"`

	// Type of address object: multicast IP address range or broadcast IP/mask to be treated as a multicast address.
	Type FirewallMulticastAddressType `json:"type,omitempty"`

	// Enable/disable visibility of the multicast address on the GUI.
	Visibility FirewallMulticastAddressVisibility `json:"visibility,omitempty"`
}

// Returns the value that identifies a FirewallMulticastAddress
func (x *FirewallMulticastAddress) MKey() string {
	return x.Name
}

// The results of a Get or List operation
type FirewallMulticastAddressResults struct {
	Results []*FirewallMulticastAddress `json:"results"`
	Mkey    string                      `json:"mkey"`
	Result
}

// List all FirewallMulticastAddresss
func (c *WebClient) ListFirewallMulticastAddresss() (res []*FirewallMulticastAddress, err error) {
	var errmsg Result
	var results FirewallMulticastAddressResults
	_, err = c.napping.Get(c.URL+"/api/v2/firewall/multicast-address", nil, &results, nil)
	if err != nil {
		return []*FirewallMulticastAddress{}, fmt.Errorf("error listing FirewallMulticastAddresss: %s", err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return []*FirewallMulticastAddress{}, fmt.Errorf("error listing FirewallMulticastAddress: not found")
		} else {
			return []*FirewallMulticastAddress{}, fmt.Errorf("error listing FirewallMulticastAddress: %s", errmsg.Status)
		}
	}
	res = results.Results
	return
}

// Get a FirewallMulticastAddress by name
func (c *WebClient) GetFirewallMulticastAddress(mkey string) (res *FirewallMulticastAddress, err error) {
	var errmsg Result
	var results FirewallMulticastAddressResults
	_, err = c.napping.Get(c.URL+"/api/v2/firewall/multicast-address/"+mkey, nil, &results, &errmsg)
	if err != nil {
		return &FirewallMulticastAddress{}, fmt.Errorf("error getting FirewallMulticastAddress '%s': %s", mkey, err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return &FirewallMulticastAddress{}, fmt.Errorf("error getting FirewallMulticastAddress '%s': not found", mkey)
		} else {
			return &FirewallMulticastAddress{}, fmt.Errorf("error getting FirewallMulticastAddress '%s': %s", mkey, errmsg.Status)
		}
	}
	if len(results.Results) == 0 {
		return &FirewallMulticastAddress{}, fmt.Errorf("error getting FirewallMulticastAddress '%s': not found", mkey)
	}

	res = results.Results[0]
	return
}

// Create a new FirewallMulticastAddress
func (c *WebClient) CreateFirewallMulticastAddress(obj *FirewallMulticastAddress) (id string, err error) {
	var errmsg Result
	var results FirewallMulticastAddressResults
	_, err = c.napping.Post(c.URL+"/api/v2/firewall/multicast-address", obj, &results, &errmsg)
	if err != nil {
		return "", fmt.Errorf("error creating FirewallMulticastAddress '%s': %s", obj.Name, err.Error())
	}
	if results.HTTPStatus == 200 {
		return
	}
	if errmsg.HTTPStatus != 200 {
		return "", fmt.Errorf("error creating FirewallMulticastAddress '%s': %s", obj.Name, errmsg.Status)
	}

	return
}

// Update a FirewallMulticastAddress
func (c *WebClient) UpdateFirewallMulticastAddress(obj *FirewallMulticastAddress) (err error) {
	var errmsg Result
	var results FirewallMulticastAddressResults
	_, err = c.napping.Put(c.URL+"/api/v2/firewall/multicast-address/"+obj.Name, obj, &results, &errmsg)
	if err != nil {
		return fmt.Errorf("error updating FirewallMulticastAddress '%s': %s", obj.Name, err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return fmt.Errorf("error updating FirewallMulticastAddress '%s': not found", obj.Name)
		} else {
			return fmt.Errorf("error updating FirewallMulticastAddress '%s': %s", obj.Name, errmsg.Status)
		}
	}

	return
}

// Delete a FirewallMulticastAddress by name
func (c *WebClient) DeleteFirewallMulticastAddress(mkey string) (err error) {
	var errmsg Result
	var results FirewallMulticastAddressResults
	_, err = c.napping.Delete(c.URL+"/api/v2/firewall/multicast-address/"+mkey, nil, &results, &errmsg)
	if err != nil {
		return fmt.Errorf("error deleting FirewallMulticastAddress '%s': %s", mkey, err.Error())
	}
	if results.HTTPStatus == 200 {
		return
	}
	if errmsg.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return fmt.Errorf("error deleting FirewallMulticastAddress '%s': not found", mkey)
		}
		return fmt.Errorf("error deleting FirewallMulticastAddress '%s': %s", mkey, errmsg.Status)
	}

	return
}

// List all FirewallMulticastAddresss
func (c *FakeClient) ListFirewallMulticastAddresss() (res []*FirewallMulticastAddress, err error) {
	for _, r := range c.FirewallMulticastAddresss {
		res = append(res, r)
	}
	return
}

// Get a FirewallMulticastAddress by name
func (c *FakeClient) GetFirewallMulticastAddress(mkey string) (*FirewallMulticastAddress, error) {
	if res, ok := c.FirewallMulticastAddresss[mkey]; ok {
		return res, nil
	} else {
		return &FirewallMulticastAddress{}, fmt.Errorf("error getting FirewallMulticastAddress '%s': not found", mkey)
	}
}

// Create a new FirewallMulticastAddress
func (c *FakeClient) CreateFirewallMulticastAddress(obj *FirewallMulticastAddress) (id string, err error) {
	id = obj.Name
	c.FirewallMulticastAddresss[id] = obj
	return
}

// Update a FirewallMulticastAddress
func (c *FakeClient) UpdateFirewallMulticastAddress(obj *FirewallMulticastAddress) (err error) {
	c.FirewallMulticastAddresss[obj.Name] = obj
	return nil
}

// Delete a FirewallMulticastAddress by name
func (c *FakeClient) DeleteFirewallMulticastAddress(mkey string) (err error) {
	delete(c.FirewallMulticastAddresss, mkey)
	return nil
}

// IP address list.
type FirewallAddress6List struct {

	// IP.
	Ip string `json:"ip,omitempty"`
}

// SDN.
type FirewallAddress6Sdn string

// Names of object-tags applied to address. Tags need to be preconfigured in config system object-tag. Separate multiple tags with a space.
type FirewallAddress6Tags struct {

	// Tag name.
	Name string `json:"name,omitempty"`
}

// Type of IPv6 address object (default = ipprefix).
type FirewallAddress6Type string

// Enable/disable the visibility of the object in the GUI.
type FirewallAddress6Visibility string

const (
	// VMware NSX.
	FirewallAddress6SdnNsx FirewallAddress6Sdn = "nsx"
)

const (
	// Uses the IP prefix to define a range of IPv6 addresses.
	FirewallAddress6TypeIpprefix FirewallAddress6Type = "ipprefix"

	// Range of IPv6 addresses between two specified addresses (inclusive).
	FirewallAddress6TypeIprange FirewallAddress6Type = "iprange"

	// Dynamic address object for SDN.
	FirewallAddress6TypeDynamic FirewallAddress6Type = "dynamic"
)

const (
	// Show in address6 selection.
	FirewallAddress6VisibilityEnable FirewallAddress6Visibility = "enable"

	// Hide from address6 selection.
	FirewallAddress6VisibilityDisable FirewallAddress6Visibility = "disable"
)

// Configure IPv6 firewall addresses.
type FirewallAddress6 struct {

	// Integer value to determine the color of the icon in the GUI (range 1 to 32, default = 0, which sets the value to 1).
	Color int `json:"color,omitempty"`

	// Comment.
	Comment string `json:"comment,omitempty"`

	// Final IP address (inclusive) in the range for the address (format: xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx).
	EndIp string `json:"end-ip,omitempty"`

	// IPv6 address prefix (format: xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx/xxx).
	Ip6 string `json:"ip6,omitempty"`

	// IP address list.
	List []FirewallAddress6List `json:"list,omitempty"`

	// Address name.
	Name string `json:"name,omitempty"`

	// Object ID for NSX.
	ObjId int `json:"obj-id,omitempty"`

	// SDN.
	Sdn FirewallAddress6Sdn `json:"sdn,omitempty"`

	// First IP address (inclusive) in the range for the address (format: xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx).
	StartIp string `json:"start-ip,omitempty"`

	// Names of object-tags applied to address. Tags need to be preconfigured in config system object-tag. Separate multiple tags with a space.
	Tags []FirewallAddress6Tags `json:"tags,omitempty"`

	// Type of IPv6 address object (default = ipprefix).
	Type FirewallAddress6Type `json:"type,omitempty"`

	// Universally Unique Identifier (UUID; automatically assigned but can be manually reset).
	Uuid string `json:"uuid,omitempty"`

	// Enable/disable the visibility of the object in the GUI.
	Visibility FirewallAddress6Visibility `json:"visibility,omitempty"`
}

// Returns the value that identifies a FirewallAddress6
func (x *FirewallAddress6) MKey() string {
	return x.Name
}

// The results of a Get or List operation
type FirewallAddress6Results struct {
	Results []*FirewallAddress6 `json:"results"`
	Mkey    string              `json:"mkey"`
	Result
}

// List all FirewallAddress6s
func (c *WebClient) ListFirewallAddress6s() (res []*FirewallAddress6, err error) {
	var errmsg Result
	var results FirewallAddress6Results
	_, err = c.napping.Get(c.URL+"/api/v2/firewall/address6", nil, &results, nil)
	if err != nil {
		return []*FirewallAddress6{}, fmt.Errorf("error listing FirewallAddress6s: %s", err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return []*FirewallAddress6{}, fmt.Errorf("error listing FirewallAddress6: not found")
		} else {
			return []*FirewallAddress6{}, fmt.Errorf("error listing FirewallAddress6: %s", errmsg.Status)
		}
	}
	res = results.Results
	return
}

// Get a FirewallAddress6 by name
func (c *WebClient) GetFirewallAddress6(mkey string) (res *FirewallAddress6, err error) {
	var errmsg Result
	var results FirewallAddress6Results
	_, err = c.napping.Get(c.URL+"/api/v2/firewall/address6/"+mkey, nil, &results, &errmsg)
	if err != nil {
		return &FirewallAddress6{}, fmt.Errorf("error getting FirewallAddress6 '%s': %s", mkey, err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return &FirewallAddress6{}, fmt.Errorf("error getting FirewallAddress6 '%s': not found", mkey)
		} else {
			return &FirewallAddress6{}, fmt.Errorf("error getting FirewallAddress6 '%s': %s", mkey, errmsg.Status)
		}
	}
	if len(results.Results) == 0 {
		return &FirewallAddress6{}, fmt.Errorf("error getting FirewallAddress6 '%s': not found", mkey)
	}

	res = results.Results[0]
	return
}

// Create a new FirewallAddress6
func (c *WebClient) CreateFirewallAddress6(obj *FirewallAddress6) (id string, err error) {
	var errmsg Result
	var results FirewallAddress6Results
	_, err = c.napping.Post(c.URL+"/api/v2/firewall/address6", obj, &results, &errmsg)
	if err != nil {
		return "", fmt.Errorf("error creating FirewallAddress6 '%s': %s", obj.Name, err.Error())
	}
	if results.HTTPStatus == 200 {
		return
	}
	if errmsg.HTTPStatus != 200 {
		return "", fmt.Errorf("error creating FirewallAddress6 '%s': %s", obj.Name, errmsg.Status)
	}

	return
}

// Update a FirewallAddress6
func (c *WebClient) UpdateFirewallAddress6(obj *FirewallAddress6) (err error) {
	var errmsg Result
	var results FirewallAddress6Results
	_, err = c.napping.Put(c.URL+"/api/v2/firewall/address6/"+obj.Name, obj, &results, &errmsg)
	if err != nil {
		return fmt.Errorf("error updating FirewallAddress6 '%s': %s", obj.Name, err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return fmt.Errorf("error updating FirewallAddress6 '%s': not found", obj.Name)
		} else {
			return fmt.Errorf("error updating FirewallAddress6 '%s': %s", obj.Name, errmsg.Status)
		}
	}

	return
}

// Delete a FirewallAddress6 by name
func (c *WebClient) DeleteFirewallAddress6(mkey string) (err error) {
	var errmsg Result
	var results FirewallAddress6Results
	_, err = c.napping.Delete(c.URL+"/api/v2/firewall/address6/"+mkey, nil, &results, &errmsg)
	if err != nil {
		return fmt.Errorf("error deleting FirewallAddress6 '%s': %s", mkey, err.Error())
	}
	if results.HTTPStatus == 200 {
		return
	}
	if errmsg.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return fmt.Errorf("error deleting FirewallAddress6 '%s': not found", mkey)
		}
		return fmt.Errorf("error deleting FirewallAddress6 '%s': %s", mkey, errmsg.Status)
	}

	return
}

// List all FirewallAddress6s
func (c *FakeClient) ListFirewallAddress6s() (res []*FirewallAddress6, err error) {
	for _, r := range c.FirewallAddress6s {
		res = append(res, r)
	}
	return
}

// Get a FirewallAddress6 by name
func (c *FakeClient) GetFirewallAddress6(mkey string) (*FirewallAddress6, error) {
	if res, ok := c.FirewallAddress6s[mkey]; ok {
		return res, nil
	} else {
		return &FirewallAddress6{}, fmt.Errorf("error getting FirewallAddress6 '%s': not found", mkey)
	}
}

// Create a new FirewallAddress6
func (c *FakeClient) CreateFirewallAddress6(obj *FirewallAddress6) (id string, err error) {
	id = obj.Name
	c.FirewallAddress6s[id] = obj
	return
}

// Update a FirewallAddress6
func (c *FakeClient) UpdateFirewallAddress6(obj *FirewallAddress6) (err error) {
	c.FirewallAddress6s[obj.Name] = obj
	return nil
}

// Delete a FirewallAddress6 by name
func (c *FakeClient) DeleteFirewallAddress6(mkey string) (err error) {
	delete(c.FirewallAddress6s, mkey)
	return nil
}

// Applied object tags.
type FirewallMulticastAddress6Tags struct {

	// Tag name.
	Name string `json:"name,omitempty"`
}

// Enable/disable visibility of the IPv6 multicast address on the GUI.
type FirewallMulticastAddress6Visibility string

const (
	// Show the IPv6 multicast address on the GUI.
	FirewallMulticastAddress6VisibilityEnable FirewallMulticastAddress6Visibility = "enable"

	// Hide the IPv6 multicast address from the GUI.
	FirewallMulticastAddress6VisibilityDisable FirewallMulticastAddress6Visibility = "disable"
)

// Configure IPv6 multicast address.
type FirewallMulticastAddress6 struct {

	// Color of icon on the GUI.
	Color int `json:"color,omitempty"`

	// Comment.
	Comment string `json:"comment,omitempty"`

	// IPv6 address prefix (format: xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx/xxx).
	Ip6 string `json:"ip6,omitempty"`

	// IPv6 multicast address name.
	Name string `json:"name,omitempty"`

	// Applied object tags.
	Tags []FirewallMulticastAddress6Tags `json:"tags,omitempty"`

	// Enable/disable visibility of the IPv6 multicast address on the GUI.
	Visibility FirewallMulticastAddress6Visibility `json:"visibility,omitempty"`
}

// Returns the value that identifies a FirewallMulticastAddress6
func (x *FirewallMulticastAddress6) MKey() string {
	return x.Name
}

// The results of a Get or List operation
type FirewallMulticastAddress6Results struct {
	Results []*FirewallMulticastAddress6 `json:"results"`
	Mkey    string                       `json:"mkey"`
	Result
}

// List all FirewallMulticastAddress6s
func (c *WebClient) ListFirewallMulticastAddress6s() (res []*FirewallMulticastAddress6, err error) {
	var errmsg Result
	var results FirewallMulticastAddress6Results
	_, err = c.napping.Get(c.URL+"/api/v2/firewall/multicast-address6", nil, &results, nil)
	if err != nil {
		return []*FirewallMulticastAddress6{}, fmt.Errorf("error listing FirewallMulticastAddress6s: %s", err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return []*FirewallMulticastAddress6{}, fmt.Errorf("error listing FirewallMulticastAddress6: not found")
		} else {
			return []*FirewallMulticastAddress6{}, fmt.Errorf("error listing FirewallMulticastAddress6: %s", errmsg.Status)
		}
	}
	res = results.Results
	return
}

// Get a FirewallMulticastAddress6 by name
func (c *WebClient) GetFirewallMulticastAddress6(mkey string) (res *FirewallMulticastAddress6, err error) {
	var errmsg Result
	var results FirewallMulticastAddress6Results
	_, err = c.napping.Get(c.URL+"/api/v2/firewall/multicast-address6/"+mkey, nil, &results, &errmsg)
	if err != nil {
		return &FirewallMulticastAddress6{}, fmt.Errorf("error getting FirewallMulticastAddress6 '%s': %s", mkey, err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return &FirewallMulticastAddress6{}, fmt.Errorf("error getting FirewallMulticastAddress6 '%s': not found", mkey)
		} else {
			return &FirewallMulticastAddress6{}, fmt.Errorf("error getting FirewallMulticastAddress6 '%s': %s", mkey, errmsg.Status)
		}
	}
	if len(results.Results) == 0 {
		return &FirewallMulticastAddress6{}, fmt.Errorf("error getting FirewallMulticastAddress6 '%s': not found", mkey)
	}

	res = results.Results[0]
	return
}

// Create a new FirewallMulticastAddress6
func (c *WebClient) CreateFirewallMulticastAddress6(obj *FirewallMulticastAddress6) (id string, err error) {
	var errmsg Result
	var results FirewallMulticastAddress6Results
	_, err = c.napping.Post(c.URL+"/api/v2/firewall/multicast-address6", obj, &results, &errmsg)
	if err != nil {
		return "", fmt.Errorf("error creating FirewallMulticastAddress6 '%s': %s", obj.Name, err.Error())
	}
	if results.HTTPStatus == 200 {
		return
	}
	if errmsg.HTTPStatus != 200 {
		return "", fmt.Errorf("error creating FirewallMulticastAddress6 '%s': %s", obj.Name, errmsg.Status)
	}

	return
}

// Update a FirewallMulticastAddress6
func (c *WebClient) UpdateFirewallMulticastAddress6(obj *FirewallMulticastAddress6) (err error) {
	var errmsg Result
	var results FirewallMulticastAddress6Results
	_, err = c.napping.Put(c.URL+"/api/v2/firewall/multicast-address6/"+obj.Name, obj, &results, &errmsg)
	if err != nil {
		return fmt.Errorf("error updating FirewallMulticastAddress6 '%s': %s", obj.Name, err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return fmt.Errorf("error updating FirewallMulticastAddress6 '%s': not found", obj.Name)
		} else {
			return fmt.Errorf("error updating FirewallMulticastAddress6 '%s': %s", obj.Name, errmsg.Status)
		}
	}

	return
}

// Delete a FirewallMulticastAddress6 by name
func (c *WebClient) DeleteFirewallMulticastAddress6(mkey string) (err error) {
	var errmsg Result
	var results FirewallMulticastAddress6Results
	_, err = c.napping.Delete(c.URL+"/api/v2/firewall/multicast-address6/"+mkey, nil, &results, &errmsg)
	if err != nil {
		return fmt.Errorf("error deleting FirewallMulticastAddress6 '%s': %s", mkey, err.Error())
	}
	if results.HTTPStatus == 200 {
		return
	}
	if errmsg.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return fmt.Errorf("error deleting FirewallMulticastAddress6 '%s': not found", mkey)
		}
		return fmt.Errorf("error deleting FirewallMulticastAddress6 '%s': %s", mkey, errmsg.Status)
	}

	return
}

// List all FirewallMulticastAddress6s
func (c *FakeClient) ListFirewallMulticastAddress6s() (res []*FirewallMulticastAddress6, err error) {
	for _, r := range c.FirewallMulticastAddress6s {
		res = append(res, r)
	}
	return
}

// Get a FirewallMulticastAddress6 by name
func (c *FakeClient) GetFirewallMulticastAddress6(mkey string) (*FirewallMulticastAddress6, error) {
	if res, ok := c.FirewallMulticastAddress6s[mkey]; ok {
		return res, nil
	} else {
		return &FirewallMulticastAddress6{}, fmt.Errorf("error getting FirewallMulticastAddress6 '%s': not found", mkey)
	}
}

// Create a new FirewallMulticastAddress6
func (c *FakeClient) CreateFirewallMulticastAddress6(obj *FirewallMulticastAddress6) (id string, err error) {
	id = obj.Name
	c.FirewallMulticastAddress6s[id] = obj
	return
}

// Update a FirewallMulticastAddress6
func (c *FakeClient) UpdateFirewallMulticastAddress6(obj *FirewallMulticastAddress6) (err error) {
	c.FirewallMulticastAddress6s[obj.Name] = obj
	return nil
}

// Delete a FirewallMulticastAddress6 by name
func (c *FakeClient) DeleteFirewallMulticastAddress6(mkey string) (err error) {
	delete(c.FirewallMulticastAddress6s, mkey)
	return nil
}

// Enable/disable use of this group in the static route configuration.
type FirewallAddrgrpAllowRouting string

// Address objects contained within the group.
type FirewallAddrgrpMember struct {

	// Address name.
	Name string `json:"name,omitempty"`
}

// Name(s) of object-tags applied to address.
type FirewallAddrgrpTags struct {

	// Tag name.
	Name string `json:"name,omitempty"`
}

// Enable/disable address visibility in the GUI.
type FirewallAddrgrpVisibility string

const (
	// Enable use of this group in the static route configuration.
	FirewallAddrgrpAllowRoutingEnable FirewallAddrgrpAllowRouting = "enable"

	// Disable use of this group in the static route configuration.
	FirewallAddrgrpAllowRoutingDisable FirewallAddrgrpAllowRouting = "disable"
)

const (
	// Show in address group selection.
	FirewallAddrgrpVisibilityEnable FirewallAddrgrpVisibility = "enable"

	// Hide from address group selection.
	FirewallAddrgrpVisibilityDisable FirewallAddrgrpVisibility = "disable"
)

// Configure IPv4 address groups.
type FirewallAddrgrp struct {

	// Enable/disable use of this group in the static route configuration.
	AllowRouting FirewallAddrgrpAllowRouting `json:"allow-routing,omitempty"`

	// Color of icon on the GUI.
	Color int `json:"color,omitempty"`

	// Comment.
	Comment string `json:"comment,omitempty"`

	// Address objects contained within the group.
	Member []FirewallAddrgrpMember `json:"member,omitempty"`

	// Address group name.
	Name string `json:"name,omitempty"`

	// Name(s) of object-tags applied to address.
	Tags []FirewallAddrgrpTags `json:"tags,omitempty"`

	// Universally Unique Identifier (UUID; automatically assigned but can be manually reset).
	Uuid string `json:"uuid,omitempty"`

	// Enable/disable address visibility in the GUI.
	Visibility FirewallAddrgrpVisibility `json:"visibility,omitempty"`
}

// Returns the value that identifies a FirewallAddrgrp
func (x *FirewallAddrgrp) MKey() string {
	return x.Name
}

// The results of a Get or List operation
type FirewallAddrgrpResults struct {
	Results []*FirewallAddrgrp `json:"results"`
	Mkey    string             `json:"mkey"`
	Result
}

// List all FirewallAddrgrps
func (c *WebClient) ListFirewallAddrgrps() (res []*FirewallAddrgrp, err error) {
	var errmsg Result
	var results FirewallAddrgrpResults
	_, err = c.napping.Get(c.URL+"/api/v2/firewall/addrgrp", nil, &results, nil)
	if err != nil {
		return []*FirewallAddrgrp{}, fmt.Errorf("error listing FirewallAddrgrps: %s", err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return []*FirewallAddrgrp{}, fmt.Errorf("error listing FirewallAddrgrp: not found")
		} else {
			return []*FirewallAddrgrp{}, fmt.Errorf("error listing FirewallAddrgrp: %s", errmsg.Status)
		}
	}
	res = results.Results
	return
}

// Get a FirewallAddrgrp by name
func (c *WebClient) GetFirewallAddrgrp(mkey string) (res *FirewallAddrgrp, err error) {
	var errmsg Result
	var results FirewallAddrgrpResults
	_, err = c.napping.Get(c.URL+"/api/v2/firewall/addrgrp/"+mkey, nil, &results, &errmsg)
	if err != nil {
		return &FirewallAddrgrp{}, fmt.Errorf("error getting FirewallAddrgrp '%s': %s", mkey, err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return &FirewallAddrgrp{}, fmt.Errorf("error getting FirewallAddrgrp '%s': not found", mkey)
		} else {
			return &FirewallAddrgrp{}, fmt.Errorf("error getting FirewallAddrgrp '%s': %s", mkey, errmsg.Status)
		}
	}
	if len(results.Results) == 0 {
		return &FirewallAddrgrp{}, fmt.Errorf("error getting FirewallAddrgrp '%s': not found", mkey)
	}

	res = results.Results[0]
	return
}

// Create a new FirewallAddrgrp
func (c *WebClient) CreateFirewallAddrgrp(obj *FirewallAddrgrp) (id string, err error) {
	var errmsg Result
	var results FirewallAddrgrpResults
	_, err = c.napping.Post(c.URL+"/api/v2/firewall/addrgrp", obj, &results, &errmsg)
	if err != nil {
		return "", fmt.Errorf("error creating FirewallAddrgrp '%s': %s", obj.Name, err.Error())
	}
	if results.HTTPStatus == 200 {
		return
	}
	if errmsg.HTTPStatus != 200 {
		return "", fmt.Errorf("error creating FirewallAddrgrp '%s': %s", obj.Name, errmsg.Status)
	}

	return
}

// Update a FirewallAddrgrp
func (c *WebClient) UpdateFirewallAddrgrp(obj *FirewallAddrgrp) (err error) {
	var errmsg Result
	var results FirewallAddrgrpResults
	_, err = c.napping.Put(c.URL+"/api/v2/firewall/addrgrp/"+obj.Name, obj, &results, &errmsg)
	if err != nil {
		return fmt.Errorf("error updating FirewallAddrgrp '%s': %s", obj.Name, err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return fmt.Errorf("error updating FirewallAddrgrp '%s': not found", obj.Name)
		} else {
			return fmt.Errorf("error updating FirewallAddrgrp '%s': %s", obj.Name, errmsg.Status)
		}
	}

	return
}

// Delete a FirewallAddrgrp by name
func (c *WebClient) DeleteFirewallAddrgrp(mkey string) (err error) {
	var errmsg Result
	var results FirewallAddrgrpResults
	_, err = c.napping.Delete(c.URL+"/api/v2/firewall/addrgrp/"+mkey, nil, &results, &errmsg)
	if err != nil {
		return fmt.Errorf("error deleting FirewallAddrgrp '%s': %s", mkey, err.Error())
	}
	if results.HTTPStatus == 200 {
		return
	}
	if errmsg.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return fmt.Errorf("error deleting FirewallAddrgrp '%s': not found", mkey)
		}
		return fmt.Errorf("error deleting FirewallAddrgrp '%s': %s", mkey, errmsg.Status)
	}

	return
}

// List all FirewallAddrgrps
func (c *FakeClient) ListFirewallAddrgrps() (res []*FirewallAddrgrp, err error) {
	for _, r := range c.FirewallAddrgrps {
		res = append(res, r)
	}
	return
}

// Get a FirewallAddrgrp by name
func (c *FakeClient) GetFirewallAddrgrp(mkey string) (*FirewallAddrgrp, error) {
	if res, ok := c.FirewallAddrgrps[mkey]; ok {
		return res, nil
	} else {
		return &FirewallAddrgrp{}, fmt.Errorf("error getting FirewallAddrgrp '%s': not found", mkey)
	}
}

// Create a new FirewallAddrgrp
func (c *FakeClient) CreateFirewallAddrgrp(obj *FirewallAddrgrp) (id string, err error) {
	id = obj.Name
	c.FirewallAddrgrps[id] = obj
	return
}

// Update a FirewallAddrgrp
func (c *FakeClient) UpdateFirewallAddrgrp(obj *FirewallAddrgrp) (err error) {
	c.FirewallAddrgrps[obj.Name] = obj
	return nil
}

// Delete a FirewallAddrgrp by name
func (c *FakeClient) DeleteFirewallAddrgrp(mkey string) (err error) {
	delete(c.FirewallAddrgrps, mkey)
	return nil
}

// Address objects contained within the group.
type FirewallAddrgrp6Member struct {

	// Address6/addrgrp6 name.
	Name string `json:"name,omitempty"`
}

// Names of object-tags applied to address. Tags need to be preconfigured in config system object-tag. Separate multiple tags with a space.
type FirewallAddrgrp6Tags struct {

	// Tag name.
	Name string `json:"name,omitempty"`
}

// Enable/disable address group6 visibility in the GUI.
type FirewallAddrgrp6Visibility string

const (
	// Show in address group selection.
	FirewallAddrgrp6VisibilityEnable FirewallAddrgrp6Visibility = "enable"

	// Hide from address group selection.
	FirewallAddrgrp6VisibilityDisable FirewallAddrgrp6Visibility = "disable"
)

// Configure IPv6 address groups.
type FirewallAddrgrp6 struct {

	// Integer value to determine the color of the icon in the GUI (1 - 32, default = 0, which sets the value to 1).
	Color int `json:"color,omitempty"`

	// Comment.
	Comment string `json:"comment,omitempty"`

	// Address objects contained within the group.
	Member []FirewallAddrgrp6Member `json:"member,omitempty"`

	// IPv6 address group name.
	Name string `json:"name,omitempty"`

	// Names of object-tags applied to address. Tags need to be preconfigured in config system object-tag. Separate multiple tags with a space.
	Tags []FirewallAddrgrp6Tags `json:"tags,omitempty"`

	// Universally Unique Identifier (UUID; automatically assigned but can be manually reset).
	Uuid string `json:"uuid,omitempty"`

	// Enable/disable address group6 visibility in the GUI.
	Visibility FirewallAddrgrp6Visibility `json:"visibility,omitempty"`
}

// Returns the value that identifies a FirewallAddrgrp6
func (x *FirewallAddrgrp6) MKey() string {
	return x.Name
}

// The results of a Get or List operation
type FirewallAddrgrp6Results struct {
	Results []*FirewallAddrgrp6 `json:"results"`
	Mkey    string              `json:"mkey"`
	Result
}

// List all FirewallAddrgrp6s
func (c *WebClient) ListFirewallAddrgrp6s() (res []*FirewallAddrgrp6, err error) {
	var errmsg Result
	var results FirewallAddrgrp6Results
	_, err = c.napping.Get(c.URL+"/api/v2/firewall/addrgrp6", nil, &results, nil)
	if err != nil {
		return []*FirewallAddrgrp6{}, fmt.Errorf("error listing FirewallAddrgrp6s: %s", err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return []*FirewallAddrgrp6{}, fmt.Errorf("error listing FirewallAddrgrp6: not found")
		} else {
			return []*FirewallAddrgrp6{}, fmt.Errorf("error listing FirewallAddrgrp6: %s", errmsg.Status)
		}
	}
	res = results.Results
	return
}

// Get a FirewallAddrgrp6 by name
func (c *WebClient) GetFirewallAddrgrp6(mkey string) (res *FirewallAddrgrp6, err error) {
	var errmsg Result
	var results FirewallAddrgrp6Results
	_, err = c.napping.Get(c.URL+"/api/v2/firewall/addrgrp6/"+mkey, nil, &results, &errmsg)
	if err != nil {
		return &FirewallAddrgrp6{}, fmt.Errorf("error getting FirewallAddrgrp6 '%s': %s", mkey, err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return &FirewallAddrgrp6{}, fmt.Errorf("error getting FirewallAddrgrp6 '%s': not found", mkey)
		} else {
			return &FirewallAddrgrp6{}, fmt.Errorf("error getting FirewallAddrgrp6 '%s': %s", mkey, errmsg.Status)
		}
	}
	if len(results.Results) == 0 {
		return &FirewallAddrgrp6{}, fmt.Errorf("error getting FirewallAddrgrp6 '%s': not found", mkey)
	}

	res = results.Results[0]
	return
}

// Create a new FirewallAddrgrp6
func (c *WebClient) CreateFirewallAddrgrp6(obj *FirewallAddrgrp6) (id string, err error) {
	var errmsg Result
	var results FirewallAddrgrp6Results
	_, err = c.napping.Post(c.URL+"/api/v2/firewall/addrgrp6", obj, &results, &errmsg)
	if err != nil {
		return "", fmt.Errorf("error creating FirewallAddrgrp6 '%s': %s", obj.Name, err.Error())
	}
	if results.HTTPStatus == 200 {
		return
	}
	if errmsg.HTTPStatus != 200 {
		return "", fmt.Errorf("error creating FirewallAddrgrp6 '%s': %s", obj.Name, errmsg.Status)
	}

	return
}

// Update a FirewallAddrgrp6
func (c *WebClient) UpdateFirewallAddrgrp6(obj *FirewallAddrgrp6) (err error) {
	var errmsg Result
	var results FirewallAddrgrp6Results
	_, err = c.napping.Put(c.URL+"/api/v2/firewall/addrgrp6/"+obj.Name, obj, &results, &errmsg)
	if err != nil {
		return fmt.Errorf("error updating FirewallAddrgrp6 '%s': %s", obj.Name, err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return fmt.Errorf("error updating FirewallAddrgrp6 '%s': not found", obj.Name)
		} else {
			return fmt.Errorf("error updating FirewallAddrgrp6 '%s': %s", obj.Name, errmsg.Status)
		}
	}

	return
}

// Delete a FirewallAddrgrp6 by name
func (c *WebClient) DeleteFirewallAddrgrp6(mkey string) (err error) {
	var errmsg Result
	var results FirewallAddrgrp6Results
	_, err = c.napping.Delete(c.URL+"/api/v2/firewall/addrgrp6/"+mkey, nil, &results, &errmsg)
	if err != nil {
		return fmt.Errorf("error deleting FirewallAddrgrp6 '%s': %s", mkey, err.Error())
	}
	if results.HTTPStatus == 200 {
		return
	}
	if errmsg.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return fmt.Errorf("error deleting FirewallAddrgrp6 '%s': not found", mkey)
		}
		return fmt.Errorf("error deleting FirewallAddrgrp6 '%s': %s", mkey, errmsg.Status)
	}

	return
}

// List all FirewallAddrgrp6s
func (c *FakeClient) ListFirewallAddrgrp6s() (res []*FirewallAddrgrp6, err error) {
	for _, r := range c.FirewallAddrgrp6s {
		res = append(res, r)
	}
	return
}

// Get a FirewallAddrgrp6 by name
func (c *FakeClient) GetFirewallAddrgrp6(mkey string) (*FirewallAddrgrp6, error) {
	if res, ok := c.FirewallAddrgrp6s[mkey]; ok {
		return res, nil
	} else {
		return &FirewallAddrgrp6{}, fmt.Errorf("error getting FirewallAddrgrp6 '%s': not found", mkey)
	}
}

// Create a new FirewallAddrgrp6
func (c *FakeClient) CreateFirewallAddrgrp6(obj *FirewallAddrgrp6) (id string, err error) {
	id = obj.Name
	c.FirewallAddrgrp6s[id] = obj
	return
}

// Update a FirewallAddrgrp6
func (c *FakeClient) UpdateFirewallAddrgrp6(obj *FirewallAddrgrp6) (err error) {
	c.FirewallAddrgrp6s[obj.Name] = obj
	return nil
}

// Delete a FirewallAddrgrp6 by name
func (c *FakeClient) DeleteFirewallAddrgrp6(mkey string) (err error) {
	delete(c.FirewallAddrgrp6s, mkey)
	return nil
}

// Entries in the Internet Service database.
type FirewallInternetServiceEntry struct {

	// Entry ID.
	Id int `json:"id,omitempty"`

	// Total number of IP addresses.
	IpNumber int `json:"ip-number,omitempty"`

	// Total number of IP ranges.
	IpRangeNumber int `json:"ip-range-number,omitempty"`

	// Integer value for the TCP/IP port (0 - 65535).
	Port int `json:"port,omitempty"`

	// Integer value for the protocol type as defined by IANA (0 - 255).
	Protocol int `json:"protocol,omitempty"`
}

// Show Internet Service application.
type FirewallInternetService struct {

	// Entries in the Internet Service database.
	Entry []FirewallInternetServiceEntry `json:"entry,omitempty"`

	// Icon ID of Internet Service.
	IconId int `json:"icon-id,omitempty"`

	// Internet Service ID.
	Id int `json:"id,omitempty"`

	// Internet Service name.
	Name string `json:"name,omitempty"`

	// Offset of Internet Service ID.
	Offset int `json:"offset,omitempty"`

	// Reputation level of the Internet Service.
	Reputation int `json:"reputation,omitempty"`
}

// Returns the value that identifies a FirewallInternetService
func (x *FirewallInternetService) MKey() int {
	return x.Id
}

// The results of a Get or List operation
type FirewallInternetServiceResults struct {
	Results []*FirewallInternetService `json:"results"`
	Mkey    int                        `json:"mkey"`
	Result
}

// List all FirewallInternetServices
func (c *WebClient) ListFirewallInternetServices() (res []*FirewallInternetService, err error) {
	var errmsg Result
	var results FirewallInternetServiceResults
	_, err = c.napping.Get(c.URL+"/api/v2/firewall/internet-service", nil, &results, nil)
	if err != nil {
		return []*FirewallInternetService{}, fmt.Errorf("error listing FirewallInternetServices: %s", err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return []*FirewallInternetService{}, fmt.Errorf("error listing FirewallInternetService: not found")
		} else {
			return []*FirewallInternetService{}, fmt.Errorf("error listing FirewallInternetService: %s", errmsg.Status)
		}
	}
	res = results.Results
	return
}

// Get a FirewallInternetService by name
func (c *WebClient) GetFirewallInternetService(mkey int) (res *FirewallInternetService, err error) {
	var errmsg Result
	var results FirewallInternetServiceResults
	_, err = c.napping.Get(c.URL+"/api/v2/firewall/internet-service/"+strconv.Itoa(mkey), nil, &results, &errmsg)
	if err != nil {
		return &FirewallInternetService{}, fmt.Errorf("error getting FirewallInternetService '%s': %s", strconv.Itoa(mkey), err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return &FirewallInternetService{}, fmt.Errorf("error getting FirewallInternetService '%s': not found", strconv.Itoa(mkey))
		} else {
			return &FirewallInternetService{}, fmt.Errorf("error getting FirewallInternetService '%s': %s", strconv.Itoa(mkey), errmsg.Status)
		}
	}
	if len(results.Results) == 0 {
		return &FirewallInternetService{}, fmt.Errorf("error getting FirewallInternetService '%s': not found", strconv.Itoa(mkey))
	}

	res = results.Results[0]
	return
}

// Create a new FirewallInternetService
func (c *WebClient) CreateFirewallInternetService(obj *FirewallInternetService) (id int, err error) {
	var errmsg Result
	var results FirewallInternetServiceResults
	_, err = c.napping.Post(c.URL+"/api/v2/firewall/internet-service", obj, &results, &errmsg)
	if err != nil {
		return 0, fmt.Errorf("error creating FirewallInternetService '%s': %s", strconv.Itoa(obj.Id), err.Error())
	}
	if results.HTTPStatus == 200 {
		return
	}
	if errmsg.HTTPStatus != 200 {
		return 0, fmt.Errorf("error creating FirewallInternetService '%s': %s", strconv.Itoa(obj.Id), errmsg.Status)
	}

	return
}

// Update a FirewallInternetService
func (c *WebClient) UpdateFirewallInternetService(obj *FirewallInternetService) (err error) {
	var errmsg Result
	var results FirewallInternetServiceResults
	_, err = c.napping.Put(c.URL+"/api/v2/firewall/internet-service/"+strconv.Itoa(obj.Id), obj, &results, &errmsg)
	if err != nil {
		return fmt.Errorf("error updating FirewallInternetService '%s': %s", strconv.Itoa(obj.Id), err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return fmt.Errorf("error updating FirewallInternetService '%s': not found", strconv.Itoa(obj.Id))
		} else {
			return fmt.Errorf("error updating FirewallInternetService '%s': %s", strconv.Itoa(obj.Id), errmsg.Status)
		}
	}

	return
}

// Delete a FirewallInternetService by name
func (c *WebClient) DeleteFirewallInternetService(mkey int) (err error) {
	var errmsg Result
	var results FirewallInternetServiceResults
	_, err = c.napping.Delete(c.URL+"/api/v2/firewall/internet-service/"+strconv.Itoa(mkey), nil, &results, &errmsg)
	if err != nil {
		return fmt.Errorf("error deleting FirewallInternetService '%s': %s", mkey, err.Error())
	}
	if results.HTTPStatus == 200 {
		return
	}
	if errmsg.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return fmt.Errorf("error deleting FirewallInternetService '%s': not found", mkey)
		}
		return fmt.Errorf("error deleting FirewallInternetService '%s': %s", mkey, errmsg.Status)
	}

	return
}

// List all FirewallInternetServices
func (c *FakeClient) ListFirewallInternetServices() (res []*FirewallInternetService, err error) {
	for _, r := range c.FirewallInternetServices {
		res = append(res, r)
	}
	return
}

// Get a FirewallInternetService by name
func (c *FakeClient) GetFirewallInternetService(mkey int) (*FirewallInternetService, error) {
	if res, ok := c.FirewallInternetServices[mkey]; ok {
		return res, nil
	} else {
		return &FirewallInternetService{}, fmt.Errorf("error getting FirewallInternetService '%s': not found", strconv.Itoa(mkey))
	}
}

// Create a new FirewallInternetService
func (c *FakeClient) CreateFirewallInternetService(obj *FirewallInternetService) (id int, err error) {
	id = c.FirewallInternetServiceCounter
	c.FirewallInternetServiceCounter++
	c.FirewallInternetServices[id] = obj
	return
}

// Update a FirewallInternetService
func (c *FakeClient) UpdateFirewallInternetService(obj *FirewallInternetService) (err error) {
	c.FirewallInternetServices[obj.Id] = obj
	return nil
}

// Delete a FirewallInternetService by name
func (c *FakeClient) DeleteFirewallInternetService(mkey int) (err error) {
	delete(c.FirewallInternetServices, mkey)
	return nil
}

// Disable entries in the Internet Service database.
type FirewallInternetServiceCustomDisableEntry struct {

	// Disable entry ID.
	Id int `json:"id,omitempty"`

	// IP ranges in the disable entry.
	IpRange string `json:"ip-range,omitempty"`

	// Integer value for the TCP/IP port (0 - 65535).
	Port int `json:"port,omitempty"`

	// Integer value for the protocol type as defined by IANA (0 - 255).
	Protocol int `json:"protocol,omitempty"`
}

// Entries added to the Internet Service database and custom database.
type FirewallInternetServiceCustomEntry struct {

	// Destination address or address group name.
	Dst string `json:"dst,omitempty"`

	// Entry ID(1-255).
	Id int `json:"id,omitempty"`

	// Port ranges in the custom entry.
	PortRange string `json:"port-range,omitempty"`

	// Integer value for the protocol type as defined by IANA (0 - 255).
	Protocol int `json:"protocol,omitempty"`
}

// Configure custom Internet Services.
type FirewallInternetServiceCustom struct {

	// Comment.
	Comment string `json:"comment,omitempty"`

	// Disable entries in the Internet Service database.
	DisableEntry []FirewallInternetServiceCustomDisableEntry `json:"disable-entry,omitempty"`

	// Entries added to the Internet Service database and custom database.
	Entry []FirewallInternetServiceCustomEntry `json:"entry,omitempty"`

	// Internet Service ID in the Internet Service database.
	MasterServiceId int `json:"master-service-id,omitempty"`

	// Internet Service name.
	Name string `json:"name,omitempty"`
}

// Returns the value that identifies a FirewallInternetServiceCustom
func (x *FirewallInternetServiceCustom) MKey() string {
	return x.Name
}

// The results of a Get or List operation
type FirewallInternetServiceCustomResults struct {
	Results []*FirewallInternetServiceCustom `json:"results"`
	Mkey    string                           `json:"mkey"`
	Result
}

// List all FirewallInternetServiceCustoms
func (c *WebClient) ListFirewallInternetServiceCustoms() (res []*FirewallInternetServiceCustom, err error) {
	var errmsg Result
	var results FirewallInternetServiceCustomResults
	_, err = c.napping.Get(c.URL+"/api/v2/firewall/internet-service-custom", nil, &results, nil)
	if err != nil {
		return []*FirewallInternetServiceCustom{}, fmt.Errorf("error listing FirewallInternetServiceCustoms: %s", err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return []*FirewallInternetServiceCustom{}, fmt.Errorf("error listing FirewallInternetServiceCustom: not found")
		} else {
			return []*FirewallInternetServiceCustom{}, fmt.Errorf("error listing FirewallInternetServiceCustom: %s", errmsg.Status)
		}
	}
	res = results.Results
	return
}

// Get a FirewallInternetServiceCustom by name
func (c *WebClient) GetFirewallInternetServiceCustom(mkey string) (res *FirewallInternetServiceCustom, err error) {
	var errmsg Result
	var results FirewallInternetServiceCustomResults
	_, err = c.napping.Get(c.URL+"/api/v2/firewall/internet-service-custom/"+mkey, nil, &results, &errmsg)
	if err != nil {
		return &FirewallInternetServiceCustom{}, fmt.Errorf("error getting FirewallInternetServiceCustom '%s': %s", mkey, err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return &FirewallInternetServiceCustom{}, fmt.Errorf("error getting FirewallInternetServiceCustom '%s': not found", mkey)
		} else {
			return &FirewallInternetServiceCustom{}, fmt.Errorf("error getting FirewallInternetServiceCustom '%s': %s", mkey, errmsg.Status)
		}
	}
	if len(results.Results) == 0 {
		return &FirewallInternetServiceCustom{}, fmt.Errorf("error getting FirewallInternetServiceCustom '%s': not found", mkey)
	}

	res = results.Results[0]
	return
}

// Create a new FirewallInternetServiceCustom
func (c *WebClient) CreateFirewallInternetServiceCustom(obj *FirewallInternetServiceCustom) (id string, err error) {
	var errmsg Result
	var results FirewallInternetServiceCustomResults
	_, err = c.napping.Post(c.URL+"/api/v2/firewall/internet-service-custom", obj, &results, &errmsg)
	if err != nil {
		return "", fmt.Errorf("error creating FirewallInternetServiceCustom '%s': %s", obj.Name, err.Error())
	}
	if results.HTTPStatus == 200 {
		return
	}
	if errmsg.HTTPStatus != 200 {
		return "", fmt.Errorf("error creating FirewallInternetServiceCustom '%s': %s", obj.Name, errmsg.Status)
	}

	return
}

// Update a FirewallInternetServiceCustom
func (c *WebClient) UpdateFirewallInternetServiceCustom(obj *FirewallInternetServiceCustom) (err error) {
	var errmsg Result
	var results FirewallInternetServiceCustomResults
	_, err = c.napping.Put(c.URL+"/api/v2/firewall/internet-service-custom/"+obj.Name, obj, &results, &errmsg)
	if err != nil {
		return fmt.Errorf("error updating FirewallInternetServiceCustom '%s': %s", obj.Name, err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return fmt.Errorf("error updating FirewallInternetServiceCustom '%s': not found", obj.Name)
		} else {
			return fmt.Errorf("error updating FirewallInternetServiceCustom '%s': %s", obj.Name, errmsg.Status)
		}
	}

	return
}

// Delete a FirewallInternetServiceCustom by name
func (c *WebClient) DeleteFirewallInternetServiceCustom(mkey string) (err error) {
	var errmsg Result
	var results FirewallInternetServiceCustomResults
	_, err = c.napping.Delete(c.URL+"/api/v2/firewall/internet-service-custom/"+mkey, nil, &results, &errmsg)
	if err != nil {
		return fmt.Errorf("error deleting FirewallInternetServiceCustom '%s': %s", mkey, err.Error())
	}
	if results.HTTPStatus == 200 {
		return
	}
	if errmsg.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return fmt.Errorf("error deleting FirewallInternetServiceCustom '%s': not found", mkey)
		}
		return fmt.Errorf("error deleting FirewallInternetServiceCustom '%s': %s", mkey, errmsg.Status)
	}

	return
}

// List all FirewallInternetServiceCustoms
func (c *FakeClient) ListFirewallInternetServiceCustoms() (res []*FirewallInternetServiceCustom, err error) {
	for _, r := range c.FirewallInternetServiceCustoms {
		res = append(res, r)
	}
	return
}

// Get a FirewallInternetServiceCustom by name
func (c *FakeClient) GetFirewallInternetServiceCustom(mkey string) (*FirewallInternetServiceCustom, error) {
	if res, ok := c.FirewallInternetServiceCustoms[mkey]; ok {
		return res, nil
	} else {
		return &FirewallInternetServiceCustom{}, fmt.Errorf("error getting FirewallInternetServiceCustom '%s': not found", mkey)
	}
}

// Create a new FirewallInternetServiceCustom
func (c *FakeClient) CreateFirewallInternetServiceCustom(obj *FirewallInternetServiceCustom) (id string, err error) {
	id = obj.Name
	c.FirewallInternetServiceCustoms[id] = obj
	return
}

// Update a FirewallInternetServiceCustom
func (c *FakeClient) UpdateFirewallInternetServiceCustom(obj *FirewallInternetServiceCustom) (err error) {
	c.FirewallInternetServiceCustoms[obj.Name] = obj
	return nil
}

// Delete a FirewallInternetServiceCustom by name
func (c *FakeClient) DeleteFirewallInternetServiceCustom(mkey string) (err error) {
	delete(c.FirewallInternetServiceCustoms, mkey)
	return nil
}

// Enable/disable replying to ARP requests when an IP Pool is added to a policy (default = enable).
type FirewallIppoolArpReply string

// Enable/disable full cone NAT.
type FirewallIppoolPermitAnyHost string

// IP pool type (overload, one-to-one, fixed port range, or port block allocation).
type FirewallIppoolType string

const (
	// Disable ARP reply.
	FirewallIppoolArpReplyDisable FirewallIppoolArpReply = "disable"

	// Enable ARP reply.
	FirewallIppoolArpReplyEnable FirewallIppoolArpReply = "enable"
)

const (
	// Disable full cone NAT.
	FirewallIppoolPermitAnyHostDisable FirewallIppoolPermitAnyHost = "disable"

	// Enable full cone NAT.
	FirewallIppoolPermitAnyHostEnable FirewallIppoolPermitAnyHost = "enable"
)

const (
	// IP addresses in the IP pool can be shared by clients.
	FirewallIppoolTypeOverload FirewallIppoolType = "overload"

	// One to one mapping.
	FirewallIppoolTypeOneToOne FirewallIppoolType = "one-to-one"

	// Fixed port range.
	FirewallIppoolTypeFixedPortRange FirewallIppoolType = "fixed-port-range"

	// Port block allocation.
	FirewallIppoolTypePortBlockAllocation FirewallIppoolType = "port-block-allocation"
)

// Configure IPv4 IP pools.
type FirewallIppool struct {

	// Select an interface from available options that will reply to ARP requests. (If blank, any is selected).
	ArpIntf string `json:"arp-intf,omitempty"`

	// Enable/disable replying to ARP requests when an IP Pool is added to a policy (default = enable).
	ArpReply FirewallIppoolArpReply `json:"arp-reply,omitempty"`

	// Associated interface name.
	AssociatedInterface string `json:"associated-interface,omitempty"`

	//  Number of addresses in a block (64 to 4096, default = 128).
	BlockSize int `json:"block-size,omitempty"`

	// Comment.
	Comments string `json:"comments,omitempty"`

	// Final IPv4 address (inclusive) in the range for the address pool (format xxx.xxx.xxx.xxx, Default: 0.0.0.0).
	Endip string `json:"endip,omitempty"`

	// IP pool name.
	Name string `json:"name,omitempty"`

	// Number of addresses blocks that can be used by a user (1 to 128, default = 8).
	NumBlocksPerUser int `json:"num-blocks-per-user,omitempty"`

	// Enable/disable full cone NAT.
	PermitAnyHost FirewallIppoolPermitAnyHost `json:"permit-any-host,omitempty"`

	// Final IPv4 address (inclusive) in the range of the source addresses to be translated (format xxx.xxx.xxx.xxx, Default: 0.0.0.0).
	SourceEndip string `json:"source-endip,omitempty"`

	//  First IPv4 address (inclusive) in the range of the source addresses to be translated (format xxx.xxx.xxx.xxx, Default: 0.0.0.0).
	SourceStartip string `json:"source-startip,omitempty"`

	// First IPv4 address (inclusive) in the range for the address pool (format xxx.xxx.xxx.xxx, Default: 0.0.0.0).
	Startip string `json:"startip,omitempty"`

	// IP pool type (overload, one-to-one, fixed port range, or port block allocation).
	Type FirewallIppoolType `json:"type,omitempty"`
}

// Returns the value that identifies a FirewallIppool
func (x *FirewallIppool) MKey() string {
	return x.Name
}

// The results of a Get or List operation
type FirewallIppoolResults struct {
	Results []*FirewallIppool `json:"results"`
	Mkey    string            `json:"mkey"`
	Result
}

// List all FirewallIppools
func (c *WebClient) ListFirewallIppools() (res []*FirewallIppool, err error) {
	var errmsg Result
	var results FirewallIppoolResults
	_, err = c.napping.Get(c.URL+"/api/v2/firewall/ippool", nil, &results, nil)
	if err != nil {
		return []*FirewallIppool{}, fmt.Errorf("error listing FirewallIppools: %s", err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return []*FirewallIppool{}, fmt.Errorf("error listing FirewallIppool: not found")
		} else {
			return []*FirewallIppool{}, fmt.Errorf("error listing FirewallIppool: %s", errmsg.Status)
		}
	}
	res = results.Results
	return
}

// Get a FirewallIppool by name
func (c *WebClient) GetFirewallIppool(mkey string) (res *FirewallIppool, err error) {
	var errmsg Result
	var results FirewallIppoolResults
	_, err = c.napping.Get(c.URL+"/api/v2/firewall/ippool/"+mkey, nil, &results, &errmsg)
	if err != nil {
		return &FirewallIppool{}, fmt.Errorf("error getting FirewallIppool '%s': %s", mkey, err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return &FirewallIppool{}, fmt.Errorf("error getting FirewallIppool '%s': not found", mkey)
		} else {
			return &FirewallIppool{}, fmt.Errorf("error getting FirewallIppool '%s': %s", mkey, errmsg.Status)
		}
	}
	if len(results.Results) == 0 {
		return &FirewallIppool{}, fmt.Errorf("error getting FirewallIppool '%s': not found", mkey)
	}

	res = results.Results[0]
	return
}

// Create a new FirewallIppool
func (c *WebClient) CreateFirewallIppool(obj *FirewallIppool) (id string, err error) {
	var errmsg Result
	var results FirewallIppoolResults
	_, err = c.napping.Post(c.URL+"/api/v2/firewall/ippool", obj, &results, &errmsg)
	if err != nil {
		return "", fmt.Errorf("error creating FirewallIppool '%s': %s", obj.Name, err.Error())
	}
	if results.HTTPStatus == 200 {
		return
	}
	if errmsg.HTTPStatus != 200 {
		return "", fmt.Errorf("error creating FirewallIppool '%s': %s", obj.Name, errmsg.Status)
	}

	return
}

// Update a FirewallIppool
func (c *WebClient) UpdateFirewallIppool(obj *FirewallIppool) (err error) {
	var errmsg Result
	var results FirewallIppoolResults
	_, err = c.napping.Put(c.URL+"/api/v2/firewall/ippool/"+obj.Name, obj, &results, &errmsg)
	if err != nil {
		return fmt.Errorf("error updating FirewallIppool '%s': %s", obj.Name, err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return fmt.Errorf("error updating FirewallIppool '%s': not found", obj.Name)
		} else {
			return fmt.Errorf("error updating FirewallIppool '%s': %s", obj.Name, errmsg.Status)
		}
	}

	return
}

// Delete a FirewallIppool by name
func (c *WebClient) DeleteFirewallIppool(mkey string) (err error) {
	var errmsg Result
	var results FirewallIppoolResults
	_, err = c.napping.Delete(c.URL+"/api/v2/firewall/ippool/"+mkey, nil, &results, &errmsg)
	if err != nil {
		return fmt.Errorf("error deleting FirewallIppool '%s': %s", mkey, err.Error())
	}
	if results.HTTPStatus == 200 {
		return
	}
	if errmsg.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return fmt.Errorf("error deleting FirewallIppool '%s': not found", mkey)
		}
		return fmt.Errorf("error deleting FirewallIppool '%s': %s", mkey, errmsg.Status)
	}

	return
}

// List all FirewallIppools
func (c *FakeClient) ListFirewallIppools() (res []*FirewallIppool, err error) {
	for _, r := range c.FirewallIppools {
		res = append(res, r)
	}
	return
}

// Get a FirewallIppool by name
func (c *FakeClient) GetFirewallIppool(mkey string) (*FirewallIppool, error) {
	if res, ok := c.FirewallIppools[mkey]; ok {
		return res, nil
	} else {
		return &FirewallIppool{}, fmt.Errorf("error getting FirewallIppool '%s': not found", mkey)
	}
}

// Create a new FirewallIppool
func (c *FakeClient) CreateFirewallIppool(obj *FirewallIppool) (id string, err error) {
	id = obj.Name
	c.FirewallIppools[id] = obj
	return
}

// Update a FirewallIppool
func (c *FakeClient) UpdateFirewallIppool(obj *FirewallIppool) (err error) {
	c.FirewallIppools[obj.Name] = obj
	return nil
}

// Delete a FirewallIppool by name
func (c *FakeClient) DeleteFirewallIppool(mkey string) (err error) {
	delete(c.FirewallIppools, mkey)
	return nil
}

// Configure IPv6 IP pools.
type FirewallIppool6 struct {

	// Comment.
	Comments string `json:"comments,omitempty"`

	// Final IPv6 address (inclusive) in the range for the address pool (format xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx, Default: ::).
	Endip string `json:"endip,omitempty"`

	// IPv6 IP pool name.
	Name string `json:"name,omitempty"`

	// First IPv6 address (inclusive) in the range for the address pool (format xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx, Default: ::).
	Startip string `json:"startip,omitempty"`
}

// Returns the value that identifies a FirewallIppool6
func (x *FirewallIppool6) MKey() string {
	return x.Name
}

// The results of a Get or List operation
type FirewallIppool6Results struct {
	Results []*FirewallIppool6 `json:"results"`
	Mkey    string             `json:"mkey"`
	Result
}

// List all FirewallIppool6s
func (c *WebClient) ListFirewallIppool6s() (res []*FirewallIppool6, err error) {
	var errmsg Result
	var results FirewallIppool6Results
	_, err = c.napping.Get(c.URL+"/api/v2/firewall/ippool6", nil, &results, nil)
	if err != nil {
		return []*FirewallIppool6{}, fmt.Errorf("error listing FirewallIppool6s: %s", err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return []*FirewallIppool6{}, fmt.Errorf("error listing FirewallIppool6: not found")
		} else {
			return []*FirewallIppool6{}, fmt.Errorf("error listing FirewallIppool6: %s", errmsg.Status)
		}
	}
	res = results.Results
	return
}

// Get a FirewallIppool6 by name
func (c *WebClient) GetFirewallIppool6(mkey string) (res *FirewallIppool6, err error) {
	var errmsg Result
	var results FirewallIppool6Results
	_, err = c.napping.Get(c.URL+"/api/v2/firewall/ippool6/"+mkey, nil, &results, &errmsg)
	if err != nil {
		return &FirewallIppool6{}, fmt.Errorf("error getting FirewallIppool6 '%s': %s", mkey, err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return &FirewallIppool6{}, fmt.Errorf("error getting FirewallIppool6 '%s': not found", mkey)
		} else {
			return &FirewallIppool6{}, fmt.Errorf("error getting FirewallIppool6 '%s': %s", mkey, errmsg.Status)
		}
	}
	if len(results.Results) == 0 {
		return &FirewallIppool6{}, fmt.Errorf("error getting FirewallIppool6 '%s': not found", mkey)
	}

	res = results.Results[0]
	return
}

// Create a new FirewallIppool6
func (c *WebClient) CreateFirewallIppool6(obj *FirewallIppool6) (id string, err error) {
	var errmsg Result
	var results FirewallIppool6Results
	_, err = c.napping.Post(c.URL+"/api/v2/firewall/ippool6", obj, &results, &errmsg)
	if err != nil {
		return "", fmt.Errorf("error creating FirewallIppool6 '%s': %s", obj.Name, err.Error())
	}
	if results.HTTPStatus == 200 {
		return
	}
	if errmsg.HTTPStatus != 200 {
		return "", fmt.Errorf("error creating FirewallIppool6 '%s': %s", obj.Name, errmsg.Status)
	}

	return
}

// Update a FirewallIppool6
func (c *WebClient) UpdateFirewallIppool6(obj *FirewallIppool6) (err error) {
	var errmsg Result
	var results FirewallIppool6Results
	_, err = c.napping.Put(c.URL+"/api/v2/firewall/ippool6/"+obj.Name, obj, &results, &errmsg)
	if err != nil {
		return fmt.Errorf("error updating FirewallIppool6 '%s': %s", obj.Name, err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return fmt.Errorf("error updating FirewallIppool6 '%s': not found", obj.Name)
		} else {
			return fmt.Errorf("error updating FirewallIppool6 '%s': %s", obj.Name, errmsg.Status)
		}
	}

	return
}

// Delete a FirewallIppool6 by name
func (c *WebClient) DeleteFirewallIppool6(mkey string) (err error) {
	var errmsg Result
	var results FirewallIppool6Results
	_, err = c.napping.Delete(c.URL+"/api/v2/firewall/ippool6/"+mkey, nil, &results, &errmsg)
	if err != nil {
		return fmt.Errorf("error deleting FirewallIppool6 '%s': %s", mkey, err.Error())
	}
	if results.HTTPStatus == 200 {
		return
	}
	if errmsg.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return fmt.Errorf("error deleting FirewallIppool6 '%s': not found", mkey)
		}
		return fmt.Errorf("error deleting FirewallIppool6 '%s': %s", mkey, errmsg.Status)
	}

	return
}

// List all FirewallIppool6s
func (c *FakeClient) ListFirewallIppool6s() (res []*FirewallIppool6, err error) {
	for _, r := range c.FirewallIppool6s {
		res = append(res, r)
	}
	return
}

// Get a FirewallIppool6 by name
func (c *FakeClient) GetFirewallIppool6(mkey string) (*FirewallIppool6, error) {
	if res, ok := c.FirewallIppool6s[mkey]; ok {
		return res, nil
	} else {
		return &FirewallIppool6{}, fmt.Errorf("error getting FirewallIppool6 '%s': not found", mkey)
	}
}

// Create a new FirewallIppool6
func (c *FakeClient) CreateFirewallIppool6(obj *FirewallIppool6) (id string, err error) {
	id = obj.Name
	c.FirewallIppool6s[id] = obj
	return
}

// Update a FirewallIppool6
func (c *FakeClient) UpdateFirewallIppool6(obj *FirewallIppool6) (err error) {
	c.FirewallIppool6s[obj.Name] = obj
	return nil
}

// Delete a FirewallIppool6 by name
func (c *FakeClient) DeleteFirewallIppool6(mkey string) (err error) {
	delete(c.FirewallIppool6s, mkey)
	return nil
}

// Select the Monitor type used by the health check monitor to check the health of the server (PING | TCP | HTTP).
type FirewallLdbMonitorType string

const (
	// PING health monitor.
	FirewallLdbMonitorTypePing FirewallLdbMonitorType = "ping"

	// TCP-connect health monitor.
	FirewallLdbMonitorTypeTcp FirewallLdbMonitorType = "tcp"

	// HTTP-GET health monitor.
	FirewallLdbMonitorTypeHttp FirewallLdbMonitorType = "http"
)

// Configure server load balancing health monitors.
type FirewallLdbMonitor struct {

	// URL used to send a GET request to check the health of an HTTP server.
	HttpGet string `json:"http-get,omitempty"`

	// String to match the value expected in response to an HTTP-GET request.
	HttpMatch string `json:"http-match,omitempty"`

	// The maximum number of HTTP redirects to be allowed (0 - 5, default = 0).
	HttpMaxRedirects int `json:"http-max-redirects,omitempty"`

	// Time between health checks (5 - 65635 sec, default = 10).
	Interval int `json:"interval,omitempty"`

	// Monitor name.
	Name string `json:"name,omitempty"`

	// Service port used to perform the health check. If 0, health check monitor inherits port configured for the server (0 - 65635, default = 0).
	Port int `json:"port,omitempty"`

	// Number health check attempts before the server is considered down (1 - 255, default = 3).
	Retry int `json:"retry,omitempty"`

	// Time to wait to receive response to a health check from a server. Reaching the timeout means the health check failed (1 - 255 sec, default = 2).
	Timeout int `json:"timeout,omitempty"`

	// Select the Monitor type used by the health check monitor to check the health of the server (PING | TCP | HTTP).
	Type FirewallLdbMonitorType `json:"type,omitempty"`
}

// Returns the value that identifies a FirewallLdbMonitor
func (x *FirewallLdbMonitor) MKey() string {
	return x.Name
}

// The results of a Get or List operation
type FirewallLdbMonitorResults struct {
	Results []*FirewallLdbMonitor `json:"results"`
	Mkey    string                `json:"mkey"`
	Result
}

// List all FirewallLdbMonitors
func (c *WebClient) ListFirewallLdbMonitors() (res []*FirewallLdbMonitor, err error) {
	var errmsg Result
	var results FirewallLdbMonitorResults
	_, err = c.napping.Get(c.URL+"/api/v2/firewall/ldb-monitor", nil, &results, nil)
	if err != nil {
		return []*FirewallLdbMonitor{}, fmt.Errorf("error listing FirewallLdbMonitors: %s", err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return []*FirewallLdbMonitor{}, fmt.Errorf("error listing FirewallLdbMonitor: not found")
		} else {
			return []*FirewallLdbMonitor{}, fmt.Errorf("error listing FirewallLdbMonitor: %s", errmsg.Status)
		}
	}
	res = results.Results
	return
}

// Get a FirewallLdbMonitor by name
func (c *WebClient) GetFirewallLdbMonitor(mkey string) (res *FirewallLdbMonitor, err error) {
	var errmsg Result
	var results FirewallLdbMonitorResults
	_, err = c.napping.Get(c.URL+"/api/v2/firewall/ldb-monitor/"+mkey, nil, &results, &errmsg)
	if err != nil {
		return &FirewallLdbMonitor{}, fmt.Errorf("error getting FirewallLdbMonitor '%s': %s", mkey, err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return &FirewallLdbMonitor{}, fmt.Errorf("error getting FirewallLdbMonitor '%s': not found", mkey)
		} else {
			return &FirewallLdbMonitor{}, fmt.Errorf("error getting FirewallLdbMonitor '%s': %s", mkey, errmsg.Status)
		}
	}
	if len(results.Results) == 0 {
		return &FirewallLdbMonitor{}, fmt.Errorf("error getting FirewallLdbMonitor '%s': not found", mkey)
	}

	res = results.Results[0]
	return
}

// Create a new FirewallLdbMonitor
func (c *WebClient) CreateFirewallLdbMonitor(obj *FirewallLdbMonitor) (id string, err error) {
	var errmsg Result
	var results FirewallLdbMonitorResults
	_, err = c.napping.Post(c.URL+"/api/v2/firewall/ldb-monitor", obj, &results, &errmsg)
	if err != nil {
		return "", fmt.Errorf("error creating FirewallLdbMonitor '%s': %s", obj.Name, err.Error())
	}
	if results.HTTPStatus == 200 {
		return
	}
	if errmsg.HTTPStatus != 200 {
		return "", fmt.Errorf("error creating FirewallLdbMonitor '%s': %s", obj.Name, errmsg.Status)
	}

	return
}

// Update a FirewallLdbMonitor
func (c *WebClient) UpdateFirewallLdbMonitor(obj *FirewallLdbMonitor) (err error) {
	var errmsg Result
	var results FirewallLdbMonitorResults
	_, err = c.napping.Put(c.URL+"/api/v2/firewall/ldb-monitor/"+obj.Name, obj, &results, &errmsg)
	if err != nil {
		return fmt.Errorf("error updating FirewallLdbMonitor '%s': %s", obj.Name, err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return fmt.Errorf("error updating FirewallLdbMonitor '%s': not found", obj.Name)
		} else {
			return fmt.Errorf("error updating FirewallLdbMonitor '%s': %s", obj.Name, errmsg.Status)
		}
	}

	return
}

// Delete a FirewallLdbMonitor by name
func (c *WebClient) DeleteFirewallLdbMonitor(mkey string) (err error) {
	var errmsg Result
	var results FirewallLdbMonitorResults
	_, err = c.napping.Delete(c.URL+"/api/v2/firewall/ldb-monitor/"+mkey, nil, &results, &errmsg)
	if err != nil {
		return fmt.Errorf("error deleting FirewallLdbMonitor '%s': %s", mkey, err.Error())
	}
	if results.HTTPStatus == 200 {
		return
	}
	if errmsg.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return fmt.Errorf("error deleting FirewallLdbMonitor '%s': not found", mkey)
		}
		return fmt.Errorf("error deleting FirewallLdbMonitor '%s': %s", mkey, errmsg.Status)
	}

	return
}

// List all FirewallLdbMonitors
func (c *FakeClient) ListFirewallLdbMonitors() (res []*FirewallLdbMonitor, err error) {
	for _, r := range c.FirewallLdbMonitors {
		res = append(res, r)
	}
	return
}

// Get a FirewallLdbMonitor by name
func (c *FakeClient) GetFirewallLdbMonitor(mkey string) (*FirewallLdbMonitor, error) {
	if res, ok := c.FirewallLdbMonitors[mkey]; ok {
		return res, nil
	} else {
		return &FirewallLdbMonitor{}, fmt.Errorf("error getting FirewallLdbMonitor '%s': not found", mkey)
	}
}

// Create a new FirewallLdbMonitor
func (c *FakeClient) CreateFirewallLdbMonitor(obj *FirewallLdbMonitor) (id string, err error) {
	id = obj.Name
	c.FirewallLdbMonitors[id] = obj
	return
}

// Update a FirewallLdbMonitor
func (c *FakeClient) UpdateFirewallLdbMonitor(obj *FirewallLdbMonitor) (err error) {
	c.FirewallLdbMonitors[obj.Name] = obj
	return nil
}

// Delete a FirewallLdbMonitor by name
func (c *FakeClient) DeleteFirewallLdbMonitor(mkey string) (err error) {
	delete(c.FirewallLdbMonitors, mkey)
	return nil
}

// Enable to respond to ARP requests for this virtual IP address. Enabled by default.
type FirewallVipArpReply string

// External FQDN address name.
type FirewallVipExtaddr struct {

	// Address name.
	Name string `json:"name,omitempty"`
}

// Enable/disable use of HTTP cookie domain from host field in HTTP.
type FirewallVipHttpCookieDomainFromHost string

// Control sharing of cookies across virtual servers. same-ip means a cookie from one virtual server can be used by another. Disable stops cookie sharing.
type FirewallVipHttpCookieShare string

// For HTTP multiplexing, enable to add the original client IP address in the XForwarded-For HTTP header.
type FirewallVipHttpIpHeader string

// Enable/disable HTTP multiplexing.
type FirewallVipHttpMultiplex string

// Method used to distribute sessions to real servers.
type FirewallVipLdbMethod string

// IP address or address range on the destination network to which the external IP address is mapped.
type FirewallVipMappedip struct {

	// Mapped IP range.
	Range string `json:"range,omitempty"`
}

// Name of the health check monitor to use when polling to determine a virtual server's connectivity status.
type FirewallVipMonitor struct {

	// Health monitor name.
	Name string `json:"name,omitempty"`
}

// Enable to prevent unintended servers from using a virtual IP. Disable to use the actual IP address of the server as the source address.
type FirewallVipNatSourceVip string

// Enable to add the Front-End-Https header for Microsoft Outlook Web Access.
type FirewallVipOutlookWebAccess string

// Configure how to make sure that clients connect to the same server every time they make a request that is part of the same session.
type FirewallVipPersistence string

// Enable/disable port forwarding.
type FirewallVipPortforward string

// Port mapping type.
type FirewallVipPortmappingType string

// Protocol to use when forwarding packets.
type FirewallVipProtocol string

// Select the real servers that this server load balancing VIP will distribute traffic to.
type FirewallVipRealservers struct {

	// Only clients in this IP range can connect to this real server.
	ClientIp string `json:"client-ip,omitempty"`

	// Enable to check the responsiveness of the real server before forwarding traffic.
	Healthcheck string `json:"healthcheck,omitempty"`

	// Time in seconds that the health check monitor continues to monitor and unresponsive server that should be active.
	HolddownInterval int `json:"holddown-interval,omitempty"`

	// HTTP server domain name in HTTP header.
	HttpHost string `json:"http-host,omitempty"`

	// Real server ID.
	Id int `json:"id,omitempty"`

	// IP address of the real server.
	Ip string `json:"ip,omitempty"`

	// Max number of active connections that can be directed to the real server. When reached, sessions are sent to other real servers.
	MaxConnections int `json:"max-connections,omitempty"`

	// Name of the health check monitor to use when polling to determine a virtual server's connectivity status.
	Monitor string `json:"monitor,omitempty"`

	// Port for communicating with the real server. Required if port forwarding is enabled.
	Port int `json:"port,omitempty"`

	// Set the status of the real server to active so that it can accept traffic, or on standby or disabled so no traffic is sent.
	Status string `json:"status,omitempty"`

	// Weight of the real server. If weighted load balancing is enabled, the server with the highest weight gets more connections.
	Weight int `json:"weight,omitempty"`
}

// Protocol to be load balanced by the virtual server (also called the server load balance virtual IP).
type FirewallVipServerType string

// Service name.
type FirewallVipService struct {

	// Service name.
	Name string `json:"name,omitempty"`
}

// Source address filter. Each address must be either an IP/subnet (x.x.x.x/n) or a range (x.x.x.x-y.y.y.y). Separate addresses with spaces.
type FirewallVipSrcFilter struct {

	// Source-filter range.
	Range string `json:"range,omitempty"`
}

// Interfaces to which the VIP applies. Separate the names with spaces.
type FirewallVipSrcintfFilter struct {

	// Interface name.
	InterfaceName string `json:"interface-name,omitempty"`
}

// Configure a static NAT, load balance, server load balance, DNS translation, or FQDN VIP.
type FirewallVipType string

// Enable to add an HTTP header to indicate SSL offloading for a WebLogic server.
type FirewallVipWeblogicServer string

// Enable to add an HTTP header to indicate SSL offloading for a WebSphere server.
type FirewallVipWebsphereServer string

const (
	// Disable ARP reply.
	FirewallVipArpReplyDisable FirewallVipArpReply = "disable"

	// Enable ARP reply.
	FirewallVipArpReplyEnable FirewallVipArpReply = "enable"
)

const (
	// Disable use of HTTP cookie domain from host field in HTTP (use http-cooke-domain setting).
	FirewallVipHttpCookieDomainFromHostDisable FirewallVipHttpCookieDomainFromHost = "disable"

	// Enable use of HTTP cookie domain from host field in HTTP.
	FirewallVipHttpCookieDomainFromHostEnable FirewallVipHttpCookieDomainFromHost = "enable"
)

const (
	// Only allow HTTP cookie to match this virtual server.
	FirewallVipHttpCookieShareDisable FirewallVipHttpCookieShare = "disable"

	// Allow HTTP cookie to match any virtual server with same IP.
	FirewallVipHttpCookieShareSameIp FirewallVipHttpCookieShare = "same-ip"
)

const (
	// Enable adding HTTP header.
	FirewallVipHttpIpHeaderEnable FirewallVipHttpIpHeader = "enable"

	// Disable adding HTTP header.
	FirewallVipHttpIpHeaderDisable FirewallVipHttpIpHeader = "disable"
)

const (
	// Enable HTTP session multiplexing.
	FirewallVipHttpMultiplexEnable FirewallVipHttpMultiplex = "enable"

	// Disable HTTP session multiplexing.
	FirewallVipHttpMultiplexDisable FirewallVipHttpMultiplex = "disable"
)

const (
	// Distribute to server based on source IP.
	FirewallVipLdbMethodStatic FirewallVipLdbMethod = "static"

	// Distribute to server based round robin order.
	FirewallVipLdbMethodRoundRobin FirewallVipLdbMethod = "round-robin"

	// Distribute to server based on weight.
	FirewallVipLdbMethodWeighted FirewallVipLdbMethod = "weighted"

	// Distribute to server with lowest session count.
	FirewallVipLdbMethodLeastSession FirewallVipLdbMethod = "least-session"

	// Distribute to server with lowest Round-Trip-Time.
	FirewallVipLdbMethodLeastRtt FirewallVipLdbMethod = "least-rtt"

	// Distribute to the first server that is alive.
	FirewallVipLdbMethodFirstAlive FirewallVipLdbMethod = "first-alive"

	// Distribute to server based on host field in HTTP header.
	FirewallVipLdbMethodHttpHost FirewallVipLdbMethod = "http-host"
)

const (
	// Do not force to NAT as VIP.
	FirewallVipNatSourceVipDisable FirewallVipNatSourceVip = "disable"

	// Force to NAT as VIP.
	FirewallVipNatSourceVipEnable FirewallVipNatSourceVip = "enable"
)

const (
	// Disable Outlook Web Access support.
	FirewallVipOutlookWebAccessDisable FirewallVipOutlookWebAccess = "disable"

	// Enable Outlook Web Access support.
	FirewallVipOutlookWebAccessEnable FirewallVipOutlookWebAccess = "enable"
)

const (
	// None.
	FirewallVipPersistenceNone FirewallVipPersistence = "none"

	// HTTP cookie.
	FirewallVipPersistenceHttpCookie FirewallVipPersistence = "http-cookie"
)

const (
	// Disable port forward.
	FirewallVipPortforwardDisable FirewallVipPortforward = "disable"

	// Enable port forward.
	FirewallVipPortforwardEnable FirewallVipPortforward = "enable"
)

const (
	// One to one.
	FirewallVipPortmappingType1To1 FirewallVipPortmappingType = "1-to-1"

	// Many to many.
	FirewallVipPortmappingTypeMToN FirewallVipPortmappingType = "m-to-n"
)

const (
	// TCP.
	FirewallVipProtocolTcp FirewallVipProtocol = "tcp"

	// UDP.
	FirewallVipProtocolUdp FirewallVipProtocol = "udp"

	// SCTP.
	FirewallVipProtocolSctp FirewallVipProtocol = "sctp"

	// ICMP.
	FirewallVipProtocolIcmp FirewallVipProtocol = "icmp"
)

const (
	// HTTP
	FirewallVipServerTypeHttp FirewallVipServerType = "http"

	// TCP
	FirewallVipServerTypeTcp FirewallVipServerType = "tcp"

	// UDP
	FirewallVipServerTypeUdp FirewallVipServerType = "udp"

	// IP
	FirewallVipServerTypeIp FirewallVipServerType = "ip"
)

const (
	// Static NAT.
	FirewallVipTypeStaticNat FirewallVipType = "static-nat"

	// Load balance.
	FirewallVipTypeLoadBalance FirewallVipType = "load-balance"

	// Server load balance.
	FirewallVipTypeServerLoadBalance FirewallVipType = "server-load-balance"

	// DNS translation.
	FirewallVipTypeDnsTranslation FirewallVipType = "dns-translation"

	// Fully qualified domain name.
	FirewallVipTypeFqdn FirewallVipType = "fqdn"
)

const (
	// Do not add HTTP header indicating SSL offload for WebLogic server.
	FirewallVipWeblogicServerDisable FirewallVipWeblogicServer = "disable"

	// Add HTTP header indicating SSL offload for WebLogic server.
	FirewallVipWeblogicServerEnable FirewallVipWeblogicServer = "enable"
)

const (
	// Do not add HTTP header indicating SSL offload for WebSphere server.
	FirewallVipWebsphereServerDisable FirewallVipWebsphereServer = "disable"

	// Add HTTP header indicating SSL offload for WebSphere server.
	FirewallVipWebsphereServerEnable FirewallVipWebsphereServer = "enable"
)

// Configure virtual IP for IPv4.
type FirewallVip struct {

	// Enable to respond to ARP requests for this virtual IP address. Enabled by default.
	ArpReply FirewallVipArpReply `json:"arp-reply,omitempty"`

	// Color of icon on the GUI.
	Color int `json:"color,omitempty"`

	// Comment.
	Comment string `json:"comment,omitempty"`

	// DNS mapping TTL (Set to zero to use TTL in DNS response, default = 0).
	DnsMappingTtl int `json:"dns-mapping-ttl,omitempty"`

	// External FQDN address name.
	Extaddr []FirewallVipExtaddr `json:"extaddr,omitempty"`

	// Interface connected to the source network that receives the packets that will be forwarded to the destination network.
	Extintf string `json:"extintf,omitempty"`

	// IP address or address range on the external interface that you want to map to an address or address range on the destination network.
	Extip string `json:"extip,omitempty"`

	// Incoming port number range that you want to map to a port number range on the destination network.
	Extport string `json:"extport,omitempty"`

	// Enable to have the VIP send gratuitous ARPs. 0=disabled. Set from 5 up to 8640000 seconds to enable.
	GratuitousArpInterval int `json:"gratuitous-arp-interval,omitempty"`

	// Time in minutes that client web browsers should keep a cookie. Default is 60 seconds. 0 = no time limit.
	HttpCookieAge int `json:"http-cookie-age,omitempty"`

	// Domain that HTTP cookie persistence should apply to.
	HttpCookieDomain string `json:"http-cookie-domain,omitempty"`

	// Enable/disable use of HTTP cookie domain from host field in HTTP.
	HttpCookieDomainFromHost FirewallVipHttpCookieDomainFromHost `json:"http-cookie-domain-from-host,omitempty"`

	// Generation of HTTP cookie to be accepted. Changing invalidates all existing cookies.
	HttpCookieGeneration int `json:"http-cookie-generation,omitempty"`

	// Limit HTTP cookie persistence to the specified path.
	HttpCookiePath string `json:"http-cookie-path,omitempty"`

	// Control sharing of cookies across virtual servers. same-ip means a cookie from one virtual server can be used by another. Disable stops cookie sharing.
	HttpCookieShare FirewallVipHttpCookieShare `json:"http-cookie-share,omitempty"`

	// For HTTP multiplexing, enable to add the original client IP address in the XForwarded-For HTTP header.
	HttpIpHeader FirewallVipHttpIpHeader `json:"http-ip-header,omitempty"`

	// For HTTP multiplexing, enter a custom HTTPS header name. The original client IP address is added to this header. If empty, X-Forwarded-For is used.
	HttpIpHeaderName string `json:"http-ip-header-name,omitempty"`

	// Enable/disable HTTP multiplexing.
	HttpMultiplex FirewallVipHttpMultiplex `json:"http-multiplex,omitempty"`

	// Custom defined ID.
	Id int `json:"id,omitempty"`

	// Method used to distribute sessions to real servers.
	LdbMethod FirewallVipLdbMethod `json:"ldb-method,omitempty"`

	// Mapped FQDN address name.
	MappedAddr string `json:"mapped-addr,omitempty"`

	// IP address or address range on the destination network to which the external IP address is mapped.
	Mappedip []FirewallVipMappedip `json:"mappedip,omitempty"`

	// Port number range on the destination network to which the external port number range is mapped.
	Mappedport string `json:"mappedport,omitempty"`

	// Maximum number of incomplete connections.
	MaxEmbryonicConnections int `json:"max-embryonic-connections,omitempty"`

	// Name of the health check monitor to use when polling to determine a virtual server's connectivity status.
	Monitor []FirewallVipMonitor `json:"monitor,omitempty"`

	// Virtual IP name.
	Name string `json:"name,omitempty"`

	// Enable to prevent unintended servers from using a virtual IP. Disable to use the actual IP address of the server as the source address.
	NatSourceVip FirewallVipNatSourceVip `json:"nat-source-vip,omitempty"`

	// Enable to add the Front-End-Https header for Microsoft Outlook Web Access.
	OutlookWebAccess FirewallVipOutlookWebAccess `json:"outlook-web-access,omitempty"`

	// Configure how to make sure that clients connect to the same server every time they make a request that is part of the same session.
	Persistence FirewallVipPersistence `json:"persistence,omitempty"`

	// Enable/disable port forwarding.
	Portforward FirewallVipPortforward `json:"portforward,omitempty"`

	// Port mapping type.
	PortmappingType FirewallVipPortmappingType `json:"portmapping-type,omitempty"`

	// Protocol to use when forwarding packets.
	Protocol FirewallVipProtocol `json:"protocol,omitempty"`

	// Select the real servers that this server load balancing VIP will distribute traffic to.
	Realservers []FirewallVipRealservers `json:"realservers,omitempty"`

	// Protocol to be load balanced by the virtual server (also called the server load balance virtual IP).
	ServerType FirewallVipServerType `json:"server-type,omitempty"`

	// Service name.
	Service []FirewallVipService `json:"service,omitempty"`

	// Source address filter. Each address must be either an IP/subnet (x.x.x.x/n) or a range (x.x.x.x-y.y.y.y). Separate addresses with spaces.
	SrcFilter []FirewallVipSrcFilter `json:"src-filter,omitempty"`

	// Interfaces to which the VIP applies. Separate the names with spaces.
	SrcintfFilter []FirewallVipSrcintfFilter `json:"srcintf-filter,omitempty"`

	// Configure a static NAT, load balance, server load balance, DNS translation, or FQDN VIP.
	Type FirewallVipType `json:"type,omitempty"`

	// Universally Unique Identifier (UUID; automatically assigned but can be manually reset).
	Uuid string `json:"uuid,omitempty"`

	// Enable to add an HTTP header to indicate SSL offloading for a WebLogic server.
	WeblogicServer FirewallVipWeblogicServer `json:"weblogic-server,omitempty"`

	// Enable to add an HTTP header to indicate SSL offloading for a WebSphere server.
	WebsphereServer FirewallVipWebsphereServer `json:"websphere-server,omitempty"`
}

// Returns the value that identifies a FirewallVip
func (x *FirewallVip) MKey() string {
	return x.Name
}

// The results of a Get or List operation
type FirewallVipResults struct {
	Results []*FirewallVip `json:"results"`
	Mkey    string         `json:"mkey"`
	Result
}

// List all FirewallVips
func (c *WebClient) ListFirewallVips() (res []*FirewallVip, err error) {
	var errmsg Result
	var results FirewallVipResults
	_, err = c.napping.Get(c.URL+"/api/v2/firewall/vip", nil, &results, nil)
	if err != nil {
		return []*FirewallVip{}, fmt.Errorf("error listing FirewallVips: %s", err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return []*FirewallVip{}, fmt.Errorf("error listing FirewallVip: not found")
		} else {
			return []*FirewallVip{}, fmt.Errorf("error listing FirewallVip: %s", errmsg.Status)
		}
	}
	res = results.Results
	return
}

// Get a FirewallVip by name
func (c *WebClient) GetFirewallVip(mkey string) (res *FirewallVip, err error) {
	var errmsg Result
	var results FirewallVipResults
	_, err = c.napping.Get(c.URL+"/api/v2/firewall/vip/"+mkey, nil, &results, &errmsg)
	if err != nil {
		return &FirewallVip{}, fmt.Errorf("error getting FirewallVip '%s': %s", mkey, err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return &FirewallVip{}, fmt.Errorf("error getting FirewallVip '%s': not found", mkey)
		} else {
			return &FirewallVip{}, fmt.Errorf("error getting FirewallVip '%s': %s", mkey, errmsg.Status)
		}
	}
	if len(results.Results) == 0 {
		return &FirewallVip{}, fmt.Errorf("error getting FirewallVip '%s': not found", mkey)
	}

	res = results.Results[0]
	return
}

// Create a new FirewallVip
func (c *WebClient) CreateFirewallVip(obj *FirewallVip) (id string, err error) {
	var errmsg Result
	var results FirewallVipResults
	_, err = c.napping.Post(c.URL+"/api/v2/firewall/vip", obj, &results, &errmsg)
	if err != nil {
		return "", fmt.Errorf("error creating FirewallVip '%s': %s", obj.Name, err.Error())
	}
	if results.HTTPStatus == 200 {
		return
	}
	if errmsg.HTTPStatus != 200 {
		return "", fmt.Errorf("error creating FirewallVip '%s': %s", obj.Name, errmsg.Status)
	}

	return
}

// Update a FirewallVip
func (c *WebClient) UpdateFirewallVip(obj *FirewallVip) (err error) {
	var errmsg Result
	var results FirewallVipResults
	_, err = c.napping.Put(c.URL+"/api/v2/firewall/vip/"+obj.Name, obj, &results, &errmsg)
	if err != nil {
		return fmt.Errorf("error updating FirewallVip '%s': %s", obj.Name, err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return fmt.Errorf("error updating FirewallVip '%s': not found", obj.Name)
		} else {
			return fmt.Errorf("error updating FirewallVip '%s': %s", obj.Name, errmsg.Status)
		}
	}

	return
}

// Delete a FirewallVip by name
func (c *WebClient) DeleteFirewallVip(mkey string) (err error) {
	var errmsg Result
	var results FirewallVipResults
	_, err = c.napping.Delete(c.URL+"/api/v2/firewall/vip/"+mkey, nil, &results, &errmsg)
	if err != nil {
		return fmt.Errorf("error deleting FirewallVip '%s': %s", mkey, err.Error())
	}
	if results.HTTPStatus == 200 {
		return
	}
	if errmsg.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return fmt.Errorf("error deleting FirewallVip '%s': not found", mkey)
		}
		return fmt.Errorf("error deleting FirewallVip '%s': %s", mkey, errmsg.Status)
	}

	return
}

// List all FirewallVips
func (c *FakeClient) ListFirewallVips() (res []*FirewallVip, err error) {
	for _, r := range c.FirewallVips {
		res = append(res, r)
	}
	return
}

// Get a FirewallVip by name
func (c *FakeClient) GetFirewallVip(mkey string) (*FirewallVip, error) {
	if res, ok := c.FirewallVips[mkey]; ok {
		return res, nil
	} else {
		return &FirewallVip{}, fmt.Errorf("error getting FirewallVip '%s': not found", mkey)
	}
}

// Create a new FirewallVip
func (c *FakeClient) CreateFirewallVip(obj *FirewallVip) (id string, err error) {
	id = obj.Name
	c.FirewallVips[id] = obj
	return
}

// Update a FirewallVip
func (c *FakeClient) UpdateFirewallVip(obj *FirewallVip) (err error) {
	c.FirewallVips[obj.Name] = obj
	return nil
}

// Delete a FirewallVip by name
func (c *FakeClient) DeleteFirewallVip(mkey string) (err error) {
	delete(c.FirewallVips, mkey)
	return nil
}

// Enable to respond to ARP requests for this virtual IP address. Enabled by default.
type VIPArpReply string

// External FQDN address name.
type VIPExtaddr struct {

	// Address name.
	Name string `json:"name,omitempty"`
}

// Enable/disable use of HTTP cookie domain from host field in HTTP.
type VIPHttpCookieDomainFromHost string

// Control sharing of cookies across virtual servers. same-ip means a cookie from one virtual server can be used by another. Disable stops cookie sharing.
type VIPHttpCookieShare string

// For HTTP multiplexing, enable to add the original client IP address in the XForwarded-For HTTP header.
type VIPHttpIpHeader string

// Enable/disable HTTP multiplexing.
type VIPHttpMultiplex string

// Method used to distribute sessions to real servers.
type VIPLdbMethod string

// IP address or address range on the destination network to which the external IP address is mapped.
type VIPMappedip struct {

	// Mapped IP range.
	Range string `json:"range,omitempty"`
}

// Name of the health check monitor to use when polling to determine a virtual server's connectivity status.
type VIPMonitor struct {

	// Health monitor name.
	Name string `json:"name,omitempty"`
}

// Enable to prevent unintended servers from using a virtual IP. Disable to use the actual IP address of the server as the source address.
type VIPNatSourceVip string

// Enable to add the Front-End-Https header for Microsoft Outlook Web Access.
type VIPOutlookWebAccess string

// Configure how to make sure that clients connect to the same server every time they make a request that is part of the same session.
type VIPPersistence string

// Enable/disable port forwarding.
type VIPPortforward string

// Port mapping type.
type VIPPortmappingType string

// Protocol to use when forwarding packets.
type VIPProtocol string

// Select the real servers that this server load balancing VIP will distribute traffic to.
type VIPRealservers struct {

	// Only clients in this IP range can connect to this real server.
	ClientIp string `json:"client-ip,omitempty"`

	// Enable to check the responsiveness of the real server before forwarding traffic.
	Healthcheck string `json:"healthcheck,omitempty"`

	// Time in seconds that the health check monitor continues to monitor and unresponsive server that should be active.
	HolddownInterval int `json:"holddown-interval,omitempty"`

	// HTTP server domain name in HTTP header.
	HttpHost string `json:"http-host,omitempty"`

	// Real server ID.
	Id int `json:"id,omitempty"`

	// IP address of the real server.
	Ip string `json:"ip,omitempty"`

	// Max number of active connections that can be directed to the real server. When reached, sessions are sent to other real servers.
	MaxConnections int `json:"max-connections,omitempty"`

	// Name of the health check monitor to use when polling to determine a virtual server's connectivity status.
	Monitor string `json:"monitor,omitempty"`

	// Port for communicating with the real server. Required if port forwarding is enabled.
	Port int `json:"port,omitempty"`

	// Set the status of the real server to active so that it can accept traffic, or on standby or disabled so no traffic is sent.
	Status string `json:"status,omitempty"`

	// Weight of the real server. If weighted load balancing is enabled, the server with the highest weight gets more connections.
	Weight int `json:"weight,omitempty"`
}

// Protocol to be load balanced by the virtual server (also called the server load balance virtual IP).
type VIPServerType string

// Service name.
type VIPService struct {

	// Service name.
	Name string `json:"name,omitempty"`
}

// Source address filter. Each address must be either an IP/subnet (x.x.x.x/n) or a range (x.x.x.x-y.y.y.y). Separate addresses with spaces.
type VIPSrcFilter struct {

	// Source-filter range.
	Range string `json:"range,omitempty"`
}

// Interfaces to which the VIP applies. Separate the names with spaces.
type VIPSrcintfFilter struct {

	// Interface name.
	InterfaceName string `json:"interface-name,omitempty"`
}

// Configure a static NAT, load balance, server load balance, DNS translation, or FQDN VIP.
type VIPType string

// Enable to add an HTTP header to indicate SSL offloading for a WebLogic server.
type VIPWeblogicServer string

// Enable to add an HTTP header to indicate SSL offloading for a WebSphere server.
type VIPWebsphereServer string

const (
	// Disable ARP reply.
	VIPArpReplyDisable VIPArpReply = "disable"

	// Enable ARP reply.
	VIPArpReplyEnable VIPArpReply = "enable"
)

const (
	// Disable use of HTTP cookie domain from host field in HTTP (use http-cooke-domain setting).
	VIPHttpCookieDomainFromHostDisable VIPHttpCookieDomainFromHost = "disable"

	// Enable use of HTTP cookie domain from host field in HTTP.
	VIPHttpCookieDomainFromHostEnable VIPHttpCookieDomainFromHost = "enable"
)

const (
	// Only allow HTTP cookie to match this virtual server.
	VIPHttpCookieShareDisable VIPHttpCookieShare = "disable"

	// Allow HTTP cookie to match any virtual server with same IP.
	VIPHttpCookieShareSameIp VIPHttpCookieShare = "same-ip"
)

const (
	// Enable adding HTTP header.
	VIPHttpIpHeaderEnable VIPHttpIpHeader = "enable"

	// Disable adding HTTP header.
	VIPHttpIpHeaderDisable VIPHttpIpHeader = "disable"
)

const (
	// Enable HTTP session multiplexing.
	VIPHttpMultiplexEnable VIPHttpMultiplex = "enable"

	// Disable HTTP session multiplexing.
	VIPHttpMultiplexDisable VIPHttpMultiplex = "disable"
)

const (
	// Distribute to server based on source IP.
	VIPLdbMethodStatic VIPLdbMethod = "static"

	// Distribute to server based round robin order.
	VIPLdbMethodRoundRobin VIPLdbMethod = "round-robin"

	// Distribute to server based on weight.
	VIPLdbMethodWeighted VIPLdbMethod = "weighted"

	// Distribute to server with lowest session count.
	VIPLdbMethodLeastSession VIPLdbMethod = "least-session"

	// Distribute to server with lowest Round-Trip-Time.
	VIPLdbMethodLeastRtt VIPLdbMethod = "least-rtt"

	// Distribute to the first server that is alive.
	VIPLdbMethodFirstAlive VIPLdbMethod = "first-alive"

	// Distribute to server based on host field in HTTP header.
	VIPLdbMethodHttpHost VIPLdbMethod = "http-host"
)

const (
	// Do not force to NAT as VIP.
	VIPNatSourceVipDisable VIPNatSourceVip = "disable"

	// Force to NAT as VIP.
	VIPNatSourceVipEnable VIPNatSourceVip = "enable"
)

const (
	// Disable Outlook Web Access support.
	VIPOutlookWebAccessDisable VIPOutlookWebAccess = "disable"

	// Enable Outlook Web Access support.
	VIPOutlookWebAccessEnable VIPOutlookWebAccess = "enable"
)

const (
	// None.
	VIPPersistenceNone VIPPersistence = "none"

	// HTTP cookie.
	VIPPersistenceHttpCookie VIPPersistence = "http-cookie"
)

const (
	// Disable port forward.
	VIPPortforwardDisable VIPPortforward = "disable"

	// Enable port forward.
	VIPPortforwardEnable VIPPortforward = "enable"
)

const (
	// One to one.
	VIPPortmappingType1To1 VIPPortmappingType = "1-to-1"

	// Many to many.
	VIPPortmappingTypeMToN VIPPortmappingType = "m-to-n"
)

const (
	// TCP.
	VIPProtocolTcp VIPProtocol = "tcp"

	// UDP.
	VIPProtocolUdp VIPProtocol = "udp"

	// SCTP.
	VIPProtocolSctp VIPProtocol = "sctp"

	// ICMP.
	VIPProtocolIcmp VIPProtocol = "icmp"
)

const (
	// HTTP
	VIPServerTypeHttp VIPServerType = "http"

	// TCP
	VIPServerTypeTcp VIPServerType = "tcp"

	// UDP
	VIPServerTypeUdp VIPServerType = "udp"

	// IP
	VIPServerTypeIp VIPServerType = "ip"
)

const (
	// Static NAT.
	VIPTypeStaticNat VIPType = "static-nat"

	// Load balance.
	VIPTypeLoadBalance VIPType = "load-balance"

	// Server load balance.
	VIPTypeServerLoadBalance VIPType = "server-load-balance"

	// DNS translation.
	VIPTypeDnsTranslation VIPType = "dns-translation"

	// Fully qualified domain name.
	VIPTypeFqdn VIPType = "fqdn"
)

const (
	// Do not add HTTP header indicating SSL offload for WebLogic server.
	VIPWeblogicServerDisable VIPWeblogicServer = "disable"

	// Add HTTP header indicating SSL offload for WebLogic server.
	VIPWeblogicServerEnable VIPWeblogicServer = "enable"
)

const (
	// Do not add HTTP header indicating SSL offload for WebSphere server.
	VIPWebsphereServerDisable VIPWebsphereServer = "disable"

	// Add HTTP header indicating SSL offload for WebSphere server.
	VIPWebsphereServerEnable VIPWebsphereServer = "enable"
)

// Configure virtual IP for IPv4.
type VIP struct {

	// Enable to respond to ARP requests for this virtual IP address. Enabled by default.
	ArpReply VIPArpReply `json:"arp-reply,omitempty"`

	// Color of icon on the GUI.
	Color int `json:"color,omitempty"`

	// Comment.
	Comment string `json:"comment,omitempty"`

	// DNS mapping TTL (Set to zero to use TTL in DNS response, default = 0).
	DnsMappingTtl int `json:"dns-mapping-ttl,omitempty"`

	// External FQDN address name.
	Extaddr []VIPExtaddr `json:"extaddr,omitempty"`

	// Interface connected to the source network that receives the packets that will be forwarded to the destination network.
	Extintf string `json:"extintf,omitempty"`

	// IP address or address range on the external interface that you want to map to an address or address range on the destination network.
	Extip string `json:"extip,omitempty"`

	// Incoming port number range that you want to map to a port number range on the destination network.
	Extport string `json:"extport,omitempty"`

	// Enable to have the VIP send gratuitous ARPs. 0=disabled. Set from 5 up to 8640000 seconds to enable.
	GratuitousArpInterval int `json:"gratuitous-arp-interval,omitempty"`

	// Time in minutes that client web browsers should keep a cookie. Default is 60 seconds. 0 = no time limit.
	HttpCookieAge int `json:"http-cookie-age,omitempty"`

	// Domain that HTTP cookie persistence should apply to.
	HttpCookieDomain string `json:"http-cookie-domain,omitempty"`

	// Enable/disable use of HTTP cookie domain from host field in HTTP.
	HttpCookieDomainFromHost VIPHttpCookieDomainFromHost `json:"http-cookie-domain-from-host,omitempty"`

	// Generation of HTTP cookie to be accepted. Changing invalidates all existing cookies.
	HttpCookieGeneration int `json:"http-cookie-generation,omitempty"`

	// Limit HTTP cookie persistence to the specified path.
	HttpCookiePath string `json:"http-cookie-path,omitempty"`

	// Control sharing of cookies across virtual servers. same-ip means a cookie from one virtual server can be used by another. Disable stops cookie sharing.
	HttpCookieShare VIPHttpCookieShare `json:"http-cookie-share,omitempty"`

	// For HTTP multiplexing, enable to add the original client IP address in the XForwarded-For HTTP header.
	HttpIpHeader VIPHttpIpHeader `json:"http-ip-header,omitempty"`

	// For HTTP multiplexing, enter a custom HTTPS header name. The original client IP address is added to this header. If empty, X-Forwarded-For is used.
	HttpIpHeaderName string `json:"http-ip-header-name,omitempty"`

	// Enable/disable HTTP multiplexing.
	HttpMultiplex VIPHttpMultiplex `json:"http-multiplex,omitempty"`

	// Custom defined ID.
	Id int `json:"id,omitempty"`

	// Method used to distribute sessions to real servers.
	LdbMethod VIPLdbMethod `json:"ldb-method,omitempty"`

	// Mapped FQDN address name.
	MappedAddr string `json:"mapped-addr,omitempty"`

	// IP address or address range on the destination network to which the external IP address is mapped.
	Mappedip []VIPMappedip `json:"mappedip,omitempty"`

	// Port number range on the destination network to which the external port number range is mapped.
	Mappedport string `json:"mappedport,omitempty"`

	// Maximum number of incomplete connections.
	MaxEmbryonicConnections int `json:"max-embryonic-connections,omitempty"`

	// Name of the health check monitor to use when polling to determine a virtual server's connectivity status.
	Monitor []VIPMonitor `json:"monitor,omitempty"`

	// Virtual IP name.
	Name string `json:"name,omitempty"`

	// Enable to prevent unintended servers from using a virtual IP. Disable to use the actual IP address of the server as the source address.
	NatSourceVip VIPNatSourceVip `json:"nat-source-vip,omitempty"`

	// Enable to add the Front-End-Https header for Microsoft Outlook Web Access.
	OutlookWebAccess VIPOutlookWebAccess `json:"outlook-web-access,omitempty"`

	// Configure how to make sure that clients connect to the same server every time they make a request that is part of the same session.
	Persistence VIPPersistence `json:"persistence,omitempty"`

	// Enable/disable port forwarding.
	Portforward VIPPortforward `json:"portforward,omitempty"`

	// Port mapping type.
	PortmappingType VIPPortmappingType `json:"portmapping-type,omitempty"`

	// Protocol to use when forwarding packets.
	Protocol VIPProtocol `json:"protocol,omitempty"`

	// Select the real servers that this server load balancing VIP will distribute traffic to.
	Realservers []VIPRealservers `json:"realservers,omitempty"`

	// Protocol to be load balanced by the virtual server (also called the server load balance virtual IP).
	ServerType VIPServerType `json:"server-type,omitempty"`

	// Service name.
	Service []VIPService `json:"service,omitempty"`

	// Source address filter. Each address must be either an IP/subnet (x.x.x.x/n) or a range (x.x.x.x-y.y.y.y). Separate addresses with spaces.
	SrcFilter []VIPSrcFilter `json:"src-filter,omitempty"`

	// Interfaces to which the VIP applies. Separate the names with spaces.
	SrcintfFilter []VIPSrcintfFilter `json:"srcintf-filter,omitempty"`

	// Configure a static NAT, load balance, server load balance, DNS translation, or FQDN VIP.
	Type VIPType `json:"type,omitempty"`

	// Universally Unique Identifier (UUID; automatically assigned but can be manually reset).
	Uuid string `json:"uuid,omitempty"`

	// Enable to add an HTTP header to indicate SSL offloading for a WebLogic server.
	WeblogicServer VIPWeblogicServer `json:"weblogic-server,omitempty"`

	// Enable to add an HTTP header to indicate SSL offloading for a WebSphere server.
	WebsphereServer VIPWebsphereServer `json:"websphere-server,omitempty"`
}

// Returns the value that identifies a VIP
func (x *VIP) MKey() string {
	return x.Name
}

// The results of a Get or List operation
type VIPResults struct {
	Results []*VIP `json:"results"`
	Mkey    string `json:"mkey"`
	Result
}

// List all VIPs
func (c *WebClient) ListVIPs() (res []*VIP, err error) {
	var errmsg Result
	var results VIPResults
	_, err = c.napping.Get(c.URL+"/api/v2/firewall/vip", nil, &results, nil)
	if err != nil {
		return []*VIP{}, fmt.Errorf("error listing VIPs: %s", err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return []*VIP{}, fmt.Errorf("error listing VIP: not found")
		} else {
			return []*VIP{}, fmt.Errorf("error listing VIP: %s", errmsg.Status)
		}
	}
	res = results.Results
	return
}

// Get a VIP by name
func (c *WebClient) GetVIP(mkey string) (res *VIP, err error) {
	var errmsg Result
	var results VIPResults
	_, err = c.napping.Get(c.URL+"/api/v2/firewall/vip/"+mkey, nil, &results, &errmsg)
	if err != nil {
		return &VIP{}, fmt.Errorf("error getting VIP '%s': %s", mkey, err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return &VIP{}, fmt.Errorf("error getting VIP '%s': not found", mkey)
		} else {
			return &VIP{}, fmt.Errorf("error getting VIP '%s': %s", mkey, errmsg.Status)
		}
	}
	if len(results.Results) == 0 {
		return &VIP{}, fmt.Errorf("error getting VIP '%s': not found", mkey)
	}

	res = results.Results[0]
	return
}

// Create a new VIP
func (c *WebClient) CreateVIP(obj *VIP) (id string, err error) {
	var errmsg Result
	var results VIPResults
	_, err = c.napping.Post(c.URL+"/api/v2/firewall/vip", obj, &results, &errmsg)
	if err != nil {
		return "", fmt.Errorf("error creating VIP '%s': %s", obj.Name, err.Error())
	}
	if results.HTTPStatus == 200 {
		return
	}
	if errmsg.HTTPStatus != 200 {
		return "", fmt.Errorf("error creating VIP '%s': %s", obj.Name, errmsg.Status)
	}

	return
}

// Update a VIP
func (c *WebClient) UpdateVIP(obj *VIP) (err error) {
	var errmsg Result
	var results VIPResults
	_, err = c.napping.Put(c.URL+"/api/v2/firewall/vip/"+obj.Name, obj, &results, &errmsg)
	if err != nil {
		return fmt.Errorf("error updating VIP '%s': %s", obj.Name, err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return fmt.Errorf("error updating VIP '%s': not found", obj.Name)
		} else {
			return fmt.Errorf("error updating VIP '%s': %s", obj.Name, errmsg.Status)
		}
	}

	return
}

// Delete a VIP by name
func (c *WebClient) DeleteVIP(mkey string) (err error) {
	var errmsg Result
	var results VIPResults
	_, err = c.napping.Delete(c.URL+"/api/v2/firewall/vip/"+mkey, nil, &results, &errmsg)
	if err != nil {
		return fmt.Errorf("error deleting VIP '%s': %s", mkey, err.Error())
	}
	if results.HTTPStatus == 200 {
		return
	}
	if errmsg.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return fmt.Errorf("error deleting VIP '%s': not found", mkey)
		}
		return fmt.Errorf("error deleting VIP '%s': %s", mkey, errmsg.Status)
	}

	return
}

// List all VIPs
func (c *FakeClient) ListVIPs() (res []*VIP, err error) {
	for _, r := range c.VIPs {
		res = append(res, r)
	}
	return
}

// Get a VIP by name
func (c *FakeClient) GetVIP(mkey string) (*VIP, error) {
	if res, ok := c.VIPs[mkey]; ok {
		return res, nil
	} else {
		return &VIP{}, fmt.Errorf("error getting VIP '%s': not found", mkey)
	}
}

// Create a new VIP
func (c *FakeClient) CreateVIP(obj *VIP) (id string, err error) {
	id = obj.Name
	c.VIPs[id] = obj
	return
}

// Update a VIP
func (c *FakeClient) UpdateVIP(obj *VIP) (err error) {
	c.VIPs[obj.Name] = obj
	return nil
}

// Delete a VIP by name
func (c *FakeClient) DeleteVIP(mkey string) (err error) {
	delete(c.VIPs, mkey)
	return nil
}

// Enable ARP reply.
type FirewallVip46ArpReply string

// Load balance method.
type FirewallVip46LdbMethod string

// Health monitors.
type FirewallVip46Monitor struct {

	// Health monitor name.
	Name string `json:"name,omitempty"`
}

// Enable port forwarding.
type FirewallVip46Portforward string

// Mapped port protocol.
type FirewallVip46Protocol string

// Real servers.
type FirewallVip46Realservers struct {

	// Restrict server to a client IP in this range.
	ClientIp string `json:"client-ip,omitempty"`

	// Per server health check.
	Healthcheck string `json:"healthcheck,omitempty"`

	// Hold down interval.
	HolddownInterval int `json:"holddown-interval,omitempty"`

	// Real server ID.
	Id int `json:"id,omitempty"`

	// Mapped server IPv6.
	Ip string `json:"ip,omitempty"`

	// Maximum number of connections allowed to server.
	MaxConnections int `json:"max-connections,omitempty"`

	// Health monitors.
	Monitor string `json:"monitor,omitempty"`

	// Mapped server port.
	Port int `json:"port,omitempty"`

	// Server administrative status.
	Status string `json:"status,omitempty"`

	// weight
	Weight int `json:"weight,omitempty"`
}

// Server type.
type FirewallVip46ServerType string

// Source IP filter (x.x.x.x/x).
type FirewallVip46SrcFilter struct {

	// Src-filter range.
	Range string `json:"range,omitempty"`
}

// VIP type: static NAT or server load balance.
type FirewallVip46Type string

const (
	// Disable ARP reply.
	FirewallVip46ArpReplyDisable FirewallVip46ArpReply = "disable"

	// Enable ARP reply.
	FirewallVip46ArpReplyEnable FirewallVip46ArpReply = "enable"
)

const (
	// Distribute sessions based on source IP.
	FirewallVip46LdbMethodStatic FirewallVip46LdbMethod = "static"

	// Distribute sessions based round robin order.
	FirewallVip46LdbMethodRoundRobin FirewallVip46LdbMethod = "round-robin"

	// Distribute sessions based on weight.
	FirewallVip46LdbMethodWeighted FirewallVip46LdbMethod = "weighted"

	// Distribute sessions to the server with the lowest session count.
	FirewallVip46LdbMethodLeastSession FirewallVip46LdbMethod = "least-session"

	// Distribute sessions to the server with the lowest Round-Trip-Time.
	FirewallVip46LdbMethodLeastRtt FirewallVip46LdbMethod = "least-rtt"

	// Distribute sessions to the first server that is alive.
	FirewallVip46LdbMethodFirstAlive FirewallVip46LdbMethod = "first-alive"
)

const (
	// Disable port forwarding.
	FirewallVip46PortforwardDisable FirewallVip46Portforward = "disable"

	// Enable port forwarding.
	FirewallVip46PortforwardEnable FirewallVip46Portforward = "enable"
)

const (
	// TCP.
	FirewallVip46ProtocolTcp FirewallVip46Protocol = "tcp"

	// UDP.
	FirewallVip46ProtocolUdp FirewallVip46Protocol = "udp"
)

const (
	// HTTP
	FirewallVip46ServerTypeHttp FirewallVip46ServerType = "http"

	// TCP
	FirewallVip46ServerTypeTcp FirewallVip46ServerType = "tcp"

	// UDP
	FirewallVip46ServerTypeUdp FirewallVip46ServerType = "udp"

	// IP
	FirewallVip46ServerTypeIp FirewallVip46ServerType = "ip"
)

const (
	// Static NAT.
	FirewallVip46TypeStaticNat FirewallVip46Type = "static-nat"

	// Server load balance.
	FirewallVip46TypeServerLoadBalance FirewallVip46Type = "server-load-balance"
)

// Configure IPv4 to IPv6 virtual IPs.
type FirewallVip46 struct {

	// Enable ARP reply.
	ArpReply FirewallVip46ArpReply `json:"arp-reply,omitempty"`

	// Color of icon on the GUI.
	Color int `json:"color,omitempty"`

	// Comment.
	Comment string `json:"comment,omitempty"`

	// Start-external-IP [-end-external-IP].
	Extip string `json:"extip,omitempty"`

	// External service port.
	Extport string `json:"extport,omitempty"`

	// Custom defined id.
	Id int `json:"id,omitempty"`

	// Load balance method.
	LdbMethod FirewallVip46LdbMethod `json:"ldb-method,omitempty"`

	// Start-mapped-IP [-end mapped-IP].
	Mappedip string `json:"mappedip,omitempty"`

	// Mapped service port.
	Mappedport string `json:"mappedport,omitempty"`

	// Health monitors.
	Monitor []FirewallVip46Monitor `json:"monitor,omitempty"`

	// VIP46 name.
	Name string `json:"name,omitempty"`

	// Enable port forwarding.
	Portforward FirewallVip46Portforward `json:"portforward,omitempty"`

	// Mapped port protocol.
	Protocol FirewallVip46Protocol `json:"protocol,omitempty"`

	// Real servers.
	Realservers []FirewallVip46Realservers `json:"realservers,omitempty"`

	// Server type.
	ServerType FirewallVip46ServerType `json:"server-type,omitempty"`

	// Source IP filter (x.x.x.x/x).
	SrcFilter []FirewallVip46SrcFilter `json:"src-filter,omitempty"`

	// VIP type: static NAT or server load balance.
	Type FirewallVip46Type `json:"type,omitempty"`

	// Universally Unique Identifier (UUID; automatically assigned but can be manually reset).
	Uuid string `json:"uuid,omitempty"`
}

// Returns the value that identifies a FirewallVip46
func (x *FirewallVip46) MKey() string {
	return x.Name
}

// The results of a Get or List operation
type FirewallVip46Results struct {
	Results []*FirewallVip46 `json:"results"`
	Mkey    string           `json:"mkey"`
	Result
}

// List all FirewallVip46s
func (c *WebClient) ListFirewallVip46s() (res []*FirewallVip46, err error) {
	var errmsg Result
	var results FirewallVip46Results
	_, err = c.napping.Get(c.URL+"/api/v2/firewall/vip46", nil, &results, nil)
	if err != nil {
		return []*FirewallVip46{}, fmt.Errorf("error listing FirewallVip46s: %s", err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return []*FirewallVip46{}, fmt.Errorf("error listing FirewallVip46: not found")
		} else {
			return []*FirewallVip46{}, fmt.Errorf("error listing FirewallVip46: %s", errmsg.Status)
		}
	}
	res = results.Results
	return
}

// Get a FirewallVip46 by name
func (c *WebClient) GetFirewallVip46(mkey string) (res *FirewallVip46, err error) {
	var errmsg Result
	var results FirewallVip46Results
	_, err = c.napping.Get(c.URL+"/api/v2/firewall/vip46/"+mkey, nil, &results, &errmsg)
	if err != nil {
		return &FirewallVip46{}, fmt.Errorf("error getting FirewallVip46 '%s': %s", mkey, err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return &FirewallVip46{}, fmt.Errorf("error getting FirewallVip46 '%s': not found", mkey)
		} else {
			return &FirewallVip46{}, fmt.Errorf("error getting FirewallVip46 '%s': %s", mkey, errmsg.Status)
		}
	}
	if len(results.Results) == 0 {
		return &FirewallVip46{}, fmt.Errorf("error getting FirewallVip46 '%s': not found", mkey)
	}

	res = results.Results[0]
	return
}

// Create a new FirewallVip46
func (c *WebClient) CreateFirewallVip46(obj *FirewallVip46) (id string, err error) {
	var errmsg Result
	var results FirewallVip46Results
	_, err = c.napping.Post(c.URL+"/api/v2/firewall/vip46", obj, &results, &errmsg)
	if err != nil {
		return "", fmt.Errorf("error creating FirewallVip46 '%s': %s", obj.Name, err.Error())
	}
	if results.HTTPStatus == 200 {
		return
	}
	if errmsg.HTTPStatus != 200 {
		return "", fmt.Errorf("error creating FirewallVip46 '%s': %s", obj.Name, errmsg.Status)
	}

	return
}

// Update a FirewallVip46
func (c *WebClient) UpdateFirewallVip46(obj *FirewallVip46) (err error) {
	var errmsg Result
	var results FirewallVip46Results
	_, err = c.napping.Put(c.URL+"/api/v2/firewall/vip46/"+obj.Name, obj, &results, &errmsg)
	if err != nil {
		return fmt.Errorf("error updating FirewallVip46 '%s': %s", obj.Name, err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return fmt.Errorf("error updating FirewallVip46 '%s': not found", obj.Name)
		} else {
			return fmt.Errorf("error updating FirewallVip46 '%s': %s", obj.Name, errmsg.Status)
		}
	}

	return
}

// Delete a FirewallVip46 by name
func (c *WebClient) DeleteFirewallVip46(mkey string) (err error) {
	var errmsg Result
	var results FirewallVip46Results
	_, err = c.napping.Delete(c.URL+"/api/v2/firewall/vip46/"+mkey, nil, &results, &errmsg)
	if err != nil {
		return fmt.Errorf("error deleting FirewallVip46 '%s': %s", mkey, err.Error())
	}
	if results.HTTPStatus == 200 {
		return
	}
	if errmsg.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return fmt.Errorf("error deleting FirewallVip46 '%s': not found", mkey)
		}
		return fmt.Errorf("error deleting FirewallVip46 '%s': %s", mkey, errmsg.Status)
	}

	return
}

// List all FirewallVip46s
func (c *FakeClient) ListFirewallVip46s() (res []*FirewallVip46, err error) {
	for _, r := range c.FirewallVip46s {
		res = append(res, r)
	}
	return
}

// Get a FirewallVip46 by name
func (c *FakeClient) GetFirewallVip46(mkey string) (*FirewallVip46, error) {
	if res, ok := c.FirewallVip46s[mkey]; ok {
		return res, nil
	} else {
		return &FirewallVip46{}, fmt.Errorf("error getting FirewallVip46 '%s': not found", mkey)
	}
}

// Create a new FirewallVip46
func (c *FakeClient) CreateFirewallVip46(obj *FirewallVip46) (id string, err error) {
	id = obj.Name
	c.FirewallVip46s[id] = obj
	return
}

// Update a FirewallVip46
func (c *FakeClient) UpdateFirewallVip46(obj *FirewallVip46) (err error) {
	c.FirewallVip46s[obj.Name] = obj
	return nil
}

// Delete a FirewallVip46 by name
func (c *FakeClient) DeleteFirewallVip46(mkey string) (err error) {
	delete(c.FirewallVip46s, mkey)
	return nil
}

// Enable to respond to ARP requests for this virtual IP address. Enabled by default.
type FirewallVip6ArpReply string

// Enable/disable use of HTTP cookie domain from host field in HTTP.
type FirewallVip6HttpCookieDomainFromHost string

// Control sharing of cookies across virtual servers. same-ip means a cookie from one virtual server can be used by another. Disable stops cookie sharing.
type FirewallVip6HttpCookieShare string

// For HTTP multiplexing, enable to add the original client IP address in the XForwarded-For HTTP header.
type FirewallVip6HttpIpHeader string

// Enable/disable HTTP multiplexing.
type FirewallVip6HttpMultiplex string

// Method used to distribute sessions to real servers.
type FirewallVip6LdbMethod string

// Name of the health check monitor to use when polling to determine a virtual server's connectivity status.
type FirewallVip6Monitor struct {

	// Health monitor name.
	Name string `json:"name,omitempty"`
}

// Enable to add the Front-End-Https header for Microsoft Outlook Web Access.
type FirewallVip6OutlookWebAccess string

// Configure how to make sure that clients connect to the same server every time they make a request that is part of the same session.
type FirewallVip6Persistence string

// Enable port forwarding.
type FirewallVip6Portforward string

// Protocol to use when forwarding packets.
type FirewallVip6Protocol string

// Select the real servers that this server load balancing VIP will distribute traffic to.
type FirewallVip6Realservers struct {

	// Only clients in this IP range can connect to this real server.
	ClientIp string `json:"client-ip,omitempty"`

	// Enable to check the responsiveness of the real server before forwarding traffic.
	Healthcheck string `json:"healthcheck,omitempty"`

	// Time in seconds that the health check monitor continues to monitor an unresponsive server that should be active.
	HolddownInterval int `json:"holddown-interval,omitempty"`

	// HTTP server domain name in HTTP header.
	HttpHost string `json:"http-host,omitempty"`

	// Real server ID.
	Id int `json:"id,omitempty"`

	// IPv6 address of the real server.
	Ip string `json:"ip,omitempty"`

	// Max number of active connections that can directed to the real server. When reached, sessions are sent to other real servers.
	MaxConnections int `json:"max-connections,omitempty"`

	// Name of the health check monitor to use when polling to determine a virtual server's connectivity status.
	Monitor string `json:"monitor,omitempty"`

	// Port for communicating with the real server. Required if port forwarding is enabled.
	Port int `json:"port,omitempty"`

	// Set the status of the real server to active so that it can accept traffic, or on standby or disabled so no traffic is sent.
	Status string `json:"status,omitempty"`

	// Weight of the real server. If weighted load balancing is enabled, the server with the highest weight gets more connections.
	Weight int `json:"weight,omitempty"`
}

// Protocol to be load balanced by the virtual server (also called the server load balance virtual IP).
type FirewallVip6ServerType string

// Source IP6 filter (x:x:x:x:x:x:x:x/x). Separate addresses with spaces.
type FirewallVip6SrcFilter struct {

	// Source-filter range.
	Range string `json:"range,omitempty"`
}

// Configure a static NAT or server load balance VIP.
type FirewallVip6Type string

// Enable to add an HTTP header to indicate SSL offloading for a WebLogic server.
type FirewallVip6WeblogicServer string

// Enable to add an HTTP header to indicate SSL offloading for a WebSphere server.
type FirewallVip6WebsphereServer string

const (
	// Disable ARP reply.
	FirewallVip6ArpReplyDisable FirewallVip6ArpReply = "disable"

	// Enable ARP reply.
	FirewallVip6ArpReplyEnable FirewallVip6ArpReply = "enable"
)

const (
	// Disable use of HTTP cookie domain from host field in HTTP (use http-cooke-domain setting).
	FirewallVip6HttpCookieDomainFromHostDisable FirewallVip6HttpCookieDomainFromHost = "disable"

	// Enable use of HTTP cookie domain from host field in HTTP.
	FirewallVip6HttpCookieDomainFromHostEnable FirewallVip6HttpCookieDomainFromHost = "enable"
)

const (
	// Only allow HTTP cookie to match this virtual server.
	FirewallVip6HttpCookieShareDisable FirewallVip6HttpCookieShare = "disable"

	// Allow HTTP cookie to match any virtual server with same IP.
	FirewallVip6HttpCookieShareSameIp FirewallVip6HttpCookieShare = "same-ip"
)

const (
	// Enable adding HTTP header.
	FirewallVip6HttpIpHeaderEnable FirewallVip6HttpIpHeader = "enable"

	// Disable adding HTTP header.
	FirewallVip6HttpIpHeaderDisable FirewallVip6HttpIpHeader = "disable"
)

const (
	// Enable HTTP session multiplexing.
	FirewallVip6HttpMultiplexEnable FirewallVip6HttpMultiplex = "enable"

	// Disable HTTP session multiplexing.
	FirewallVip6HttpMultiplexDisable FirewallVip6HttpMultiplex = "disable"
)

const (
	// Distribute sessions based on source IP.
	FirewallVip6LdbMethodStatic FirewallVip6LdbMethod = "static"

	// Distribute sessions based round robin order.
	FirewallVip6LdbMethodRoundRobin FirewallVip6LdbMethod = "round-robin"

	// Distribute sessions based on weight.
	FirewallVip6LdbMethodWeighted FirewallVip6LdbMethod = "weighted"

	// Sends new sessions to the server with the lowest session count.
	FirewallVip6LdbMethodLeastSession FirewallVip6LdbMethod = "least-session"

	// Distribute new sessions to the server with lowest Round-Trip-Time.
	FirewallVip6LdbMethodLeastRtt FirewallVip6LdbMethod = "least-rtt"

	// Distribute sessions to the first server that is alive.
	FirewallVip6LdbMethodFirstAlive FirewallVip6LdbMethod = "first-alive"

	// Distribute sessions to servers based on host field in HTTP header.
	FirewallVip6LdbMethodHttpHost FirewallVip6LdbMethod = "http-host"
)

const (
	// Disable Outlook Web Access support.
	FirewallVip6OutlookWebAccessDisable FirewallVip6OutlookWebAccess = "disable"

	// Enable Outlook Web Access support.
	FirewallVip6OutlookWebAccessEnable FirewallVip6OutlookWebAccess = "enable"
)

const (
	// None.
	FirewallVip6PersistenceNone FirewallVip6Persistence = "none"

	// HTTP cookie.
	FirewallVip6PersistenceHttpCookie FirewallVip6Persistence = "http-cookie"
)

const (
	// Disable port forward.
	FirewallVip6PortforwardDisable FirewallVip6Portforward = "disable"

	// Enable/disable port forwarding.
	FirewallVip6PortforwardEnable FirewallVip6Portforward = "enable"
)

const (
	// TCP.
	FirewallVip6ProtocolTcp FirewallVip6Protocol = "tcp"

	// UDP.
	FirewallVip6ProtocolUdp FirewallVip6Protocol = "udp"

	// SCTP.
	FirewallVip6ProtocolSctp FirewallVip6Protocol = "sctp"
)

const (
	// HTTP
	FirewallVip6ServerTypeHttp FirewallVip6ServerType = "http"

	// TCP
	FirewallVip6ServerTypeTcp FirewallVip6ServerType = "tcp"

	// UDP
	FirewallVip6ServerTypeUdp FirewallVip6ServerType = "udp"

	// IP
	FirewallVip6ServerTypeIp FirewallVip6ServerType = "ip"
)

const (
	// Static NAT.
	FirewallVip6TypeStaticNat FirewallVip6Type = "static-nat"

	// Server load balance.
	FirewallVip6TypeServerLoadBalance FirewallVip6Type = "server-load-balance"
)

const (
	// Do not add HTTP header indicating SSL offload for WebLogic server.
	FirewallVip6WeblogicServerDisable FirewallVip6WeblogicServer = "disable"

	// Add HTTP header indicating SSL offload for WebLogic server.
	FirewallVip6WeblogicServerEnable FirewallVip6WeblogicServer = "enable"
)

const (
	// Do not add HTTP header indicating SSL offload for WebSphere server.
	FirewallVip6WebsphereServerDisable FirewallVip6WebsphereServer = "disable"

	// Add HTTP header indicating SSL offload for WebSphere server.
	FirewallVip6WebsphereServerEnable FirewallVip6WebsphereServer = "enable"
)

// Configure virtual IP for IPv6.
type FirewallVip6 struct {

	// Enable to respond to ARP requests for this virtual IP address. Enabled by default.
	ArpReply FirewallVip6ArpReply `json:"arp-reply,omitempty"`

	// Color of icon on the GUI.
	Color int `json:"color,omitempty"`

	// Comment.
	Comment string `json:"comment,omitempty"`

	// IP address or address range on the external interface that you want to map to an address or address range on the destination network.
	Extip string `json:"extip,omitempty"`

	// Incoming port number range that you want to map to a port number range on the destination network.
	Extport string `json:"extport,omitempty"`

	// Time in minutes that client web browsers should keep a cookie. Default is 60 seconds. 0 = no time limit.
	HttpCookieAge int `json:"http-cookie-age,omitempty"`

	// Domain that HTTP cookie persistence should apply to.
	HttpCookieDomain string `json:"http-cookie-domain,omitempty"`

	// Enable/disable use of HTTP cookie domain from host field in HTTP.
	HttpCookieDomainFromHost FirewallVip6HttpCookieDomainFromHost `json:"http-cookie-domain-from-host,omitempty"`

	// Generation of HTTP cookie to be accepted. Changing invalidates all existing cookies.
	HttpCookieGeneration int `json:"http-cookie-generation,omitempty"`

	// Limit HTTP cookie persistence to the specified path.
	HttpCookiePath string `json:"http-cookie-path,omitempty"`

	// Control sharing of cookies across virtual servers. same-ip means a cookie from one virtual server can be used by another. Disable stops cookie sharing.
	HttpCookieShare FirewallVip6HttpCookieShare `json:"http-cookie-share,omitempty"`

	// For HTTP multiplexing, enable to add the original client IP address in the XForwarded-For HTTP header.
	HttpIpHeader FirewallVip6HttpIpHeader `json:"http-ip-header,omitempty"`

	// For HTTP multiplexing, enter a custom HTTPS header name. The original client IP address is added to this header. If empty, X-Forwarded-For is used.
	HttpIpHeaderName string `json:"http-ip-header-name,omitempty"`

	// Enable/disable HTTP multiplexing.
	HttpMultiplex FirewallVip6HttpMultiplex `json:"http-multiplex,omitempty"`

	// Custom defined ID.
	Id int `json:"id,omitempty"`

	// Method used to distribute sessions to real servers.
	LdbMethod FirewallVip6LdbMethod `json:"ldb-method,omitempty"`

	// Mapped IP address range in the format startIP-endIP.
	Mappedip string `json:"mappedip,omitempty"`

	// Port number range on the destination network to which the external port number range is mapped.
	Mappedport string `json:"mappedport,omitempty"`

	// Maximum number of incomplete connections.
	MaxEmbryonicConnections int `json:"max-embryonic-connections,omitempty"`

	// Name of the health check monitor to use when polling to determine a virtual server's connectivity status.
	Monitor []FirewallVip6Monitor `json:"monitor,omitempty"`

	// Virtual ip6 name.
	Name string `json:"name,omitempty"`

	// Enable to add the Front-End-Https header for Microsoft Outlook Web Access.
	OutlookWebAccess FirewallVip6OutlookWebAccess `json:"outlook-web-access,omitempty"`

	// Configure how to make sure that clients connect to the same server every time they make a request that is part of the same session.
	Persistence FirewallVip6Persistence `json:"persistence,omitempty"`

	// Enable port forwarding.
	Portforward FirewallVip6Portforward `json:"portforward,omitempty"`

	// Protocol to use when forwarding packets.
	Protocol FirewallVip6Protocol `json:"protocol,omitempty"`

	// Select the real servers that this server load balancing VIP will distribute traffic to.
	Realservers []FirewallVip6Realservers `json:"realservers,omitempty"`

	// Protocol to be load balanced by the virtual server (also called the server load balance virtual IP).
	ServerType FirewallVip6ServerType `json:"server-type,omitempty"`

	// Source IP6 filter (x:x:x:x:x:x:x:x/x). Separate addresses with spaces.
	SrcFilter []FirewallVip6SrcFilter `json:"src-filter,omitempty"`

	// Configure a static NAT or server load balance VIP.
	Type FirewallVip6Type `json:"type,omitempty"`

	// Universally Unique Identifier (UUID; automatically assigned but can be manually reset).
	Uuid string `json:"uuid,omitempty"`

	// Enable to add an HTTP header to indicate SSL offloading for a WebLogic server.
	WeblogicServer FirewallVip6WeblogicServer `json:"weblogic-server,omitempty"`

	// Enable to add an HTTP header to indicate SSL offloading for a WebSphere server.
	WebsphereServer FirewallVip6WebsphereServer `json:"websphere-server,omitempty"`
}

// Returns the value that identifies a FirewallVip6
func (x *FirewallVip6) MKey() string {
	return x.Name
}

// The results of a Get or List operation
type FirewallVip6Results struct {
	Results []*FirewallVip6 `json:"results"`
	Mkey    string          `json:"mkey"`
	Result
}

// List all FirewallVip6s
func (c *WebClient) ListFirewallVip6s() (res []*FirewallVip6, err error) {
	var errmsg Result
	var results FirewallVip6Results
	_, err = c.napping.Get(c.URL+"/api/v2/firewall/vip6", nil, &results, nil)
	if err != nil {
		return []*FirewallVip6{}, fmt.Errorf("error listing FirewallVip6s: %s", err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return []*FirewallVip6{}, fmt.Errorf("error listing FirewallVip6: not found")
		} else {
			return []*FirewallVip6{}, fmt.Errorf("error listing FirewallVip6: %s", errmsg.Status)
		}
	}
	res = results.Results
	return
}

// Get a FirewallVip6 by name
func (c *WebClient) GetFirewallVip6(mkey string) (res *FirewallVip6, err error) {
	var errmsg Result
	var results FirewallVip6Results
	_, err = c.napping.Get(c.URL+"/api/v2/firewall/vip6/"+mkey, nil, &results, &errmsg)
	if err != nil {
		return &FirewallVip6{}, fmt.Errorf("error getting FirewallVip6 '%s': %s", mkey, err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return &FirewallVip6{}, fmt.Errorf("error getting FirewallVip6 '%s': not found", mkey)
		} else {
			return &FirewallVip6{}, fmt.Errorf("error getting FirewallVip6 '%s': %s", mkey, errmsg.Status)
		}
	}
	if len(results.Results) == 0 {
		return &FirewallVip6{}, fmt.Errorf("error getting FirewallVip6 '%s': not found", mkey)
	}

	res = results.Results[0]
	return
}

// Create a new FirewallVip6
func (c *WebClient) CreateFirewallVip6(obj *FirewallVip6) (id string, err error) {
	var errmsg Result
	var results FirewallVip6Results
	_, err = c.napping.Post(c.URL+"/api/v2/firewall/vip6", obj, &results, &errmsg)
	if err != nil {
		return "", fmt.Errorf("error creating FirewallVip6 '%s': %s", obj.Name, err.Error())
	}
	if results.HTTPStatus == 200 {
		return
	}
	if errmsg.HTTPStatus != 200 {
		return "", fmt.Errorf("error creating FirewallVip6 '%s': %s", obj.Name, errmsg.Status)
	}

	return
}

// Update a FirewallVip6
func (c *WebClient) UpdateFirewallVip6(obj *FirewallVip6) (err error) {
	var errmsg Result
	var results FirewallVip6Results
	_, err = c.napping.Put(c.URL+"/api/v2/firewall/vip6/"+obj.Name, obj, &results, &errmsg)
	if err != nil {
		return fmt.Errorf("error updating FirewallVip6 '%s': %s", obj.Name, err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return fmt.Errorf("error updating FirewallVip6 '%s': not found", obj.Name)
		} else {
			return fmt.Errorf("error updating FirewallVip6 '%s': %s", obj.Name, errmsg.Status)
		}
	}

	return
}

// Delete a FirewallVip6 by name
func (c *WebClient) DeleteFirewallVip6(mkey string) (err error) {
	var errmsg Result
	var results FirewallVip6Results
	_, err = c.napping.Delete(c.URL+"/api/v2/firewall/vip6/"+mkey, nil, &results, &errmsg)
	if err != nil {
		return fmt.Errorf("error deleting FirewallVip6 '%s': %s", mkey, err.Error())
	}
	if results.HTTPStatus == 200 {
		return
	}
	if errmsg.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return fmt.Errorf("error deleting FirewallVip6 '%s': not found", mkey)
		}
		return fmt.Errorf("error deleting FirewallVip6 '%s': %s", mkey, errmsg.Status)
	}

	return
}

// List all FirewallVip6s
func (c *FakeClient) ListFirewallVip6s() (res []*FirewallVip6, err error) {
	for _, r := range c.FirewallVip6s {
		res = append(res, r)
	}
	return
}

// Get a FirewallVip6 by name
func (c *FakeClient) GetFirewallVip6(mkey string) (*FirewallVip6, error) {
	if res, ok := c.FirewallVip6s[mkey]; ok {
		return res, nil
	} else {
		return &FirewallVip6{}, fmt.Errorf("error getting FirewallVip6 '%s': not found", mkey)
	}
}

// Create a new FirewallVip6
func (c *FakeClient) CreateFirewallVip6(obj *FirewallVip6) (id string, err error) {
	id = obj.Name
	c.FirewallVip6s[id] = obj
	return
}

// Update a FirewallVip6
func (c *FakeClient) UpdateFirewallVip6(obj *FirewallVip6) (err error) {
	c.FirewallVip6s[obj.Name] = obj
	return nil
}

// Delete a FirewallVip6 by name
func (c *FakeClient) DeleteFirewallVip6(mkey string) (err error) {
	delete(c.FirewallVip6s, mkey)
	return nil
}

// Enable ARP reply.
type FirewallVip64ArpReply string

// Load balance method.
type FirewallVip64LdbMethod string

// Health monitors.
type FirewallVip64Monitor struct {

	// Health monitor name.
	Name string `json:"name,omitempty"`
}

// Enable port forwarding.
type FirewallVip64Portforward string

// Mapped port protocol.
type FirewallVip64Protocol string

// Real servers.
type FirewallVip64Realservers struct {

	// Restrict server to a client IP in this range.
	ClientIp string `json:"client-ip,omitempty"`

	// Per server health check.
	Healthcheck string `json:"healthcheck,omitempty"`

	// Hold down interval.
	HolddownInterval int `json:"holddown-interval,omitempty"`

	// Real server ID.
	Id int `json:"id,omitempty"`

	// Mapped server IP.
	Ip string `json:"ip,omitempty"`

	// Maximum number of connections allowed to server.
	MaxConnections int `json:"max-connections,omitempty"`

	// Health monitors.
	Monitor string `json:"monitor,omitempty"`

	// Mapped server port.
	Port int `json:"port,omitempty"`

	// Server administrative status.
	Status string `json:"status,omitempty"`

	// weight
	Weight int `json:"weight,omitempty"`
}

// Server type.
type FirewallVip64ServerType string

// Source IP6 filter (x:x:x:x:x:x:x:x/x).
type FirewallVip64SrcFilter struct {

	// Src-filter range.
	Range string `json:"range,omitempty"`
}

// VIP type: static NAT or server load balance.
type FirewallVip64Type string

const (
	// Disable arp reply.
	FirewallVip64ArpReplyDisable FirewallVip64ArpReply = "disable"

	// Enable arp reply.
	FirewallVip64ArpReplyEnable FirewallVip64ArpReply = "enable"
)

const (
	// Distribute sessions based on source IP.
	FirewallVip64LdbMethodStatic FirewallVip64LdbMethod = "static"

	// Distribute sessions based round robin order.
	FirewallVip64LdbMethodRoundRobin FirewallVip64LdbMethod = "round-robin"

	// Distribute sessions based on weight.
	FirewallVip64LdbMethodWeighted FirewallVip64LdbMethod = "weighted"

	// Distribute sessions to the server with the lowest session count.
	FirewallVip64LdbMethodLeastSession FirewallVip64LdbMethod = "least-session"

	// Distribute sessions to the server with the lowest Round-Trip-Time.
	FirewallVip64LdbMethodLeastRtt FirewallVip64LdbMethod = "least-rtt"

	// Distribute sessions to the first server that is alive.
	FirewallVip64LdbMethodFirstAlive FirewallVip64LdbMethod = "first-alive"
)

const (
	// Disable port forwarding.
	FirewallVip64PortforwardDisable FirewallVip64Portforward = "disable"

	// Enable port forwarding.
	FirewallVip64PortforwardEnable FirewallVip64Portforward = "enable"
)

const (
	// TCP.
	FirewallVip64ProtocolTcp FirewallVip64Protocol = "tcp"

	// UDP.
	FirewallVip64ProtocolUdp FirewallVip64Protocol = "udp"
)

const (
	// HTTP
	FirewallVip64ServerTypeHttp FirewallVip64ServerType = "http"

	// TCP
	FirewallVip64ServerTypeTcp FirewallVip64ServerType = "tcp"

	// UDP
	FirewallVip64ServerTypeUdp FirewallVip64ServerType = "udp"

	// IP
	FirewallVip64ServerTypeIp FirewallVip64ServerType = "ip"
)

const (
	// Static NAT.
	FirewallVip64TypeStaticNat FirewallVip64Type = "static-nat"

	// Server load balance.
	FirewallVip64TypeServerLoadBalance FirewallVip64Type = "server-load-balance"
)

// Configure IPv6 to IPv4 virtual IPs.
type FirewallVip64 struct {

	// Enable ARP reply.
	ArpReply FirewallVip64ArpReply `json:"arp-reply,omitempty"`

	// Color of icon on the GUI.
	Color int `json:"color,omitempty"`

	// Comment.
	Comment string `json:"comment,omitempty"`

	// Start-external-IP [-end-external-IP].
	Extip string `json:"extip,omitempty"`

	// External service port.
	Extport string `json:"extport,omitempty"`

	// Custom defined id.
	Id int `json:"id,omitempty"`

	// Load balance method.
	LdbMethod FirewallVip64LdbMethod `json:"ldb-method,omitempty"`

	// Start-mapped-IP [-end-mapped-IP].
	Mappedip string `json:"mappedip,omitempty"`

	// Mapped service port.
	Mappedport string `json:"mappedport,omitempty"`

	// Health monitors.
	Monitor []FirewallVip64Monitor `json:"monitor,omitempty"`

	// VIP64 name.
	Name string `json:"name,omitempty"`

	// Enable port forwarding.
	Portforward FirewallVip64Portforward `json:"portforward,omitempty"`

	// Mapped port protocol.
	Protocol FirewallVip64Protocol `json:"protocol,omitempty"`

	// Real servers.
	Realservers []FirewallVip64Realservers `json:"realservers,omitempty"`

	// Server type.
	ServerType FirewallVip64ServerType `json:"server-type,omitempty"`

	// Source IP6 filter (x:x:x:x:x:x:x:x/x).
	SrcFilter []FirewallVip64SrcFilter `json:"src-filter,omitempty"`

	// VIP type: static NAT or server load balance.
	Type FirewallVip64Type `json:"type,omitempty"`

	// Universally Unique Identifier (UUID; automatically assigned but can be manually reset).
	Uuid string `json:"uuid,omitempty"`
}

// Returns the value that identifies a FirewallVip64
func (x *FirewallVip64) MKey() string {
	return x.Name
}

// The results of a Get or List operation
type FirewallVip64Results struct {
	Results []*FirewallVip64 `json:"results"`
	Mkey    string           `json:"mkey"`
	Result
}

// List all FirewallVip64s
func (c *WebClient) ListFirewallVip64s() (res []*FirewallVip64, err error) {
	var errmsg Result
	var results FirewallVip64Results
	_, err = c.napping.Get(c.URL+"/api/v2/firewall/vip64", nil, &results, nil)
	if err != nil {
		return []*FirewallVip64{}, fmt.Errorf("error listing FirewallVip64s: %s", err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return []*FirewallVip64{}, fmt.Errorf("error listing FirewallVip64: not found")
		} else {
			return []*FirewallVip64{}, fmt.Errorf("error listing FirewallVip64: %s", errmsg.Status)
		}
	}
	res = results.Results
	return
}

// Get a FirewallVip64 by name
func (c *WebClient) GetFirewallVip64(mkey string) (res *FirewallVip64, err error) {
	var errmsg Result
	var results FirewallVip64Results
	_, err = c.napping.Get(c.URL+"/api/v2/firewall/vip64/"+mkey, nil, &results, &errmsg)
	if err != nil {
		return &FirewallVip64{}, fmt.Errorf("error getting FirewallVip64 '%s': %s", mkey, err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return &FirewallVip64{}, fmt.Errorf("error getting FirewallVip64 '%s': not found", mkey)
		} else {
			return &FirewallVip64{}, fmt.Errorf("error getting FirewallVip64 '%s': %s", mkey, errmsg.Status)
		}
	}
	if len(results.Results) == 0 {
		return &FirewallVip64{}, fmt.Errorf("error getting FirewallVip64 '%s': not found", mkey)
	}

	res = results.Results[0]
	return
}

// Create a new FirewallVip64
func (c *WebClient) CreateFirewallVip64(obj *FirewallVip64) (id string, err error) {
	var errmsg Result
	var results FirewallVip64Results
	_, err = c.napping.Post(c.URL+"/api/v2/firewall/vip64", obj, &results, &errmsg)
	if err != nil {
		return "", fmt.Errorf("error creating FirewallVip64 '%s': %s", obj.Name, err.Error())
	}
	if results.HTTPStatus == 200 {
		return
	}
	if errmsg.HTTPStatus != 200 {
		return "", fmt.Errorf("error creating FirewallVip64 '%s': %s", obj.Name, errmsg.Status)
	}

	return
}

// Update a FirewallVip64
func (c *WebClient) UpdateFirewallVip64(obj *FirewallVip64) (err error) {
	var errmsg Result
	var results FirewallVip64Results
	_, err = c.napping.Put(c.URL+"/api/v2/firewall/vip64/"+obj.Name, obj, &results, &errmsg)
	if err != nil {
		return fmt.Errorf("error updating FirewallVip64 '%s': %s", obj.Name, err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return fmt.Errorf("error updating FirewallVip64 '%s': not found", obj.Name)
		} else {
			return fmt.Errorf("error updating FirewallVip64 '%s': %s", obj.Name, errmsg.Status)
		}
	}

	return
}

// Delete a FirewallVip64 by name
func (c *WebClient) DeleteFirewallVip64(mkey string) (err error) {
	var errmsg Result
	var results FirewallVip64Results
	_, err = c.napping.Delete(c.URL+"/api/v2/firewall/vip64/"+mkey, nil, &results, &errmsg)
	if err != nil {
		return fmt.Errorf("error deleting FirewallVip64 '%s': %s", mkey, err.Error())
	}
	if results.HTTPStatus == 200 {
		return
	}
	if errmsg.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return fmt.Errorf("error deleting FirewallVip64 '%s': not found", mkey)
		}
		return fmt.Errorf("error deleting FirewallVip64 '%s': %s", mkey, errmsg.Status)
	}

	return
}

// List all FirewallVip64s
func (c *FakeClient) ListFirewallVip64s() (res []*FirewallVip64, err error) {
	for _, r := range c.FirewallVip64s {
		res = append(res, r)
	}
	return
}

// Get a FirewallVip64 by name
func (c *FakeClient) GetFirewallVip64(mkey string) (*FirewallVip64, error) {
	if res, ok := c.FirewallVip64s[mkey]; ok {
		return res, nil
	} else {
		return &FirewallVip64{}, fmt.Errorf("error getting FirewallVip64 '%s': not found", mkey)
	}
}

// Create a new FirewallVip64
func (c *FakeClient) CreateFirewallVip64(obj *FirewallVip64) (id string, err error) {
	id = obj.Name
	c.FirewallVip64s[id] = obj
	return
}

// Update a FirewallVip64
func (c *FakeClient) UpdateFirewallVip64(obj *FirewallVip64) (err error) {
	c.FirewallVip64s[obj.Name] = obj
	return nil
}

// Delete a FirewallVip64 by name
func (c *FakeClient) DeleteFirewallVip64(mkey string) (err error) {
	delete(c.FirewallVip64s, mkey)
	return nil
}

// Member VIP objects of the group (Separate multiple objects with a space).
type FirewallVipgrpMember struct {

	// VIP name.
	Name string `json:"name,omitempty"`
}

// Configure IPv4 virtual IP groups.
type FirewallVipgrp struct {

	// Integer value to determine the color of the icon in the GUI (range 1 to 32, default = 0, which sets the value to 1).
	Color int `json:"color,omitempty"`

	// Comment.
	Comments string `json:"comments,omitempty"`

	// interface
	Interface string `json:"interface,omitempty"`

	// Member VIP objects of the group (Separate multiple objects with a space).
	Member []FirewallVipgrpMember `json:"member,omitempty"`

	// VIP group name.
	Name string `json:"name,omitempty"`

	// Universally Unique Identifier (UUID; automatically assigned but can be manually reset).
	Uuid string `json:"uuid,omitempty"`
}

// Returns the value that identifies a FirewallVipgrp
func (x *FirewallVipgrp) MKey() string {
	return x.Name
}

// The results of a Get or List operation
type FirewallVipgrpResults struct {
	Results []*FirewallVipgrp `json:"results"`
	Mkey    string            `json:"mkey"`
	Result
}

// List all FirewallVipgrps
func (c *WebClient) ListFirewallVipgrps() (res []*FirewallVipgrp, err error) {
	var errmsg Result
	var results FirewallVipgrpResults
	_, err = c.napping.Get(c.URL+"/api/v2/firewall/vipgrp", nil, &results, nil)
	if err != nil {
		return []*FirewallVipgrp{}, fmt.Errorf("error listing FirewallVipgrps: %s", err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return []*FirewallVipgrp{}, fmt.Errorf("error listing FirewallVipgrp: not found")
		} else {
			return []*FirewallVipgrp{}, fmt.Errorf("error listing FirewallVipgrp: %s", errmsg.Status)
		}
	}
	res = results.Results
	return
}

// Get a FirewallVipgrp by name
func (c *WebClient) GetFirewallVipgrp(mkey string) (res *FirewallVipgrp, err error) {
	var errmsg Result
	var results FirewallVipgrpResults
	_, err = c.napping.Get(c.URL+"/api/v2/firewall/vipgrp/"+mkey, nil, &results, &errmsg)
	if err != nil {
		return &FirewallVipgrp{}, fmt.Errorf("error getting FirewallVipgrp '%s': %s", mkey, err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return &FirewallVipgrp{}, fmt.Errorf("error getting FirewallVipgrp '%s': not found", mkey)
		} else {
			return &FirewallVipgrp{}, fmt.Errorf("error getting FirewallVipgrp '%s': %s", mkey, errmsg.Status)
		}
	}
	if len(results.Results) == 0 {
		return &FirewallVipgrp{}, fmt.Errorf("error getting FirewallVipgrp '%s': not found", mkey)
	}

	res = results.Results[0]
	return
}

// Create a new FirewallVipgrp
func (c *WebClient) CreateFirewallVipgrp(obj *FirewallVipgrp) (id string, err error) {
	var errmsg Result
	var results FirewallVipgrpResults
	_, err = c.napping.Post(c.URL+"/api/v2/firewall/vipgrp", obj, &results, &errmsg)
	if err != nil {
		return "", fmt.Errorf("error creating FirewallVipgrp '%s': %s", obj.Name, err.Error())
	}
	if results.HTTPStatus == 200 {
		return
	}
	if errmsg.HTTPStatus != 200 {
		return "", fmt.Errorf("error creating FirewallVipgrp '%s': %s", obj.Name, errmsg.Status)
	}

	return
}

// Update a FirewallVipgrp
func (c *WebClient) UpdateFirewallVipgrp(obj *FirewallVipgrp) (err error) {
	var errmsg Result
	var results FirewallVipgrpResults
	_, err = c.napping.Put(c.URL+"/api/v2/firewall/vipgrp/"+obj.Name, obj, &results, &errmsg)
	if err != nil {
		return fmt.Errorf("error updating FirewallVipgrp '%s': %s", obj.Name, err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return fmt.Errorf("error updating FirewallVipgrp '%s': not found", obj.Name)
		} else {
			return fmt.Errorf("error updating FirewallVipgrp '%s': %s", obj.Name, errmsg.Status)
		}
	}

	return
}

// Delete a FirewallVipgrp by name
func (c *WebClient) DeleteFirewallVipgrp(mkey string) (err error) {
	var errmsg Result
	var results FirewallVipgrpResults
	_, err = c.napping.Delete(c.URL+"/api/v2/firewall/vipgrp/"+mkey, nil, &results, &errmsg)
	if err != nil {
		return fmt.Errorf("error deleting FirewallVipgrp '%s': %s", mkey, err.Error())
	}
	if results.HTTPStatus == 200 {
		return
	}
	if errmsg.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return fmt.Errorf("error deleting FirewallVipgrp '%s': not found", mkey)
		}
		return fmt.Errorf("error deleting FirewallVipgrp '%s': %s", mkey, errmsg.Status)
	}

	return
}

// List all FirewallVipgrps
func (c *FakeClient) ListFirewallVipgrps() (res []*FirewallVipgrp, err error) {
	for _, r := range c.FirewallVipgrps {
		res = append(res, r)
	}
	return
}

// Get a FirewallVipgrp by name
func (c *FakeClient) GetFirewallVipgrp(mkey string) (*FirewallVipgrp, error) {
	if res, ok := c.FirewallVipgrps[mkey]; ok {
		return res, nil
	} else {
		return &FirewallVipgrp{}, fmt.Errorf("error getting FirewallVipgrp '%s': not found", mkey)
	}
}

// Create a new FirewallVipgrp
func (c *FakeClient) CreateFirewallVipgrp(obj *FirewallVipgrp) (id string, err error) {
	id = obj.Name
	c.FirewallVipgrps[id] = obj
	return
}

// Update a FirewallVipgrp
func (c *FakeClient) UpdateFirewallVipgrp(obj *FirewallVipgrp) (err error) {
	c.FirewallVipgrps[obj.Name] = obj
	return nil
}

// Delete a FirewallVipgrp by name
func (c *FakeClient) DeleteFirewallVipgrp(mkey string) (err error) {
	delete(c.FirewallVipgrps, mkey)
	return nil
}

// Member VIP objects of the group (Separate multiple objects with a space).
type FirewallVipgrp46Member struct {

	// VIP46 name.
	Name string `json:"name,omitempty"`
}

// Configure IPv4 to IPv6 virtual IP groups.
type FirewallVipgrp46 struct {

	// Integer value to determine the color of the icon in the GUI (range 1 to 32, default = 0, which sets the value to 1).
	Color int `json:"color,omitempty"`

	// Comment.
	Comments string `json:"comments,omitempty"`

	// Member VIP objects of the group (Separate multiple objects with a space).
	Member []FirewallVipgrp46Member `json:"member,omitempty"`

	// VIP46 group name.
	Name string `json:"name,omitempty"`

	// Universally Unique Identifier (UUID; automatically assigned but can be manually reset).
	Uuid string `json:"uuid,omitempty"`
}

// Returns the value that identifies a FirewallVipgrp46
func (x *FirewallVipgrp46) MKey() string {
	return x.Name
}

// The results of a Get or List operation
type FirewallVipgrp46Results struct {
	Results []*FirewallVipgrp46 `json:"results"`
	Mkey    string              `json:"mkey"`
	Result
}

// List all FirewallVipgrp46s
func (c *WebClient) ListFirewallVipgrp46s() (res []*FirewallVipgrp46, err error) {
	var errmsg Result
	var results FirewallVipgrp46Results
	_, err = c.napping.Get(c.URL+"/api/v2/firewall/vipgrp46", nil, &results, nil)
	if err != nil {
		return []*FirewallVipgrp46{}, fmt.Errorf("error listing FirewallVipgrp46s: %s", err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return []*FirewallVipgrp46{}, fmt.Errorf("error listing FirewallVipgrp46: not found")
		} else {
			return []*FirewallVipgrp46{}, fmt.Errorf("error listing FirewallVipgrp46: %s", errmsg.Status)
		}
	}
	res = results.Results
	return
}

// Get a FirewallVipgrp46 by name
func (c *WebClient) GetFirewallVipgrp46(mkey string) (res *FirewallVipgrp46, err error) {
	var errmsg Result
	var results FirewallVipgrp46Results
	_, err = c.napping.Get(c.URL+"/api/v2/firewall/vipgrp46/"+mkey, nil, &results, &errmsg)
	if err != nil {
		return &FirewallVipgrp46{}, fmt.Errorf("error getting FirewallVipgrp46 '%s': %s", mkey, err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return &FirewallVipgrp46{}, fmt.Errorf("error getting FirewallVipgrp46 '%s': not found", mkey)
		} else {
			return &FirewallVipgrp46{}, fmt.Errorf("error getting FirewallVipgrp46 '%s': %s", mkey, errmsg.Status)
		}
	}
	if len(results.Results) == 0 {
		return &FirewallVipgrp46{}, fmt.Errorf("error getting FirewallVipgrp46 '%s': not found", mkey)
	}

	res = results.Results[0]
	return
}

// Create a new FirewallVipgrp46
func (c *WebClient) CreateFirewallVipgrp46(obj *FirewallVipgrp46) (id string, err error) {
	var errmsg Result
	var results FirewallVipgrp46Results
	_, err = c.napping.Post(c.URL+"/api/v2/firewall/vipgrp46", obj, &results, &errmsg)
	if err != nil {
		return "", fmt.Errorf("error creating FirewallVipgrp46 '%s': %s", obj.Name, err.Error())
	}
	if results.HTTPStatus == 200 {
		return
	}
	if errmsg.HTTPStatus != 200 {
		return "", fmt.Errorf("error creating FirewallVipgrp46 '%s': %s", obj.Name, errmsg.Status)
	}

	return
}

// Update a FirewallVipgrp46
func (c *WebClient) UpdateFirewallVipgrp46(obj *FirewallVipgrp46) (err error) {
	var errmsg Result
	var results FirewallVipgrp46Results
	_, err = c.napping.Put(c.URL+"/api/v2/firewall/vipgrp46/"+obj.Name, obj, &results, &errmsg)
	if err != nil {
		return fmt.Errorf("error updating FirewallVipgrp46 '%s': %s", obj.Name, err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return fmt.Errorf("error updating FirewallVipgrp46 '%s': not found", obj.Name)
		} else {
			return fmt.Errorf("error updating FirewallVipgrp46 '%s': %s", obj.Name, errmsg.Status)
		}
	}

	return
}

// Delete a FirewallVipgrp46 by name
func (c *WebClient) DeleteFirewallVipgrp46(mkey string) (err error) {
	var errmsg Result
	var results FirewallVipgrp46Results
	_, err = c.napping.Delete(c.URL+"/api/v2/firewall/vipgrp46/"+mkey, nil, &results, &errmsg)
	if err != nil {
		return fmt.Errorf("error deleting FirewallVipgrp46 '%s': %s", mkey, err.Error())
	}
	if results.HTTPStatus == 200 {
		return
	}
	if errmsg.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return fmt.Errorf("error deleting FirewallVipgrp46 '%s': not found", mkey)
		}
		return fmt.Errorf("error deleting FirewallVipgrp46 '%s': %s", mkey, errmsg.Status)
	}

	return
}

// List all FirewallVipgrp46s
func (c *FakeClient) ListFirewallVipgrp46s() (res []*FirewallVipgrp46, err error) {
	for _, r := range c.FirewallVipgrp46s {
		res = append(res, r)
	}
	return
}

// Get a FirewallVipgrp46 by name
func (c *FakeClient) GetFirewallVipgrp46(mkey string) (*FirewallVipgrp46, error) {
	if res, ok := c.FirewallVipgrp46s[mkey]; ok {
		return res, nil
	} else {
		return &FirewallVipgrp46{}, fmt.Errorf("error getting FirewallVipgrp46 '%s': not found", mkey)
	}
}

// Create a new FirewallVipgrp46
func (c *FakeClient) CreateFirewallVipgrp46(obj *FirewallVipgrp46) (id string, err error) {
	id = obj.Name
	c.FirewallVipgrp46s[id] = obj
	return
}

// Update a FirewallVipgrp46
func (c *FakeClient) UpdateFirewallVipgrp46(obj *FirewallVipgrp46) (err error) {
	c.FirewallVipgrp46s[obj.Name] = obj
	return nil
}

// Delete a FirewallVipgrp46 by name
func (c *FakeClient) DeleteFirewallVipgrp46(mkey string) (err error) {
	delete(c.FirewallVipgrp46s, mkey)
	return nil
}

// Member VIP objects of the group (Separate multiple objects with a space).
type FirewallVipgrp6Member struct {

	// IPv6 VIP name.
	Name string `json:"name,omitempty"`
}

// Configure IPv6 virtual IP groups.
type FirewallVipgrp6 struct {

	// Integer value to determine the color of the icon in the GUI (range 1 to 32, default = 0, which sets the value to 1).
	Color int `json:"color,omitempty"`

	// Comment.
	Comments string `json:"comments,omitempty"`

	// Member VIP objects of the group (Separate multiple objects with a space).
	Member []FirewallVipgrp6Member `json:"member,omitempty"`

	// IPv6 VIP group name.
	Name string `json:"name,omitempty"`

	// Universally Unique Identifier (UUID; automatically assigned but can be manually reset).
	Uuid string `json:"uuid,omitempty"`
}

// Returns the value that identifies a FirewallVipgrp6
func (x *FirewallVipgrp6) MKey() string {
	return x.Name
}

// The results of a Get or List operation
type FirewallVipgrp6Results struct {
	Results []*FirewallVipgrp6 `json:"results"`
	Mkey    string             `json:"mkey"`
	Result
}

// List all FirewallVipgrp6s
func (c *WebClient) ListFirewallVipgrp6s() (res []*FirewallVipgrp6, err error) {
	var errmsg Result
	var results FirewallVipgrp6Results
	_, err = c.napping.Get(c.URL+"/api/v2/firewall/vipgrp6", nil, &results, nil)
	if err != nil {
		return []*FirewallVipgrp6{}, fmt.Errorf("error listing FirewallVipgrp6s: %s", err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return []*FirewallVipgrp6{}, fmt.Errorf("error listing FirewallVipgrp6: not found")
		} else {
			return []*FirewallVipgrp6{}, fmt.Errorf("error listing FirewallVipgrp6: %s", errmsg.Status)
		}
	}
	res = results.Results
	return
}

// Get a FirewallVipgrp6 by name
func (c *WebClient) GetFirewallVipgrp6(mkey string) (res *FirewallVipgrp6, err error) {
	var errmsg Result
	var results FirewallVipgrp6Results
	_, err = c.napping.Get(c.URL+"/api/v2/firewall/vipgrp6/"+mkey, nil, &results, &errmsg)
	if err != nil {
		return &FirewallVipgrp6{}, fmt.Errorf("error getting FirewallVipgrp6 '%s': %s", mkey, err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return &FirewallVipgrp6{}, fmt.Errorf("error getting FirewallVipgrp6 '%s': not found", mkey)
		} else {
			return &FirewallVipgrp6{}, fmt.Errorf("error getting FirewallVipgrp6 '%s': %s", mkey, errmsg.Status)
		}
	}
	if len(results.Results) == 0 {
		return &FirewallVipgrp6{}, fmt.Errorf("error getting FirewallVipgrp6 '%s': not found", mkey)
	}

	res = results.Results[0]
	return
}

// Create a new FirewallVipgrp6
func (c *WebClient) CreateFirewallVipgrp6(obj *FirewallVipgrp6) (id string, err error) {
	var errmsg Result
	var results FirewallVipgrp6Results
	_, err = c.napping.Post(c.URL+"/api/v2/firewall/vipgrp6", obj, &results, &errmsg)
	if err != nil {
		return "", fmt.Errorf("error creating FirewallVipgrp6 '%s': %s", obj.Name, err.Error())
	}
	if results.HTTPStatus == 200 {
		return
	}
	if errmsg.HTTPStatus != 200 {
		return "", fmt.Errorf("error creating FirewallVipgrp6 '%s': %s", obj.Name, errmsg.Status)
	}

	return
}

// Update a FirewallVipgrp6
func (c *WebClient) UpdateFirewallVipgrp6(obj *FirewallVipgrp6) (err error) {
	var errmsg Result
	var results FirewallVipgrp6Results
	_, err = c.napping.Put(c.URL+"/api/v2/firewall/vipgrp6/"+obj.Name, obj, &results, &errmsg)
	if err != nil {
		return fmt.Errorf("error updating FirewallVipgrp6 '%s': %s", obj.Name, err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return fmt.Errorf("error updating FirewallVipgrp6 '%s': not found", obj.Name)
		} else {
			return fmt.Errorf("error updating FirewallVipgrp6 '%s': %s", obj.Name, errmsg.Status)
		}
	}

	return
}

// Delete a FirewallVipgrp6 by name
func (c *WebClient) DeleteFirewallVipgrp6(mkey string) (err error) {
	var errmsg Result
	var results FirewallVipgrp6Results
	_, err = c.napping.Delete(c.URL+"/api/v2/firewall/vipgrp6/"+mkey, nil, &results, &errmsg)
	if err != nil {
		return fmt.Errorf("error deleting FirewallVipgrp6 '%s': %s", mkey, err.Error())
	}
	if results.HTTPStatus == 200 {
		return
	}
	if errmsg.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return fmt.Errorf("error deleting FirewallVipgrp6 '%s': not found", mkey)
		}
		return fmt.Errorf("error deleting FirewallVipgrp6 '%s': %s", mkey, errmsg.Status)
	}

	return
}

// List all FirewallVipgrp6s
func (c *FakeClient) ListFirewallVipgrp6s() (res []*FirewallVipgrp6, err error) {
	for _, r := range c.FirewallVipgrp6s {
		res = append(res, r)
	}
	return
}

// Get a FirewallVipgrp6 by name
func (c *FakeClient) GetFirewallVipgrp6(mkey string) (*FirewallVipgrp6, error) {
	if res, ok := c.FirewallVipgrp6s[mkey]; ok {
		return res, nil
	} else {
		return &FirewallVipgrp6{}, fmt.Errorf("error getting FirewallVipgrp6 '%s': not found", mkey)
	}
}

// Create a new FirewallVipgrp6
func (c *FakeClient) CreateFirewallVipgrp6(obj *FirewallVipgrp6) (id string, err error) {
	id = obj.Name
	c.FirewallVipgrp6s[id] = obj
	return
}

// Update a FirewallVipgrp6
func (c *FakeClient) UpdateFirewallVipgrp6(obj *FirewallVipgrp6) (err error) {
	c.FirewallVipgrp6s[obj.Name] = obj
	return nil
}

// Delete a FirewallVipgrp6 by name
func (c *FakeClient) DeleteFirewallVipgrp6(mkey string) (err error) {
	delete(c.FirewallVipgrp6s, mkey)
	return nil
}

// Member VIP objects of the group (Separate multiple objects with a space).
type FirewallVipgrp64Member struct {

	// VIP64 name.
	Name string `json:"name,omitempty"`
}

// Configure IPv6 to IPv4 virtual IP groups.
type FirewallVipgrp64 struct {

	// Integer value to determine the color of the icon in the GUI (range 1 to 32, default = 0, which sets the value to 1).
	Color int `json:"color,omitempty"`

	// Comment.
	Comments string `json:"comments,omitempty"`

	// Member VIP objects of the group (Separate multiple objects with a space).
	Member []FirewallVipgrp64Member `json:"member,omitempty"`

	// VIP64 group name.
	Name string `json:"name,omitempty"`

	// Universally Unique Identifier (UUID; automatically assigned but can be manually reset).
	Uuid string `json:"uuid,omitempty"`
}

// Returns the value that identifies a FirewallVipgrp64
func (x *FirewallVipgrp64) MKey() string {
	return x.Name
}

// The results of a Get or List operation
type FirewallVipgrp64Results struct {
	Results []*FirewallVipgrp64 `json:"results"`
	Mkey    string              `json:"mkey"`
	Result
}

// List all FirewallVipgrp64s
func (c *WebClient) ListFirewallVipgrp64s() (res []*FirewallVipgrp64, err error) {
	var errmsg Result
	var results FirewallVipgrp64Results
	_, err = c.napping.Get(c.URL+"/api/v2/firewall/vipgrp64", nil, &results, nil)
	if err != nil {
		return []*FirewallVipgrp64{}, fmt.Errorf("error listing FirewallVipgrp64s: %s", err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return []*FirewallVipgrp64{}, fmt.Errorf("error listing FirewallVipgrp64: not found")
		} else {
			return []*FirewallVipgrp64{}, fmt.Errorf("error listing FirewallVipgrp64: %s", errmsg.Status)
		}
	}
	res = results.Results
	return
}

// Get a FirewallVipgrp64 by name
func (c *WebClient) GetFirewallVipgrp64(mkey string) (res *FirewallVipgrp64, err error) {
	var errmsg Result
	var results FirewallVipgrp64Results
	_, err = c.napping.Get(c.URL+"/api/v2/firewall/vipgrp64/"+mkey, nil, &results, &errmsg)
	if err != nil {
		return &FirewallVipgrp64{}, fmt.Errorf("error getting FirewallVipgrp64 '%s': %s", mkey, err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return &FirewallVipgrp64{}, fmt.Errorf("error getting FirewallVipgrp64 '%s': not found", mkey)
		} else {
			return &FirewallVipgrp64{}, fmt.Errorf("error getting FirewallVipgrp64 '%s': %s", mkey, errmsg.Status)
		}
	}
	if len(results.Results) == 0 {
		return &FirewallVipgrp64{}, fmt.Errorf("error getting FirewallVipgrp64 '%s': not found", mkey)
	}

	res = results.Results[0]
	return
}

// Create a new FirewallVipgrp64
func (c *WebClient) CreateFirewallVipgrp64(obj *FirewallVipgrp64) (id string, err error) {
	var errmsg Result
	var results FirewallVipgrp64Results
	_, err = c.napping.Post(c.URL+"/api/v2/firewall/vipgrp64", obj, &results, &errmsg)
	if err != nil {
		return "", fmt.Errorf("error creating FirewallVipgrp64 '%s': %s", obj.Name, err.Error())
	}
	if results.HTTPStatus == 200 {
		return
	}
	if errmsg.HTTPStatus != 200 {
		return "", fmt.Errorf("error creating FirewallVipgrp64 '%s': %s", obj.Name, errmsg.Status)
	}

	return
}

// Update a FirewallVipgrp64
func (c *WebClient) UpdateFirewallVipgrp64(obj *FirewallVipgrp64) (err error) {
	var errmsg Result
	var results FirewallVipgrp64Results
	_, err = c.napping.Put(c.URL+"/api/v2/firewall/vipgrp64/"+obj.Name, obj, &results, &errmsg)
	if err != nil {
		return fmt.Errorf("error updating FirewallVipgrp64 '%s': %s", obj.Name, err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return fmt.Errorf("error updating FirewallVipgrp64 '%s': not found", obj.Name)
		} else {
			return fmt.Errorf("error updating FirewallVipgrp64 '%s': %s", obj.Name, errmsg.Status)
		}
	}

	return
}

// Delete a FirewallVipgrp64 by name
func (c *WebClient) DeleteFirewallVipgrp64(mkey string) (err error) {
	var errmsg Result
	var results FirewallVipgrp64Results
	_, err = c.napping.Delete(c.URL+"/api/v2/firewall/vipgrp64/"+mkey, nil, &results, &errmsg)
	if err != nil {
		return fmt.Errorf("error deleting FirewallVipgrp64 '%s': %s", mkey, err.Error())
	}
	if results.HTTPStatus == 200 {
		return
	}
	if errmsg.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return fmt.Errorf("error deleting FirewallVipgrp64 '%s': not found", mkey)
		}
		return fmt.Errorf("error deleting FirewallVipgrp64 '%s': %s", mkey, errmsg.Status)
	}

	return
}

// List all FirewallVipgrp64s
func (c *FakeClient) ListFirewallVipgrp64s() (res []*FirewallVipgrp64, err error) {
	for _, r := range c.FirewallVipgrp64s {
		res = append(res, r)
	}
	return
}

// Get a FirewallVipgrp64 by name
func (c *FakeClient) GetFirewallVipgrp64(mkey string) (*FirewallVipgrp64, error) {
	if res, ok := c.FirewallVipgrp64s[mkey]; ok {
		return res, nil
	} else {
		return &FirewallVipgrp64{}, fmt.Errorf("error getting FirewallVipgrp64 '%s': not found", mkey)
	}
}

// Create a new FirewallVipgrp64
func (c *FakeClient) CreateFirewallVipgrp64(obj *FirewallVipgrp64) (id string, err error) {
	id = obj.Name
	c.FirewallVipgrp64s[id] = obj
	return
}

// Update a FirewallVipgrp64
func (c *FakeClient) UpdateFirewallVipgrp64(obj *FirewallVipgrp64) (err error) {
	c.FirewallVipgrp64s[obj.Name] = obj
	return nil
}

// Delete a FirewallVipgrp64 by name
func (c *FakeClient) DeleteFirewallVipgrp64(mkey string) (err error) {
	delete(c.FirewallVipgrp64s, mkey)
	return nil
}

// Enable/disable logging for antivirus oversize file blocking.
type FirewallProfileProtocolOptionsOversizeLog string

// Enable/disable inspection of RPC over HTTP.
type FirewallProfileProtocolOptionsRpcOverHttp string

// Enable/disable logging for HTTP/HTTPS switching protocols.
type FirewallProfileProtocolOptionsSwitchingProtocolsLog string

const (
	// Disable logging for antivirus oversize file blocking.
	FirewallProfileProtocolOptionsOversizeLogDisable FirewallProfileProtocolOptionsOversizeLog = "disable"

	// Enable logging for antivirus oversize file blocking.
	FirewallProfileProtocolOptionsOversizeLogEnable FirewallProfileProtocolOptionsOversizeLog = "enable"
)

const (
	// Enable inspection of RPC over HTTP.
	FirewallProfileProtocolOptionsRpcOverHttpEnable FirewallProfileProtocolOptionsRpcOverHttp = "enable"

	// Disable inspection of RPC over HTTP.
	FirewallProfileProtocolOptionsRpcOverHttpDisable FirewallProfileProtocolOptionsRpcOverHttp = "disable"
)

const (
	// Disable logging for HTTP/HTTPS switching protocols.
	FirewallProfileProtocolOptionsSwitchingProtocolsLogDisable FirewallProfileProtocolOptionsSwitchingProtocolsLog = "disable"

	// Enable logging for HTTP/HTTPS switching protocols.
	FirewallProfileProtocolOptionsSwitchingProtocolsLogEnable FirewallProfileProtocolOptionsSwitchingProtocolsLog = "enable"
)

// Configure protocol options.
type FirewallProfileProtocolOptions struct {

	// Optional comments.
	Comment string `json:"comment,omitempty"`

	// Configure DNS protocol options.
	Dns string `json:"dns,omitempty"`

	// Configure FTP protocol options.
	Ftp string `json:"ftp,omitempty"`

	// Configure HTTP protocol options.
	Http string `json:"http,omitempty"`

	// Configure IMAP protocol options.
	Imap string `json:"imap,omitempty"`

	// Configure Mail signature.
	MailSignature string `json:"mail-signature,omitempty"`

	// Configure MAPI protocol options.
	Mapi string `json:"mapi,omitempty"`

	// Name.
	Name string `json:"name,omitempty"`

	// Configure NNTP protocol options.
	Nntp string `json:"nntp,omitempty"`

	// Enable/disable logging for antivirus oversize file blocking.
	OversizeLog FirewallProfileProtocolOptionsOversizeLog `json:"oversize-log,omitempty"`

	// Configure POP3 protocol options.
	Pop3 string `json:"pop3,omitempty"`

	// Name of the replacement message group to be used
	ReplacemsgGroup string `json:"replacemsg-group,omitempty"`

	// Enable/disable inspection of RPC over HTTP.
	RpcOverHttp FirewallProfileProtocolOptionsRpcOverHttp `json:"rpc-over-http,omitempty"`

	// Configure SMTP protocol options.
	Smtp string `json:"smtp,omitempty"`

	// Enable/disable logging for HTTP/HTTPS switching protocols.
	SwitchingProtocolsLog FirewallProfileProtocolOptionsSwitchingProtocolsLog `json:"switching-protocols-log,omitempty"`
}

// Returns the value that identifies a FirewallProfileProtocolOptions
func (x *FirewallProfileProtocolOptions) MKey() string {
	return x.Name
}

// The results of a Get or List operation
type FirewallProfileProtocolOptionsResults struct {
	Results []*FirewallProfileProtocolOptions `json:"results"`
	Mkey    string                            `json:"mkey"`
	Result
}

// List all FirewallProfileProtocolOptionss
func (c *WebClient) ListFirewallProfileProtocolOptionss() (res []*FirewallProfileProtocolOptions, err error) {
	var errmsg Result
	var results FirewallProfileProtocolOptionsResults
	_, err = c.napping.Get(c.URL+"/api/v2/firewall/profile-protocol-options", nil, &results, nil)
	if err != nil {
		return []*FirewallProfileProtocolOptions{}, fmt.Errorf("error listing FirewallProfileProtocolOptionss: %s", err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return []*FirewallProfileProtocolOptions{}, fmt.Errorf("error listing FirewallProfileProtocolOptions: not found")
		} else {
			return []*FirewallProfileProtocolOptions{}, fmt.Errorf("error listing FirewallProfileProtocolOptions: %s", errmsg.Status)
		}
	}
	res = results.Results
	return
}

// Get a FirewallProfileProtocolOptions by name
func (c *WebClient) GetFirewallProfileProtocolOptions(mkey string) (res *FirewallProfileProtocolOptions, err error) {
	var errmsg Result
	var results FirewallProfileProtocolOptionsResults
	_, err = c.napping.Get(c.URL+"/api/v2/firewall/profile-protocol-options/"+mkey, nil, &results, &errmsg)
	if err != nil {
		return &FirewallProfileProtocolOptions{}, fmt.Errorf("error getting FirewallProfileProtocolOptions '%s': %s", mkey, err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return &FirewallProfileProtocolOptions{}, fmt.Errorf("error getting FirewallProfileProtocolOptions '%s': not found", mkey)
		} else {
			return &FirewallProfileProtocolOptions{}, fmt.Errorf("error getting FirewallProfileProtocolOptions '%s': %s", mkey, errmsg.Status)
		}
	}
	if len(results.Results) == 0 {
		return &FirewallProfileProtocolOptions{}, fmt.Errorf("error getting FirewallProfileProtocolOptions '%s': not found", mkey)
	}

	res = results.Results[0]
	return
}

// Create a new FirewallProfileProtocolOptions
func (c *WebClient) CreateFirewallProfileProtocolOptions(obj *FirewallProfileProtocolOptions) (id string, err error) {
	var errmsg Result
	var results FirewallProfileProtocolOptionsResults
	_, err = c.napping.Post(c.URL+"/api/v2/firewall/profile-protocol-options", obj, &results, &errmsg)
	if err != nil {
		return "", fmt.Errorf("error creating FirewallProfileProtocolOptions '%s': %s", obj.Name, err.Error())
	}
	if results.HTTPStatus == 200 {
		return
	}
	if errmsg.HTTPStatus != 200 {
		return "", fmt.Errorf("error creating FirewallProfileProtocolOptions '%s': %s", obj.Name, errmsg.Status)
	}

	return
}

// Update a FirewallProfileProtocolOptions
func (c *WebClient) UpdateFirewallProfileProtocolOptions(obj *FirewallProfileProtocolOptions) (err error) {
	var errmsg Result
	var results FirewallProfileProtocolOptionsResults
	_, err = c.napping.Put(c.URL+"/api/v2/firewall/profile-protocol-options/"+obj.Name, obj, &results, &errmsg)
	if err != nil {
		return fmt.Errorf("error updating FirewallProfileProtocolOptions '%s': %s", obj.Name, err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return fmt.Errorf("error updating FirewallProfileProtocolOptions '%s': not found", obj.Name)
		} else {
			return fmt.Errorf("error updating FirewallProfileProtocolOptions '%s': %s", obj.Name, errmsg.Status)
		}
	}

	return
}

// Delete a FirewallProfileProtocolOptions by name
func (c *WebClient) DeleteFirewallProfileProtocolOptions(mkey string) (err error) {
	var errmsg Result
	var results FirewallProfileProtocolOptionsResults
	_, err = c.napping.Delete(c.URL+"/api/v2/firewall/profile-protocol-options/"+mkey, nil, &results, &errmsg)
	if err != nil {
		return fmt.Errorf("error deleting FirewallProfileProtocolOptions '%s': %s", mkey, err.Error())
	}
	if results.HTTPStatus == 200 {
		return
	}
	if errmsg.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return fmt.Errorf("error deleting FirewallProfileProtocolOptions '%s': not found", mkey)
		}
		return fmt.Errorf("error deleting FirewallProfileProtocolOptions '%s': %s", mkey, errmsg.Status)
	}

	return
}

// List all FirewallProfileProtocolOptionss
func (c *FakeClient) ListFirewallProfileProtocolOptionss() (res []*FirewallProfileProtocolOptions, err error) {
	for _, r := range c.FirewallProfileProtocolOptionss {
		res = append(res, r)
	}
	return
}

// Get a FirewallProfileProtocolOptions by name
func (c *FakeClient) GetFirewallProfileProtocolOptions(mkey string) (*FirewallProfileProtocolOptions, error) {
	if res, ok := c.FirewallProfileProtocolOptionss[mkey]; ok {
		return res, nil
	} else {
		return &FirewallProfileProtocolOptions{}, fmt.Errorf("error getting FirewallProfileProtocolOptions '%s': not found", mkey)
	}
}

// Create a new FirewallProfileProtocolOptions
func (c *FakeClient) CreateFirewallProfileProtocolOptions(obj *FirewallProfileProtocolOptions) (id string, err error) {
	id = obj.Name
	c.FirewallProfileProtocolOptionss[id] = obj
	return
}

// Update a FirewallProfileProtocolOptions
func (c *FakeClient) UpdateFirewallProfileProtocolOptions(obj *FirewallProfileProtocolOptions) (err error) {
	c.FirewallProfileProtocolOptionss[obj.Name] = obj
	return nil
}

// Delete a FirewallProfileProtocolOptions by name
func (c *FakeClient) DeleteFirewallProfileProtocolOptions(mkey string) (err error) {
	delete(c.FirewallProfileProtocolOptionss, mkey)
	return nil
}

// Enable/disable inspection of MAPI over HTTPS.
type FirewallSslSshProfileMapiOverHttps string

// Enable/disable inspection of RPC over HTTPS.
type FirewallSslSshProfileRpcOverHttps string

// Re-sign or replace the server's certificate.
type FirewallSslSshProfileServerCertMode string

// Enable/disable logging SSL anomalies.
type FirewallSslSshProfileSslAnomaliesLog string

// Servers to exempt from SSL inspection.
type FirewallSslSshProfileSslExempt struct {

	// IPv4 address object.
	Address string `json:"address,omitempty"`

	// IPv6 address object.
	Address6 string `json:"address6,omitempty"`

	// FortiGuard category ID.
	FortiguardCategory int `json:"fortiguard-category,omitempty"`

	// ID number.
	Id int `json:"id,omitempty"`

	// Type of address object (IPv4 or IPv6) or FortiGuard category.
	Type string `json:"type,omitempty"`
}

// Enable/disable logging SSL exemptions.
type FirewallSslSshProfileSslExemptionsLog string

// SSL servers.
type FirewallSslSshProfileSslServer struct {

	// Action based on client certificate request failure during the FTPS handshake.
	FtpsClientCertRequest string `json:"ftps-client-cert-request,omitempty"`

	// Action based on client certificate request failure during the HTTPS handshake.
	HttpsClientCertRequest string `json:"https-client-cert-request,omitempty"`

	// SSL server ID.
	Id int `json:"id,omitempty"`

	// Action based on client certificate request failure during the IMAPS handshake.
	ImapsClientCertRequest string `json:"imaps-client-cert-request,omitempty"`

	// IPv4 address of the SSL server.
	Ip string `json:"ip,omitempty"`

	// Action based on client certificate request failure during the POP3S handshake.
	Pop3sClientCertRequest string `json:"pop3s-client-cert-request,omitempty"`

	// Action based on client certificate request failure during the SMTPS handshake.
	SmtpsClientCertRequest string `json:"smtps-client-cert-request,omitempty"`

	// Action based on client certificate request failure during an SSL protocol handshake.
	SslOtherClientCertRequest string `json:"ssl-other-client-cert-request,omitempty"`
}

// Enable/disable the use of SSL server table for SSL offloading.
type FirewallSslSshProfileUseSslServer string

// Enable/disable exempting servers by FortiGuard whitelist.
type FirewallSslSshProfileWhitelist string

const (
	// Enable inspection of MAPI over HTTPS.
	FirewallSslSshProfileMapiOverHttpsEnable FirewallSslSshProfileMapiOverHttps = "enable"

	// Disable inspection of MAPI over HTTPS.
	FirewallSslSshProfileMapiOverHttpsDisable FirewallSslSshProfileMapiOverHttps = "disable"
)

const (
	// Enable inspection of RPC over HTTPS.
	FirewallSslSshProfileRpcOverHttpsEnable FirewallSslSshProfileRpcOverHttps = "enable"

	// Disable inspection of RPC over HTTPS.
	FirewallSslSshProfileRpcOverHttpsDisable FirewallSslSshProfileRpcOverHttps = "disable"
)

const (
	// Multiple clients connecting to multiple servers.
	FirewallSslSshProfileServerCertModeReSign FirewallSslSshProfileServerCertMode = "re-sign"

	// Protect an SSL server.
	FirewallSslSshProfileServerCertModeReplace FirewallSslSshProfileServerCertMode = "replace"
)

const (
	// Disable logging SSL anomalies.
	FirewallSslSshProfileSslAnomaliesLogDisable FirewallSslSshProfileSslAnomaliesLog = "disable"

	// Enable logging SSL anomalies.
	FirewallSslSshProfileSslAnomaliesLogEnable FirewallSslSshProfileSslAnomaliesLog = "enable"
)

const (
	// Disable logging SSL exemptions.
	FirewallSslSshProfileSslExemptionsLogDisable FirewallSslSshProfileSslExemptionsLog = "disable"

	// Enable logging SSL exemptions.
	FirewallSslSshProfileSslExemptionsLogEnable FirewallSslSshProfileSslExemptionsLog = "enable"
)

const (
	// Don't use SSL server configuration.
	FirewallSslSshProfileUseSslServerDisable FirewallSslSshProfileUseSslServer = "disable"

	// Use SSL server configuration.
	FirewallSslSshProfileUseSslServerEnable FirewallSslSshProfileUseSslServer = "enable"
)

const (
	// Enable setting.
	FirewallSslSshProfileWhitelistEnable FirewallSslSshProfileWhitelist = "enable"

	// Disable setting.
	FirewallSslSshProfileWhitelistDisable FirewallSslSshProfileWhitelist = "disable"
)

// Configure SSL/SSH protocol options.
type FirewallSslSshProfile struct {

	// CA certificate used by SSL Inspection.
	Caname string `json:"caname,omitempty"`

	// Optional comments.
	Comment string `json:"comment,omitempty"`

	// Configure FTPS options.
	Ftps string `json:"ftps,omitempty"`

	// Configure HTTPS options.
	Https string `json:"https,omitempty"`

	// Configure IMAPS options.
	Imaps string `json:"imaps,omitempty"`

	// Enable/disable inspection of MAPI over HTTPS.
	MapiOverHttps FirewallSslSshProfileMapiOverHttps `json:"mapi-over-https,omitempty"`

	// Name.
	Name string `json:"name,omitempty"`

	// Configure POP3S options.
	Pop3s string `json:"pop3s,omitempty"`

	// Enable/disable inspection of RPC over HTTPS.
	RpcOverHttps FirewallSslSshProfileRpcOverHttps `json:"rpc-over-https,omitempty"`

	// Certificate used by SSL Inspection to replace server certificate.
	ServerCert string `json:"server-cert,omitempty"`

	// Re-sign or replace the server's certificate.
	ServerCertMode FirewallSslSshProfileServerCertMode `json:"server-cert-mode,omitempty"`

	// Configure SMTPS options.
	Smtps string `json:"smtps,omitempty"`

	// Configure SSL options.
	Ssl string `json:"ssl,omitempty"`

	// Enable/disable logging SSL anomalies.
	SslAnomaliesLog FirewallSslSshProfileSslAnomaliesLog `json:"ssl-anomalies-log,omitempty"`

	// Servers to exempt from SSL inspection.
	SslExempt []FirewallSslSshProfileSslExempt `json:"ssl-exempt,omitempty"`

	// Enable/disable logging SSL exemptions.
	SslExemptionsLog FirewallSslSshProfileSslExemptionsLog `json:"ssl-exemptions-log,omitempty"`

	// SSL servers.
	SslServer []FirewallSslSshProfileSslServer `json:"ssl-server,omitempty"`

	// Untrusted CA certificate used by SSL Inspection.
	UntrustedCaname string `json:"untrusted-caname,omitempty"`

	// Enable/disable the use of SSL server table for SSL offloading.
	UseSslServer FirewallSslSshProfileUseSslServer `json:"use-ssl-server,omitempty"`

	// Enable/disable exempting servers by FortiGuard whitelist.
	Whitelist FirewallSslSshProfileWhitelist `json:"whitelist,omitempty"`
}

// Returns the value that identifies a FirewallSslSshProfile
func (x *FirewallSslSshProfile) MKey() string {
	return x.Name
}

// The results of a Get or List operation
type FirewallSslSshProfileResults struct {
	Results []*FirewallSslSshProfile `json:"results"`
	Mkey    string                   `json:"mkey"`
	Result
}

// List all FirewallSslSshProfiles
func (c *WebClient) ListFirewallSslSshProfiles() (res []*FirewallSslSshProfile, err error) {
	var errmsg Result
	var results FirewallSslSshProfileResults
	_, err = c.napping.Get(c.URL+"/api/v2/firewall/ssl-ssh-profile", nil, &results, nil)
	if err != nil {
		return []*FirewallSslSshProfile{}, fmt.Errorf("error listing FirewallSslSshProfiles: %s", err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return []*FirewallSslSshProfile{}, fmt.Errorf("error listing FirewallSslSshProfile: not found")
		} else {
			return []*FirewallSslSshProfile{}, fmt.Errorf("error listing FirewallSslSshProfile: %s", errmsg.Status)
		}
	}
	res = results.Results
	return
}

// Get a FirewallSslSshProfile by name
func (c *WebClient) GetFirewallSslSshProfile(mkey string) (res *FirewallSslSshProfile, err error) {
	var errmsg Result
	var results FirewallSslSshProfileResults
	_, err = c.napping.Get(c.URL+"/api/v2/firewall/ssl-ssh-profile/"+mkey, nil, &results, &errmsg)
	if err != nil {
		return &FirewallSslSshProfile{}, fmt.Errorf("error getting FirewallSslSshProfile '%s': %s", mkey, err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return &FirewallSslSshProfile{}, fmt.Errorf("error getting FirewallSslSshProfile '%s': not found", mkey)
		} else {
			return &FirewallSslSshProfile{}, fmt.Errorf("error getting FirewallSslSshProfile '%s': %s", mkey, errmsg.Status)
		}
	}
	if len(results.Results) == 0 {
		return &FirewallSslSshProfile{}, fmt.Errorf("error getting FirewallSslSshProfile '%s': not found", mkey)
	}

	res = results.Results[0]
	return
}

// Create a new FirewallSslSshProfile
func (c *WebClient) CreateFirewallSslSshProfile(obj *FirewallSslSshProfile) (id string, err error) {
	var errmsg Result
	var results FirewallSslSshProfileResults
	_, err = c.napping.Post(c.URL+"/api/v2/firewall/ssl-ssh-profile", obj, &results, &errmsg)
	if err != nil {
		return "", fmt.Errorf("error creating FirewallSslSshProfile '%s': %s", obj.Name, err.Error())
	}
	if results.HTTPStatus == 200 {
		return
	}
	if errmsg.HTTPStatus != 200 {
		return "", fmt.Errorf("error creating FirewallSslSshProfile '%s': %s", obj.Name, errmsg.Status)
	}

	return
}

// Update a FirewallSslSshProfile
func (c *WebClient) UpdateFirewallSslSshProfile(obj *FirewallSslSshProfile) (err error) {
	var errmsg Result
	var results FirewallSslSshProfileResults
	_, err = c.napping.Put(c.URL+"/api/v2/firewall/ssl-ssh-profile/"+obj.Name, obj, &results, &errmsg)
	if err != nil {
		return fmt.Errorf("error updating FirewallSslSshProfile '%s': %s", obj.Name, err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return fmt.Errorf("error updating FirewallSslSshProfile '%s': not found", obj.Name)
		} else {
			return fmt.Errorf("error updating FirewallSslSshProfile '%s': %s", obj.Name, errmsg.Status)
		}
	}

	return
}

// Delete a FirewallSslSshProfile by name
func (c *WebClient) DeleteFirewallSslSshProfile(mkey string) (err error) {
	var errmsg Result
	var results FirewallSslSshProfileResults
	_, err = c.napping.Delete(c.URL+"/api/v2/firewall/ssl-ssh-profile/"+mkey, nil, &results, &errmsg)
	if err != nil {
		return fmt.Errorf("error deleting FirewallSslSshProfile '%s': %s", mkey, err.Error())
	}
	if results.HTTPStatus == 200 {
		return
	}
	if errmsg.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return fmt.Errorf("error deleting FirewallSslSshProfile '%s': not found", mkey)
		}
		return fmt.Errorf("error deleting FirewallSslSshProfile '%s': %s", mkey, errmsg.Status)
	}

	return
}

// List all FirewallSslSshProfiles
func (c *FakeClient) ListFirewallSslSshProfiles() (res []*FirewallSslSshProfile, err error) {
	for _, r := range c.FirewallSslSshProfiles {
		res = append(res, r)
	}
	return
}

// Get a FirewallSslSshProfile by name
func (c *FakeClient) GetFirewallSslSshProfile(mkey string) (*FirewallSslSshProfile, error) {
	if res, ok := c.FirewallSslSshProfiles[mkey]; ok {
		return res, nil
	} else {
		return &FirewallSslSshProfile{}, fmt.Errorf("error getting FirewallSslSshProfile '%s': not found", mkey)
	}
}

// Create a new FirewallSslSshProfile
func (c *FakeClient) CreateFirewallSslSshProfile(obj *FirewallSslSshProfile) (id string, err error) {
	id = obj.Name
	c.FirewallSslSshProfiles[id] = obj
	return
}

// Update a FirewallSslSshProfile
func (c *FakeClient) UpdateFirewallSslSshProfile(obj *FirewallSslSshProfile) (err error) {
	c.FirewallSslSshProfiles[obj.Name] = obj
	return nil
}

// Delete a FirewallSslSshProfile by name
func (c *FakeClient) DeleteFirewallSslSshProfile(mkey string) (err error) {
	delete(c.FirewallSslSshProfiles, mkey)
	return nil
}

// Configure profile groups.
type FirewallProfileGroup struct {

	// Name of an existing Application list.
	ApplicationList string `json:"application-list,omitempty"`

	// Name of an existing Antivirus profile.
	AvProfile string `json:"av-profile,omitempty"`

	// Name of an existing DLP sensor.
	DlpSensor string `json:"dlp-sensor,omitempty"`

	// Name of an existing DNS filter profile.
	DnsfilterProfile string `json:"dnsfilter-profile,omitempty"`

	// Name of an existing ICAP profile.
	IcapProfile string `json:"icap-profile,omitempty"`

	// Name of an existing IPS sensor.
	IpsSensor string `json:"ips-sensor,omitempty"`

	// Profile group name.
	Name string `json:"name,omitempty"`

	// Name of an existing Protocol options profile.
	ProfileProtocolOptions string `json:"profile-protocol-options,omitempty"`

	// Name of an existing Spam filter profile.
	SpamfilterProfile string `json:"spamfilter-profile,omitempty"`

	// Name of an existing SSL SSH profile.
	SslSshProfile string `json:"ssl-ssh-profile,omitempty"`

	// Name of an existing VoIP profile.
	VoipProfile string `json:"voip-profile,omitempty"`

	// Name of an existing Web application firewall profile.
	WafProfile string `json:"waf-profile,omitempty"`

	// Name of an existing Web filter profile.
	WebfilterProfile string `json:"webfilter-profile,omitempty"`
}

// Returns the value that identifies a FirewallProfileGroup
func (x *FirewallProfileGroup) MKey() string {
	return x.Name
}

// The results of a Get or List operation
type FirewallProfileGroupResults struct {
	Results []*FirewallProfileGroup `json:"results"`
	Mkey    string                  `json:"mkey"`
	Result
}

// List all FirewallProfileGroups
func (c *WebClient) ListFirewallProfileGroups() (res []*FirewallProfileGroup, err error) {
	var errmsg Result
	var results FirewallProfileGroupResults
	_, err = c.napping.Get(c.URL+"/api/v2/firewall/profile-group", nil, &results, nil)
	if err != nil {
		return []*FirewallProfileGroup{}, fmt.Errorf("error listing FirewallProfileGroups: %s", err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return []*FirewallProfileGroup{}, fmt.Errorf("error listing FirewallProfileGroup: not found")
		} else {
			return []*FirewallProfileGroup{}, fmt.Errorf("error listing FirewallProfileGroup: %s", errmsg.Status)
		}
	}
	res = results.Results
	return
}

// Get a FirewallProfileGroup by name
func (c *WebClient) GetFirewallProfileGroup(mkey string) (res *FirewallProfileGroup, err error) {
	var errmsg Result
	var results FirewallProfileGroupResults
	_, err = c.napping.Get(c.URL+"/api/v2/firewall/profile-group/"+mkey, nil, &results, &errmsg)
	if err != nil {
		return &FirewallProfileGroup{}, fmt.Errorf("error getting FirewallProfileGroup '%s': %s", mkey, err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return &FirewallProfileGroup{}, fmt.Errorf("error getting FirewallProfileGroup '%s': not found", mkey)
		} else {
			return &FirewallProfileGroup{}, fmt.Errorf("error getting FirewallProfileGroup '%s': %s", mkey, errmsg.Status)
		}
	}
	if len(results.Results) == 0 {
		return &FirewallProfileGroup{}, fmt.Errorf("error getting FirewallProfileGroup '%s': not found", mkey)
	}

	res = results.Results[0]
	return
}

// Create a new FirewallProfileGroup
func (c *WebClient) CreateFirewallProfileGroup(obj *FirewallProfileGroup) (id string, err error) {
	var errmsg Result
	var results FirewallProfileGroupResults
	_, err = c.napping.Post(c.URL+"/api/v2/firewall/profile-group", obj, &results, &errmsg)
	if err != nil {
		return "", fmt.Errorf("error creating FirewallProfileGroup '%s': %s", obj.Name, err.Error())
	}
	if results.HTTPStatus == 200 {
		return
	}
	if errmsg.HTTPStatus != 200 {
		return "", fmt.Errorf("error creating FirewallProfileGroup '%s': %s", obj.Name, errmsg.Status)
	}

	return
}

// Update a FirewallProfileGroup
func (c *WebClient) UpdateFirewallProfileGroup(obj *FirewallProfileGroup) (err error) {
	var errmsg Result
	var results FirewallProfileGroupResults
	_, err = c.napping.Put(c.URL+"/api/v2/firewall/profile-group/"+obj.Name, obj, &results, &errmsg)
	if err != nil {
		return fmt.Errorf("error updating FirewallProfileGroup '%s': %s", obj.Name, err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return fmt.Errorf("error updating FirewallProfileGroup '%s': not found", obj.Name)
		} else {
			return fmt.Errorf("error updating FirewallProfileGroup '%s': %s", obj.Name, errmsg.Status)
		}
	}

	return
}

// Delete a FirewallProfileGroup by name
func (c *WebClient) DeleteFirewallProfileGroup(mkey string) (err error) {
	var errmsg Result
	var results FirewallProfileGroupResults
	_, err = c.napping.Delete(c.URL+"/api/v2/firewall/profile-group/"+mkey, nil, &results, &errmsg)
	if err != nil {
		return fmt.Errorf("error deleting FirewallProfileGroup '%s': %s", mkey, err.Error())
	}
	if results.HTTPStatus == 200 {
		return
	}
	if errmsg.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return fmt.Errorf("error deleting FirewallProfileGroup '%s': not found", mkey)
		}
		return fmt.Errorf("error deleting FirewallProfileGroup '%s': %s", mkey, errmsg.Status)
	}

	return
}

// List all FirewallProfileGroups
func (c *FakeClient) ListFirewallProfileGroups() (res []*FirewallProfileGroup, err error) {
	for _, r := range c.FirewallProfileGroups {
		res = append(res, r)
	}
	return
}

// Get a FirewallProfileGroup by name
func (c *FakeClient) GetFirewallProfileGroup(mkey string) (*FirewallProfileGroup, error) {
	if res, ok := c.FirewallProfileGroups[mkey]; ok {
		return res, nil
	} else {
		return &FirewallProfileGroup{}, fmt.Errorf("error getting FirewallProfileGroup '%s': not found", mkey)
	}
}

// Create a new FirewallProfileGroup
func (c *FakeClient) CreateFirewallProfileGroup(obj *FirewallProfileGroup) (id string, err error) {
	id = obj.Name
	c.FirewallProfileGroups[id] = obj
	return
}

// Update a FirewallProfileGroup
func (c *FakeClient) UpdateFirewallProfileGroup(obj *FirewallProfileGroup) (err error) {
	c.FirewallProfileGroups[obj.Name] = obj
	return nil
}

// Delete a FirewallProfileGroup by name
func (c *FakeClient) DeleteFirewallProfileGroup(mkey string) (err error) {
	delete(c.FirewallProfileGroups, mkey)
	return nil
}

// Enable/disable adding an X-Forwarded-Proto header to forwarded requests.
type FirewallSslServerAddHeaderXForwardedProto string

// Relative strength of encryption algorithms accepted in negotiation.
type FirewallSslServerSslAlgorithm string

// Allow or block client renegotiation by server.
type FirewallSslServerSslClientRenegotiation string

// Bit-size of Diffie-Hellman (DH) prime used in DHE-RSA negotiation (default = 2048).
type FirewallSslServerSslDhBits string

// Highest SSL/TLS version to negotiate.
type FirewallSslServerSslMaxVersion string

// Lowest SSL/TLS version to negotiate.
type FirewallSslServerSslMinVersion string

// SSL/TLS mode for encryption and decryption of traffic.
type FirewallSslServerSslMode string

// Enable/disable sending empty fragments to avoid attack on CBC IV.
type FirewallSslServerSslSendEmptyFrags string

// Enable/disable rewriting the URL.
type FirewallSslServerUrlRewrite string

const (
	// Add X-Forwarded-Proto header.
	FirewallSslServerAddHeaderXForwardedProtoEnable FirewallSslServerAddHeaderXForwardedProto = "enable"

	// Do not add X-Forwarded-Proto header.
	FirewallSslServerAddHeaderXForwardedProtoDisable FirewallSslServerAddHeaderXForwardedProto = "disable"
)

const (
	// High encryption. Allow only AES and ChaCha
	FirewallSslServerSslAlgorithmHigh FirewallSslServerSslAlgorithm = "high"

	// Medium encryption. Allow AES, ChaCha, 3DES, and RC4.
	FirewallSslServerSslAlgorithmMedium FirewallSslServerSslAlgorithm = "medium"

	// Low encryption. Allow AES, ChaCha, 3DES, RC4, and DES.
	FirewallSslServerSslAlgorithmLow FirewallSslServerSslAlgorithm = "low"
)

const (
	// Allow a SSL client to renegotiate.
	FirewallSslServerSslClientRenegotiationAllow FirewallSslServerSslClientRenegotiation = "allow"

	// Abort any SSL connection that attempts to renegotiate.
	FirewallSslServerSslClientRenegotiationDeny FirewallSslServerSslClientRenegotiation = "deny"

	// Reject any SSL connection that does not offer a RFC 5746 Secure Renegotiation Indication.
	FirewallSslServerSslClientRenegotiationSecure FirewallSslServerSslClientRenegotiation = "secure"
)

const (
	// 768-bit Diffie-Hellman prime.
	FirewallSslServerSslDhBits768 FirewallSslServerSslDhBits = "768"

	// 1024-bit Diffie-Hellman prime.
	FirewallSslServerSslDhBits1024 FirewallSslServerSslDhBits = "1024"

	// 1536-bit Diffie-Hellman prime.
	FirewallSslServerSslDhBits1536 FirewallSslServerSslDhBits = "1536"

	// 2048-bit Diffie-Hellman prime.
	FirewallSslServerSslDhBits2048 FirewallSslServerSslDhBits = "2048"
)

const (
	// SSL 3.0.
	FirewallSslServerSslMaxVersionSslX30 FirewallSslServerSslMaxVersion = "ssl-3.0"

	// TLS 1.0.
	FirewallSslServerSslMaxVersionTls10 FirewallSslServerSslMaxVersion = "tls-1.0"

	// TLS 1.1.
	FirewallSslServerSslMaxVersionTls11 FirewallSslServerSslMaxVersion = "tls-1.1"

	// TLS 1.2.
	FirewallSslServerSslMaxVersionTls12 FirewallSslServerSslMaxVersion = "tls-1.2"
)

const (
	// SSL 3.0.
	FirewallSslServerSslMinVersionSslX30 FirewallSslServerSslMinVersion = "ssl-3.0"

	// TLS 1.0.
	FirewallSslServerSslMinVersionTls10 FirewallSslServerSslMinVersion = "tls-1.0"

	// TLS 1.1.
	FirewallSslServerSslMinVersionTls11 FirewallSslServerSslMinVersion = "tls-1.1"

	// TLS 1.2.
	FirewallSslServerSslMinVersionTls12 FirewallSslServerSslMinVersion = "tls-1.2"
)

const (
	// Client to FortiGate SSL.
	FirewallSslServerSslModeHalf FirewallSslServerSslMode = "half"

	// Client to FortiGate and FortiGate to Server SSL.
	FirewallSslServerSslModeFull FirewallSslServerSslMode = "full"
)

const (
	// Send empty fragments.
	FirewallSslServerSslSendEmptyFragsEnable FirewallSslServerSslSendEmptyFrags = "enable"

	// Do not send empty fragments.
	FirewallSslServerSslSendEmptyFragsDisable FirewallSslServerSslSendEmptyFrags = "disable"
)

const (
	// Enable setting.
	FirewallSslServerUrlRewriteEnable FirewallSslServerUrlRewrite = "enable"

	// Disable setting.
	FirewallSslServerUrlRewriteDisable FirewallSslServerUrlRewrite = "disable"
)

// Configure SSL servers.
type FirewallSslServer struct {

	// Enable/disable adding an X-Forwarded-Proto header to forwarded requests.
	AddHeaderXForwardedProto FirewallSslServerAddHeaderXForwardedProto `json:"add-header-x-forwarded-proto,omitempty"`

	// IPv4 address of the SSL server.
	Ip string `json:"ip,omitempty"`

	// Mapped server service port (1 - 65535, default = 80).
	MappedPort int `json:"mapped-port,omitempty"`

	// Server name.
	Name string `json:"name,omitempty"`

	// Server service port (1 - 65535, default = 443).
	Port int `json:"port,omitempty"`

	// Relative strength of encryption algorithms accepted in negotiation.
	SslAlgorithm FirewallSslServerSslAlgorithm `json:"ssl-algorithm,omitempty"`

	// Name of certificate for SSL connections to this server (default = "Fortinet_CA_SSL").
	SslCert string `json:"ssl-cert,omitempty"`

	// Allow or block client renegotiation by server.
	SslClientRenegotiation FirewallSslServerSslClientRenegotiation `json:"ssl-client-renegotiation,omitempty"`

	// Bit-size of Diffie-Hellman (DH) prime used in DHE-RSA negotiation (default = 2048).
	SslDhBits FirewallSslServerSslDhBits `json:"ssl-dh-bits,omitempty"`

	// Highest SSL/TLS version to negotiate.
	SslMaxVersion FirewallSslServerSslMaxVersion `json:"ssl-max-version,omitempty"`

	// Lowest SSL/TLS version to negotiate.
	SslMinVersion FirewallSslServerSslMinVersion `json:"ssl-min-version,omitempty"`

	// SSL/TLS mode for encryption and decryption of traffic.
	SslMode FirewallSslServerSslMode `json:"ssl-mode,omitempty"`

	// Enable/disable sending empty fragments to avoid attack on CBC IV.
	SslSendEmptyFrags FirewallSslServerSslSendEmptyFrags `json:"ssl-send-empty-frags,omitempty"`

	// Enable/disable rewriting the URL.
	UrlRewrite FirewallSslServerUrlRewrite `json:"url-rewrite,omitempty"`
}

// Returns the value that identifies a FirewallSslServer
func (x *FirewallSslServer) MKey() string {
	return x.Name
}

// The results of a Get or List operation
type FirewallSslServerResults struct {
	Results []*FirewallSslServer `json:"results"`
	Mkey    string               `json:"mkey"`
	Result
}

// List all FirewallSslServers
func (c *WebClient) ListFirewallSslServers() (res []*FirewallSslServer, err error) {
	var errmsg Result
	var results FirewallSslServerResults
	_, err = c.napping.Get(c.URL+"/api/v2/firewall/ssl-server", nil, &results, nil)
	if err != nil {
		return []*FirewallSslServer{}, fmt.Errorf("error listing FirewallSslServers: %s", err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return []*FirewallSslServer{}, fmt.Errorf("error listing FirewallSslServer: not found")
		} else {
			return []*FirewallSslServer{}, fmt.Errorf("error listing FirewallSslServer: %s", errmsg.Status)
		}
	}
	res = results.Results
	return
}

// Get a FirewallSslServer by name
func (c *WebClient) GetFirewallSslServer(mkey string) (res *FirewallSslServer, err error) {
	var errmsg Result
	var results FirewallSslServerResults
	_, err = c.napping.Get(c.URL+"/api/v2/firewall/ssl-server/"+mkey, nil, &results, &errmsg)
	if err != nil {
		return &FirewallSslServer{}, fmt.Errorf("error getting FirewallSslServer '%s': %s", mkey, err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return &FirewallSslServer{}, fmt.Errorf("error getting FirewallSslServer '%s': not found", mkey)
		} else {
			return &FirewallSslServer{}, fmt.Errorf("error getting FirewallSslServer '%s': %s", mkey, errmsg.Status)
		}
	}
	if len(results.Results) == 0 {
		return &FirewallSslServer{}, fmt.Errorf("error getting FirewallSslServer '%s': not found", mkey)
	}

	res = results.Results[0]
	return
}

// Create a new FirewallSslServer
func (c *WebClient) CreateFirewallSslServer(obj *FirewallSslServer) (id string, err error) {
	var errmsg Result
	var results FirewallSslServerResults
	_, err = c.napping.Post(c.URL+"/api/v2/firewall/ssl-server", obj, &results, &errmsg)
	if err != nil {
		return "", fmt.Errorf("error creating FirewallSslServer '%s': %s", obj.Name, err.Error())
	}
	if results.HTTPStatus == 200 {
		return
	}
	if errmsg.HTTPStatus != 200 {
		return "", fmt.Errorf("error creating FirewallSslServer '%s': %s", obj.Name, errmsg.Status)
	}

	return
}

// Update a FirewallSslServer
func (c *WebClient) UpdateFirewallSslServer(obj *FirewallSslServer) (err error) {
	var errmsg Result
	var results FirewallSslServerResults
	_, err = c.napping.Put(c.URL+"/api/v2/firewall/ssl-server/"+obj.Name, obj, &results, &errmsg)
	if err != nil {
		return fmt.Errorf("error updating FirewallSslServer '%s': %s", obj.Name, err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return fmt.Errorf("error updating FirewallSslServer '%s': not found", obj.Name)
		} else {
			return fmt.Errorf("error updating FirewallSslServer '%s': %s", obj.Name, errmsg.Status)
		}
	}

	return
}

// Delete a FirewallSslServer by name
func (c *WebClient) DeleteFirewallSslServer(mkey string) (err error) {
	var errmsg Result
	var results FirewallSslServerResults
	_, err = c.napping.Delete(c.URL+"/api/v2/firewall/ssl-server/"+mkey, nil, &results, &errmsg)
	if err != nil {
		return fmt.Errorf("error deleting FirewallSslServer '%s': %s", mkey, err.Error())
	}
	if results.HTTPStatus == 200 {
		return
	}
	if errmsg.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return fmt.Errorf("error deleting FirewallSslServer '%s': not found", mkey)
		}
		return fmt.Errorf("error deleting FirewallSslServer '%s': %s", mkey, errmsg.Status)
	}

	return
}

// List all FirewallSslServers
func (c *FakeClient) ListFirewallSslServers() (res []*FirewallSslServer, err error) {
	for _, r := range c.FirewallSslServers {
		res = append(res, r)
	}
	return
}

// Get a FirewallSslServer by name
func (c *FakeClient) GetFirewallSslServer(mkey string) (*FirewallSslServer, error) {
	if res, ok := c.FirewallSslServers[mkey]; ok {
		return res, nil
	} else {
		return &FirewallSslServer{}, fmt.Errorf("error getting FirewallSslServer '%s': not found", mkey)
	}
}

// Create a new FirewallSslServer
func (c *FakeClient) CreateFirewallSslServer(obj *FirewallSslServer) (id string, err error) {
	id = obj.Name
	c.FirewallSslServers[id] = obj
	return
}

// Update a FirewallSslServer
func (c *FakeClient) UpdateFirewallSslServer(obj *FirewallSslServer) (err error) {
	c.FirewallSslServers[obj.Name] = obj
	return nil
}

// Delete a FirewallSslServer by name
func (c *FakeClient) DeleteFirewallSslServer(mkey string) (err error) {
	delete(c.FirewallSslServers, mkey)
	return nil
}

// Rule.
type FirewallIdentityBasedRouteRule struct {

	// Outgoing interface for the rule.
	Device string `json:"device,omitempty"`

	// IPv4 address of the gateway (Format: xxx.xxx.xxx.xxx , Default: 0.0.0.0).
	Gateway string `json:"gateway,omitempty"`

	// Select one or more group(s) from available groups that are allowed to use this route. Separate group names with a space.
	Groups string `json:"groups,omitempty"`

	// Rule ID.
	Id int `json:"id,omitempty"`
}

// Configure identity based routing.
type FirewallIdentityBasedRoute struct {

	// Comments.
	Comments string `json:"comments,omitempty"`

	// Name.
	Name string `json:"name,omitempty"`

	// Rule.
	Rule []FirewallIdentityBasedRouteRule `json:"rule,omitempty"`
}

// Returns the value that identifies a FirewallIdentityBasedRoute
func (x *FirewallIdentityBasedRoute) MKey() string {
	return x.Name
}

// The results of a Get or List operation
type FirewallIdentityBasedRouteResults struct {
	Results []*FirewallIdentityBasedRoute `json:"results"`
	Mkey    string                        `json:"mkey"`
	Result
}

// List all FirewallIdentityBasedRoutes
func (c *WebClient) ListFirewallIdentityBasedRoutes() (res []*FirewallIdentityBasedRoute, err error) {
	var errmsg Result
	var results FirewallIdentityBasedRouteResults
	_, err = c.napping.Get(c.URL+"/api/v2/firewall/identity-based-route", nil, &results, nil)
	if err != nil {
		return []*FirewallIdentityBasedRoute{}, fmt.Errorf("error listing FirewallIdentityBasedRoutes: %s", err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return []*FirewallIdentityBasedRoute{}, fmt.Errorf("error listing FirewallIdentityBasedRoute: not found")
		} else {
			return []*FirewallIdentityBasedRoute{}, fmt.Errorf("error listing FirewallIdentityBasedRoute: %s", errmsg.Status)
		}
	}
	res = results.Results
	return
}

// Get a FirewallIdentityBasedRoute by name
func (c *WebClient) GetFirewallIdentityBasedRoute(mkey string) (res *FirewallIdentityBasedRoute, err error) {
	var errmsg Result
	var results FirewallIdentityBasedRouteResults
	_, err = c.napping.Get(c.URL+"/api/v2/firewall/identity-based-route/"+mkey, nil, &results, &errmsg)
	if err != nil {
		return &FirewallIdentityBasedRoute{}, fmt.Errorf("error getting FirewallIdentityBasedRoute '%s': %s", mkey, err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return &FirewallIdentityBasedRoute{}, fmt.Errorf("error getting FirewallIdentityBasedRoute '%s': not found", mkey)
		} else {
			return &FirewallIdentityBasedRoute{}, fmt.Errorf("error getting FirewallIdentityBasedRoute '%s': %s", mkey, errmsg.Status)
		}
	}
	if len(results.Results) == 0 {
		return &FirewallIdentityBasedRoute{}, fmt.Errorf("error getting FirewallIdentityBasedRoute '%s': not found", mkey)
	}

	res = results.Results[0]
	return
}

// Create a new FirewallIdentityBasedRoute
func (c *WebClient) CreateFirewallIdentityBasedRoute(obj *FirewallIdentityBasedRoute) (id string, err error) {
	var errmsg Result
	var results FirewallIdentityBasedRouteResults
	_, err = c.napping.Post(c.URL+"/api/v2/firewall/identity-based-route", obj, &results, &errmsg)
	if err != nil {
		return "", fmt.Errorf("error creating FirewallIdentityBasedRoute '%s': %s", obj.Name, err.Error())
	}
	if results.HTTPStatus == 200 {
		return
	}
	if errmsg.HTTPStatus != 200 {
		return "", fmt.Errorf("error creating FirewallIdentityBasedRoute '%s': %s", obj.Name, errmsg.Status)
	}

	return
}

// Update a FirewallIdentityBasedRoute
func (c *WebClient) UpdateFirewallIdentityBasedRoute(obj *FirewallIdentityBasedRoute) (err error) {
	var errmsg Result
	var results FirewallIdentityBasedRouteResults
	_, err = c.napping.Put(c.URL+"/api/v2/firewall/identity-based-route/"+obj.Name, obj, &results, &errmsg)
	if err != nil {
		return fmt.Errorf("error updating FirewallIdentityBasedRoute '%s': %s", obj.Name, err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return fmt.Errorf("error updating FirewallIdentityBasedRoute '%s': not found", obj.Name)
		} else {
			return fmt.Errorf("error updating FirewallIdentityBasedRoute '%s': %s", obj.Name, errmsg.Status)
		}
	}

	return
}

// Delete a FirewallIdentityBasedRoute by name
func (c *WebClient) DeleteFirewallIdentityBasedRoute(mkey string) (err error) {
	var errmsg Result
	var results FirewallIdentityBasedRouteResults
	_, err = c.napping.Delete(c.URL+"/api/v2/firewall/identity-based-route/"+mkey, nil, &results, &errmsg)
	if err != nil {
		return fmt.Errorf("error deleting FirewallIdentityBasedRoute '%s': %s", mkey, err.Error())
	}
	if results.HTTPStatus == 200 {
		return
	}
	if errmsg.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return fmt.Errorf("error deleting FirewallIdentityBasedRoute '%s': not found", mkey)
		}
		return fmt.Errorf("error deleting FirewallIdentityBasedRoute '%s': %s", mkey, errmsg.Status)
	}

	return
}

// List all FirewallIdentityBasedRoutes
func (c *FakeClient) ListFirewallIdentityBasedRoutes() (res []*FirewallIdentityBasedRoute, err error) {
	for _, r := range c.FirewallIdentityBasedRoutes {
		res = append(res, r)
	}
	return
}

// Get a FirewallIdentityBasedRoute by name
func (c *FakeClient) GetFirewallIdentityBasedRoute(mkey string) (*FirewallIdentityBasedRoute, error) {
	if res, ok := c.FirewallIdentityBasedRoutes[mkey]; ok {
		return res, nil
	} else {
		return &FirewallIdentityBasedRoute{}, fmt.Errorf("error getting FirewallIdentityBasedRoute '%s': not found", mkey)
	}
}

// Create a new FirewallIdentityBasedRoute
func (c *FakeClient) CreateFirewallIdentityBasedRoute(obj *FirewallIdentityBasedRoute) (id string, err error) {
	id = obj.Name
	c.FirewallIdentityBasedRoutes[id] = obj
	return
}

// Update a FirewallIdentityBasedRoute
func (c *FakeClient) UpdateFirewallIdentityBasedRoute(obj *FirewallIdentityBasedRoute) (err error) {
	c.FirewallIdentityBasedRoutes[obj.Name] = obj
	return nil
}

// Delete a FirewallIdentityBasedRoute by name
func (c *FakeClient) DeleteFirewallIdentityBasedRoute(mkey string) (err error) {
	delete(c.FirewallIdentityBasedRoutes, mkey)
	return nil
}

// Policy action (allow/deny/ipsec).
type FirewallPolicyAction string

// Application category ID list.
type FirewallPolicyAppCategory struct {

	// Category IDs.
	Id int `json:"id,omitempty"`
}

// Application ID list.
type FirewallPolicyApplication struct {

	// Application IDs.
	Id int `json:"id,omitempty"`
}

// Enable/disable authentication-based routing.
type FirewallPolicyAuthPath string

// Enable/disable block notification.
type FirewallPolicyBlockNotification string

// Enable to exempt some users from the captive portal.
type FirewallPolicyCaptivePortalExempt string

// Custom fields to append to log messages for this policy.
type FirewallPolicyCustomLogFields struct {

	// Custom log field.
	FieldId string `json:"field-id,omitempty"`
}

// Enable TCP NPU session delay to guarantee packet order of 3-way handshake.
type FirewallPolicyDelayTcpNpuSession string

// Names of devices or device groups that can be matched by the policy.
type FirewallPolicyDevices struct {

	// Device or group name.
	Name string `json:"name,omitempty"`
}

// Enable to change packet's DiffServ values to the specified diffservcode-forward value.
type FirewallPolicyDiffservForward string

// Enable to change packet's reverse (reply) DiffServ values to the specified diffservcode-rev value.
type FirewallPolicyDiffservReverse string

// Enable/disable user authentication disclaimer.
type FirewallPolicyDisclaimer string

// Enable DSCP check.
type FirewallPolicyDscpMatch string

// Enable negated DSCP match.
type FirewallPolicyDscpNegate string

// Enable DSRI to ignore HTTP server responses.
type FirewallPolicyDsri string

// Destination address and address group names.
type FirewallPolicyDstaddr struct {

	// Address name.
	Name string `json:"name,omitempty"`
}

// When enabled dstaddr specifies what the destination address must NOT be.
type FirewallPolicyDstaddrNegate string

// Outgoing (egress) interface.
type FirewallPolicyDstintf struct {

	// Interface name.
	Name string `json:"name,omitempty"`
}

// How to handle sessions if the configuration of this firewall policy changes.
type FirewallPolicyFirewallSessionDirty string

// Enable to prevent source NAT from changing a session's source port.
type FirewallPolicyFixedport string

// Enable/disable Fortinet Single Sign-On.
type FirewallPolicyFsso string

// Names of user groups that can authenticate with this policy.
type FirewallPolicyGroups struct {

	// Group name.
	Name string `json:"name,omitempty"`
}

// Policy-based IPsec VPN: only traffic from the remote network can initiate a VPN.
type FirewallPolicyInbound string

// Enable/disable use of Internet Services for this policy. If enabled, destination address and service are not used.
type FirewallPolicyInternetService string

// Custom Internet Service Name.
type FirewallPolicyInternetServiceCustom struct {

	// Custom Internet Service name.
	Name string `json:"name,omitempty"`
}

// Internet Service ID.
type FirewallPolicyInternetServiceId struct {

	// Internet Service ID.
	Id int `json:"id,omitempty"`
}

// When enabled internet-service specifies what the service must NOT be.
type FirewallPolicyInternetServiceNegate string

// Enable to use IP Pools for source NAT.
type FirewallPolicyIppool string

// Enable to allow everything, but log all of the meaningful data for security information gathering. A learning report will be generated.
type FirewallPolicyLearningMode string

// Enable or disable logging. Log all sessions or security profile sessions.
type FirewallPolicyLogtraffic string

// Record logs when a session starts and ends.
type FirewallPolicyLogtrafficStart string

// Enable to match packets that have had their destination addresses changed by a VIP.
type FirewallPolicyMatchVip string

// Enable/disable source NAT.
type FirewallPolicyNat string

// Policy-based IPsec VPN: apply destination NAT to inbound traffic.
type FirewallPolicyNatinbound string

// Policy-based IPsec VPN: apply source NAT to outbound traffic.
type FirewallPolicyNatoutbound string

// Enable/disable NTLM authentication.
type FirewallPolicyNtlm string

// HTTP-User-Agent value of supported browsers.
type FirewallPolicyNtlmEnabledBrowsers struct {

	// User agent string.
	UserAgentString string `json:"user-agent-string,omitempty"`
}

// Enable/disable NTLM guest user access.
type FirewallPolicyNtlmGuest string

// Policy-based IPsec VPN: only traffic from the internal network can initiate a VPN.
type FirewallPolicyOutbound string

// Accept UDP packets from any host.
type FirewallPolicyPermitAnyHost string

// Accept UDP packets from any Session Traversal Utilities for NAT (STUN) host.
type FirewallPolicyPermitStunHost string

// IP Pool names.
type FirewallPolicyPoolname struct {

	// IP pool name.
	Name string `json:"name,omitempty"`
}

// Determine whether the firewall policy allows security profile groups or single profiles only.
type FirewallPolicyProfileType string

// Enable MAC authentication bypass. The bypassed MAC address must be received from RADIUS server.
type FirewallPolicyRadiusMacAuthBypass string

// Enable/disable RADIUS single sign-on (RSSO).
type FirewallPolicyRsso string

// Address names if this is an RTP NAT policy.
type FirewallPolicyRtpAddr struct {

	// Address name.
	Name string `json:"name,omitempty"`
}

// Enable Real Time Protocol (RTP) NAT.
type FirewallPolicyRtpNat string

// Block or monitor connections to Botnet servers or disable Botnet scanning.
type FirewallPolicyScanBotnetConnections string

// Enable to force current sessions to end when the schedule object times out. Disable allows them to end from inactivity.
type FirewallPolicyScheduleTimeout string

// Enable to send a reply when a session is denied or blocked by a firewall policy.
type FirewallPolicySendDenyPacket string

// Service and service group names.
type FirewallPolicyService struct {

	// Service and service group names.
	Name string `json:"name,omitempty"`
}

// When enabled service specifies what the service must NOT be.
type FirewallPolicyServiceNegate string

// Source address and address group names.
type FirewallPolicySrcaddr struct {

	// Address name.
	Name string `json:"name,omitempty"`
}

// When enabled srcaddr specifies what the source address must NOT be.
type FirewallPolicySrcaddrNegate string

// Incoming (ingress) interface.
type FirewallPolicySrcintf struct {

	// Interface name.
	Name string `json:"name,omitempty"`
}

// Enable to copy decrypted SSL traffic to a FortiGate interface (called SSL mirroring).
type FirewallPolicySslMirror string

// SSL mirror interface name.
type FirewallPolicySslMirrorIntf struct {

	// Mirror Interface name.
	Name string `json:"name,omitempty"`
}

// Enable or disable this policy.
type FirewallPolicyStatus string

// Names of object-tags applied to this policy.
type FirewallPolicyTags struct {

	// Tag name.
	Name string `json:"name,omitempty"`
}

// Enable/disable creation of TCP session without SYN flag.
type FirewallPolicyTcpSessionWithoutSyn string

// Enable/disable sending RST packets when TCP sessions expire.
type FirewallPolicyTimeoutSendRst string

// URL category ID list.
type FirewallPolicyUrlCategory struct {

	// URL category ID.
	Id int `json:"id,omitempty"`
}

// Names of individual users that can authenticate with this policy.
type FirewallPolicyUsers struct {

	// Names of individual users that can authenticate with this policy.
	Name string `json:"name,omitempty"`
}

// Enable to add one or more security profiles (AV, IPS, etc.) to the firewall policy.
type FirewallPolicyUtmStatus string

// Enable/disable forwarding traffic matching this policy to a configured WCCP server.
type FirewallPolicyWccp string

// Enable/disable WiFi Single Sign On (WSSO).
type FirewallPolicyWsso string

const (
	// Allows session that match the firewall policy.
	FirewallPolicyActionAccept FirewallPolicyAction = "accept"

	// Blocks sessions that match the firewall policy.
	FirewallPolicyActionDeny FirewallPolicyAction = "deny"

	// Firewall policy becomes a policy-based IPsec VPN policy.
	FirewallPolicyActionIpsec FirewallPolicyAction = "ipsec"
)

const (
	// Enable authentication-based routing.
	FirewallPolicyAuthPathEnable FirewallPolicyAuthPath = "enable"

	// Disable authentication-based routing.
	FirewallPolicyAuthPathDisable FirewallPolicyAuthPath = "disable"
)

const (
	// Enable setting.
	FirewallPolicyBlockNotificationEnable FirewallPolicyBlockNotification = "enable"

	// Disable setting.
	FirewallPolicyBlockNotificationDisable FirewallPolicyBlockNotification = "disable"
)

const (
	// Enable exemption of captive portal.
	FirewallPolicyCaptivePortalExemptEnable FirewallPolicyCaptivePortalExempt = "enable"

	// Disable exemption of captive portal.
	FirewallPolicyCaptivePortalExemptDisable FirewallPolicyCaptivePortalExempt = "disable"
)

const (
	// Enable TCP NPU session delay in order to guarantee packet order of 3-way handshake.
	FirewallPolicyDelayTcpNpuSessionEnable FirewallPolicyDelayTcpNpuSession = "enable"

	// Disable TCP NPU session delay in order to guarantee packet order of 3-way handshake.
	FirewallPolicyDelayTcpNpuSessionDisable FirewallPolicyDelayTcpNpuSession = "disable"
)

const (
	// Enable WAN optimization.
	FirewallPolicyDiffservForwardEnable FirewallPolicyDiffservForward = "enable"

	// Disable WAN optimization.
	FirewallPolicyDiffservForwardDisable FirewallPolicyDiffservForward = "disable"
)

const (
	// Enable setting.
	FirewallPolicyDiffservReverseEnable FirewallPolicyDiffservReverse = "enable"

	// Disable setting.
	FirewallPolicyDiffservReverseDisable FirewallPolicyDiffservReverse = "disable"
)

const (
	// Enable user authentication disclaimer.
	FirewallPolicyDisclaimerEnable FirewallPolicyDisclaimer = "enable"

	// Disable user authentication disclaimer.
	FirewallPolicyDisclaimerDisable FirewallPolicyDisclaimer = "disable"
)

const (
	// Enable DSCP check.
	FirewallPolicyDscpMatchEnable FirewallPolicyDscpMatch = "enable"

	// Disable DSCP check.
	FirewallPolicyDscpMatchDisable FirewallPolicyDscpMatch = "disable"
)

const (
	// Enable DSCP negate.
	FirewallPolicyDscpNegateEnable FirewallPolicyDscpNegate = "enable"

	// Disable DSCP negate.
	FirewallPolicyDscpNegateDisable FirewallPolicyDscpNegate = "disable"
)

const (
	// Enable DSRI.
	FirewallPolicyDsriEnable FirewallPolicyDsri = "enable"

	// Disable DSRI.
	FirewallPolicyDsriDisable FirewallPolicyDsri = "disable"
)

const (
	// Enable destination address negate.
	FirewallPolicyDstaddrNegateEnable FirewallPolicyDstaddrNegate = "enable"

	// Disable destination address negate.
	FirewallPolicyDstaddrNegateDisable FirewallPolicyDstaddrNegate = "disable"
)

const (
	// Flush all current sessions accepted by this policy. These sessions must be started and re-matched with policies.
	FirewallPolicyFirewallSessionDirtyCheckAll FirewallPolicyFirewallSessionDirty = "check-all"

	// Continue to allow sessions already accepted by this policy.
	FirewallPolicyFirewallSessionDirtyCheckNew FirewallPolicyFirewallSessionDirty = "check-new"
)

const (
	// Enable setting.
	FirewallPolicyFixedportEnable FirewallPolicyFixedport = "enable"

	// Disable setting.
	FirewallPolicyFixedportDisable FirewallPolicyFixedport = "disable"
)

const (
	// Enable setting.
	FirewallPolicyFssoEnable FirewallPolicyFsso = "enable"

	// Disable setting.
	FirewallPolicyFssoDisable FirewallPolicyFsso = "disable"
)

const (
	// Enable setting.
	FirewallPolicyInboundEnable FirewallPolicyInbound = "enable"

	// Disable setting.
	FirewallPolicyInboundDisable FirewallPolicyInbound = "disable"
)

const (
	// Enable use of Internet Services in policy.
	FirewallPolicyInternetServiceEnable FirewallPolicyInternetService = "enable"

	// Disable use of Internet Services in policy.
	FirewallPolicyInternetServiceDisable FirewallPolicyInternetService = "disable"
)

const (
	// Enable negated Internet Service match.
	FirewallPolicyInternetServiceNegateEnable FirewallPolicyInternetServiceNegate = "enable"

	// Disable negated Internet Service match.
	FirewallPolicyInternetServiceNegateDisable FirewallPolicyInternetServiceNegate = "disable"
)

const (
	// Enable setting.
	FirewallPolicyIppoolEnable FirewallPolicyIppool = "enable"

	// Disable setting.
	FirewallPolicyIppoolDisable FirewallPolicyIppool = "disable"
)

const (
	// Enable learning mode in firewall policy.
	FirewallPolicyLearningModeEnable FirewallPolicyLearningMode = "enable"

	// Disable learning mode in firewall policy.
	FirewallPolicyLearningModeDisable FirewallPolicyLearningMode = "disable"
)

const (
	// Log all sessions accepted or denied by this policy.
	FirewallPolicyLogtrafficAll FirewallPolicyLogtraffic = "all"

	// Log traffic that has a security profile applied to it.
	FirewallPolicyLogtrafficUtm FirewallPolicyLogtraffic = "utm"

	// Disable all logging for this policy.
	FirewallPolicyLogtrafficDisable FirewallPolicyLogtraffic = "disable"
)

const (
	// Enable setting.
	FirewallPolicyLogtrafficStartEnable FirewallPolicyLogtrafficStart = "enable"

	// Disable setting.
	FirewallPolicyLogtrafficStartDisable FirewallPolicyLogtrafficStart = "disable"
)

const (
	// Match DNATed packet.
	FirewallPolicyMatchVipEnable FirewallPolicyMatchVip = "enable"

	// Do not match DNATed packet.
	FirewallPolicyMatchVipDisable FirewallPolicyMatchVip = "disable"
)

const (
	// Enable setting.
	FirewallPolicyNatEnable FirewallPolicyNat = "enable"

	// Disable setting.
	FirewallPolicyNatDisable FirewallPolicyNat = "disable"
)

const (
	// Enable setting.
	FirewallPolicyNatinboundEnable FirewallPolicyNatinbound = "enable"

	// Disable setting.
	FirewallPolicyNatinboundDisable FirewallPolicyNatinbound = "disable"
)

const (
	// Enable setting.
	FirewallPolicyNatoutboundEnable FirewallPolicyNatoutbound = "enable"

	// Disable setting.
	FirewallPolicyNatoutboundDisable FirewallPolicyNatoutbound = "disable"
)

const (
	// Enable setting.
	FirewallPolicyNtlmEnable FirewallPolicyNtlm = "enable"

	// Disable setting.
	FirewallPolicyNtlmDisable FirewallPolicyNtlm = "disable"
)

const (
	// Enable setting.
	FirewallPolicyNtlmGuestEnable FirewallPolicyNtlmGuest = "enable"

	// Disable setting.
	FirewallPolicyNtlmGuestDisable FirewallPolicyNtlmGuest = "disable"
)

const (
	// Enable setting.
	FirewallPolicyOutboundEnable FirewallPolicyOutbound = "enable"

	// Disable setting.
	FirewallPolicyOutboundDisable FirewallPolicyOutbound = "disable"
)

const (
	// Enable setting.
	FirewallPolicyPermitAnyHostEnable FirewallPolicyPermitAnyHost = "enable"

	// Disable setting.
	FirewallPolicyPermitAnyHostDisable FirewallPolicyPermitAnyHost = "disable"
)

const (
	// Enable setting.
	FirewallPolicyPermitStunHostEnable FirewallPolicyPermitStunHost = "enable"

	// Disable setting.
	FirewallPolicyPermitStunHostDisable FirewallPolicyPermitStunHost = "disable"
)

const (
	// Do not allow security profile groups.
	FirewallPolicyProfileTypeSingle FirewallPolicyProfileType = "single"

	// Allow security profile groups.
	FirewallPolicyProfileTypeGroup FirewallPolicyProfileType = "group"
)

const (
	// Enable MAC authentication bypass.
	FirewallPolicyRadiusMacAuthBypassEnable FirewallPolicyRadiusMacAuthBypass = "enable"

	// Disable MAC authentication bypass.
	FirewallPolicyRadiusMacAuthBypassDisable FirewallPolicyRadiusMacAuthBypass = "disable"
)

const (
	// Enable setting.
	FirewallPolicyRssoEnable FirewallPolicyRsso = "enable"

	// Disable setting.
	FirewallPolicyRssoDisable FirewallPolicyRsso = "disable"
)

const (
	// Disable setting.
	FirewallPolicyRtpNatDisable FirewallPolicyRtpNat = "disable"

	// Enable setting.
	FirewallPolicyRtpNatEnable FirewallPolicyRtpNat = "enable"
)

const (
	// Do not scan connections to botnet servers.
	FirewallPolicyScanBotnetConnectionsDisable FirewallPolicyScanBotnetConnections = "disable"

	// Block connections to botnet servers.
	FirewallPolicyScanBotnetConnectionsBlock FirewallPolicyScanBotnetConnections = "block"

	// Log connections to botnet servers.
	FirewallPolicyScanBotnetConnectionsMonitor FirewallPolicyScanBotnetConnections = "monitor"
)

const (
	// Enable schedule timeout.
	FirewallPolicyScheduleTimeoutEnable FirewallPolicyScheduleTimeout = "enable"

	// Disable schedule timeout.
	FirewallPolicyScheduleTimeoutDisable FirewallPolicyScheduleTimeout = "disable"
)

const (
	// Disable deny-packet sending.
	FirewallPolicySendDenyPacketDisable FirewallPolicySendDenyPacket = "disable"

	// Enable deny-packet sending.
	FirewallPolicySendDenyPacketEnable FirewallPolicySendDenyPacket = "enable"
)

const (
	// Enable negated service match.
	FirewallPolicyServiceNegateEnable FirewallPolicyServiceNegate = "enable"

	// Disable negated service match.
	FirewallPolicyServiceNegateDisable FirewallPolicyServiceNegate = "disable"
)

const (
	// Enable source address negate.
	FirewallPolicySrcaddrNegateEnable FirewallPolicySrcaddrNegate = "enable"

	// Disable source address negate.
	FirewallPolicySrcaddrNegateDisable FirewallPolicySrcaddrNegate = "disable"
)

const (
	// Enable SSL mirror.
	FirewallPolicySslMirrorEnable FirewallPolicySslMirror = "enable"

	// Disable SSL mirror.
	FirewallPolicySslMirrorDisable FirewallPolicySslMirror = "disable"
)

const (
	// Enable setting.
	FirewallPolicyStatusEnable FirewallPolicyStatus = "enable"

	// Disable setting.
	FirewallPolicyStatusDisable FirewallPolicyStatus = "disable"
)

const (
	// Enable TCP session without SYN.
	FirewallPolicyTcpSessionWithoutSynAll FirewallPolicyTcpSessionWithoutSyn = "all"

	// Enable TCP session data only.
	FirewallPolicyTcpSessionWithoutSynDataOnly FirewallPolicyTcpSessionWithoutSyn = "data-only"

	// Disable TCP session without SYN.
	FirewallPolicyTcpSessionWithoutSynDisable FirewallPolicyTcpSessionWithoutSyn = "disable"
)

const (
	// Enable sending of RST packet upon TCP session expiration.
	FirewallPolicyTimeoutSendRstEnable FirewallPolicyTimeoutSendRst = "enable"

	// Disable sending of RST packet upon TCP session expiration.
	FirewallPolicyTimeoutSendRstDisable FirewallPolicyTimeoutSendRst = "disable"
)

const (
	// Enable setting.
	FirewallPolicyUtmStatusEnable FirewallPolicyUtmStatus = "enable"

	// Disable setting.
	FirewallPolicyUtmStatusDisable FirewallPolicyUtmStatus = "disable"
)

const (
	// Enable WCCP setting.
	FirewallPolicyWccpEnable FirewallPolicyWccp = "enable"

	// Disable WCCP setting.
	FirewallPolicyWccpDisable FirewallPolicyWccp = "disable"
)

const (
	// Enable setting.
	FirewallPolicyWssoEnable FirewallPolicyWsso = "enable"

	// Disable setting.
	FirewallPolicyWssoDisable FirewallPolicyWsso = "disable"
)

// Configure IPv4 policies.
type FirewallPolicy struct {

	// Policy action (allow/deny/ipsec).
	Action FirewallPolicyAction `json:"action,omitempty"`

	// Application category ID list.
	AppCategory []FirewallPolicyAppCategory `json:"app-category,omitempty"`

	// Application ID list.
	Application []FirewallPolicyApplication `json:"application,omitempty"`

	// Name of an existing Application list.
	ApplicationList string `json:"application-list,omitempty"`

	// HTTPS server certificate for policy authentication.
	AuthCert string `json:"auth-cert,omitempty"`

	// Enable/disable authentication-based routing.
	AuthPath FirewallPolicyAuthPath `json:"auth-path,omitempty"`

	// HTTP-to-HTTPS redirect address for firewall authentication.
	AuthRedirectAddr string `json:"auth-redirect-addr,omitempty"`

	// Name of an existing Antivirus profile.
	AvProfile string `json:"av-profile,omitempty"`

	// Enable/disable block notification.
	BlockNotification FirewallPolicyBlockNotification `json:"block-notification,omitempty"`

	// Enable to exempt some users from the captive portal.
	CaptivePortalExempt FirewallPolicyCaptivePortalExempt `json:"captive-portal-exempt,omitempty"`

	// Comment.
	Comments string `json:"comments,omitempty"`

	// Custom fields to append to log messages for this policy.
	CustomLogFields []FirewallPolicyCustomLogFields `json:"custom-log-fields,omitempty"`

	// Enable TCP NPU session delay to guarantee packet order of 3-way handshake.
	DelayTcpNpuSession FirewallPolicyDelayTcpNpuSession `json:"delay-tcp-npu-session,omitempty"`

	// Names of devices or device groups that can be matched by the policy.
	Devices []FirewallPolicyDevices `json:"devices,omitempty"`

	// Enable to change packet's DiffServ values to the specified diffservcode-forward value.
	DiffservForward FirewallPolicyDiffservForward `json:"diffserv-forward,omitempty"`

	// Enable to change packet's reverse (reply) DiffServ values to the specified diffservcode-rev value.
	DiffservReverse FirewallPolicyDiffservReverse `json:"diffserv-reverse,omitempty"`

	// Change packet's DiffServ to this value.
	DiffservcodeForward string `json:"diffservcode-forward,omitempty"`

	// Change packet's reverse (reply) DiffServ to this value.
	DiffservcodeRev string `json:"diffservcode-rev,omitempty"`

	// Enable/disable user authentication disclaimer.
	Disclaimer FirewallPolicyDisclaimer `json:"disclaimer,omitempty"`

	// Name of an existing DLP sensor.
	DlpSensor string `json:"dlp-sensor,omitempty"`

	// Name of an existing DNS filter profile.
	DnsfilterProfile string `json:"dnsfilter-profile,omitempty"`

	// Enable DSCP check.
	DscpMatch FirewallPolicyDscpMatch `json:"dscp-match,omitempty"`

	// Enable negated DSCP match.
	DscpNegate FirewallPolicyDscpNegate `json:"dscp-negate,omitempty"`

	// DSCP value.
	DscpValue string `json:"dscp-value,omitempty"`

	// Enable DSRI to ignore HTTP server responses.
	Dsri FirewallPolicyDsri `json:"dsri,omitempty"`

	// Destination address and address group names.
	Dstaddr []FirewallPolicyDstaddr `json:"dstaddr,omitempty"`

	// When enabled dstaddr specifies what the destination address must NOT be.
	DstaddrNegate FirewallPolicyDstaddrNegate `json:"dstaddr-negate,omitempty"`

	// Outgoing (egress) interface.
	Dstintf []FirewallPolicyDstintf `json:"dstintf,omitempty"`

	// How to handle sessions if the configuration of this firewall policy changes.
	FirewallSessionDirty FirewallPolicyFirewallSessionDirty `json:"firewall-session-dirty,omitempty"`

	// Enable to prevent source NAT from changing a session's source port.
	Fixedport FirewallPolicyFixedport `json:"fixedport,omitempty"`

	// Enable/disable Fortinet Single Sign-On.
	Fsso FirewallPolicyFsso `json:"fsso,omitempty"`

	// FSSO agent to use for NTLM authentication.
	FssoAgentForNtlm string `json:"fsso-agent-for-ntlm,omitempty"`

	// Label for the policy that appears when the GUI is in Global View mode.
	GlobalLabel string `json:"global-label,omitempty"`

	// Names of user groups that can authenticate with this policy.
	Groups []FirewallPolicyGroups `json:"groups,omitempty"`

	// Name of an existing ICAP profile.
	IcapProfile string `json:"icap-profile,omitempty"`

	// Name of identity-based routing rule.
	IdentityBasedRoute string `json:"identity-based-route,omitempty"`

	// Policy-based IPsec VPN: only traffic from the remote network can initiate a VPN.
	Inbound FirewallPolicyInbound `json:"inbound,omitempty"`

	// Enable/disable use of Internet Services for this policy. If enabled, destination address and service are not used.
	InternetService FirewallPolicyInternetService `json:"internet-service,omitempty"`

	// Custom Internet Service Name.
	InternetServiceCustom []FirewallPolicyInternetServiceCustom `json:"internet-service-custom,omitempty"`

	// Internet Service ID.
	InternetServiceId []FirewallPolicyInternetServiceId `json:"internet-service-id,omitempty"`

	// When enabled internet-service specifies what the service must NOT be.
	InternetServiceNegate FirewallPolicyInternetServiceNegate `json:"internet-service-negate,omitempty"`

	// Enable to use IP Pools for source NAT.
	Ippool FirewallPolicyIppool `json:"ippool,omitempty"`

	// Name of an existing IPS sensor.
	IpsSensor string `json:"ips-sensor,omitempty"`

	// Label for the policy that appears when the GUI is in Section View mode.
	Label string `json:"label,omitempty"`

	// Enable to allow everything, but log all of the meaningful data for security information gathering. A learning report will be generated.
	LearningMode FirewallPolicyLearningMode `json:"learning-mode,omitempty"`

	// Enable or disable logging. Log all sessions or security profile sessions.
	Logtraffic FirewallPolicyLogtraffic `json:"logtraffic,omitempty"`

	// Record logs when a session starts and ends.
	LogtrafficStart FirewallPolicyLogtrafficStart `json:"logtraffic-start,omitempty"`

	// Enable to match packets that have had their destination addresses changed by a VIP.
	MatchVip FirewallPolicyMatchVip `json:"match-vip,omitempty"`

	// Policy name.
	Name string `json:"name,omitempty"`

	// Enable/disable source NAT.
	Nat FirewallPolicyNat `json:"nat,omitempty"`

	// Policy-based IPsec VPN: apply destination NAT to inbound traffic.
	Natinbound FirewallPolicyNatinbound `json:"natinbound,omitempty"`

	// Policy-based IPsec VPN: source NAT IP address for outgoing traffic.
	Natip string `json:"natip,omitempty"`

	// Policy-based IPsec VPN: apply source NAT to outbound traffic.
	Natoutbound FirewallPolicyNatoutbound `json:"natoutbound,omitempty"`

	// Enable/disable NTLM authentication.
	Ntlm FirewallPolicyNtlm `json:"ntlm,omitempty"`

	// HTTP-User-Agent value of supported browsers.
	NtlmEnabledBrowsers []FirewallPolicyNtlmEnabledBrowsers `json:"ntlm-enabled-browsers,omitempty"`

	// Enable/disable NTLM guest user access.
	NtlmGuest FirewallPolicyNtlmGuest `json:"ntlm-guest,omitempty"`

	// Policy-based IPsec VPN: only traffic from the internal network can initiate a VPN.
	Outbound FirewallPolicyOutbound `json:"outbound,omitempty"`

	// Per-IP traffic shaper.
	PerIpShaper string `json:"per-ip-shaper,omitempty"`

	// Accept UDP packets from any host.
	PermitAnyHost FirewallPolicyPermitAnyHost `json:"permit-any-host,omitempty"`

	// Accept UDP packets from any Session Traversal Utilities for NAT (STUN) host.
	PermitStunHost FirewallPolicyPermitStunHost `json:"permit-stun-host,omitempty"`

	// Policy ID.
	Policyid int `json:"policyid,omitempty"`

	// IP Pool names.
	Poolname []FirewallPolicyPoolname `json:"poolname,omitempty"`

	// Name of profile group.
	ProfileGroup string `json:"profile-group,omitempty"`

	// Name of an existing Protocol options profile.
	ProfileProtocolOptions string `json:"profile-protocol-options,omitempty"`

	// Determine whether the firewall policy allows security profile groups or single profiles only.
	ProfileType FirewallPolicyProfileType `json:"profile-type,omitempty"`

	// Enable MAC authentication bypass. The bypassed MAC address must be received from RADIUS server.
	RadiusMacAuthBypass FirewallPolicyRadiusMacAuthBypass `json:"radius-mac-auth-bypass,omitempty"`

	// URL users are directed to after seeing and accepting the disclaimer or authenticating.
	RedirectUrl string `json:"redirect-url,omitempty"`

	// Override the default replacement message group for this policy.
	ReplacemsgOverrideGroup string `json:"replacemsg-override-group,omitempty"`

	// Enable/disable RADIUS single sign-on (RSSO).
	Rsso FirewallPolicyRsso `json:"rsso,omitempty"`

	// Address names if this is an RTP NAT policy.
	RtpAddr []FirewallPolicyRtpAddr `json:"rtp-addr,omitempty"`

	// Enable Real Time Protocol (RTP) NAT.
	RtpNat FirewallPolicyRtpNat `json:"rtp-nat,omitempty"`

	// Block or monitor connections to Botnet servers or disable Botnet scanning.
	ScanBotnetConnections FirewallPolicyScanBotnetConnections `json:"scan-botnet-connections,omitempty"`

	// Schedule name.
	Schedule string `json:"schedule,omitempty"`

	// Enable to force current sessions to end when the schedule object times out. Disable allows them to end from inactivity.
	ScheduleTimeout FirewallPolicyScheduleTimeout `json:"schedule-timeout,omitempty"`

	// Enable to send a reply when a session is denied or blocked by a firewall policy.
	SendDenyPacket FirewallPolicySendDenyPacket `json:"send-deny-packet,omitempty"`

	// Service and service group names.
	Service []FirewallPolicyService `json:"service,omitempty"`

	// When enabled service specifies what the service must NOT be.
	ServiceNegate FirewallPolicyServiceNegate `json:"service-negate,omitempty"`

	// Session TTL in seconds for sessions accepted by this policy. 0 means use the system default session TTL.
	SessionTtl int `json:"session-ttl,omitempty"`

	// Name of an existing Spam filter profile.
	SpamfilterProfile string `json:"spamfilter-profile,omitempty"`

	// Source address and address group names.
	Srcaddr []FirewallPolicySrcaddr `json:"srcaddr,omitempty"`

	// When enabled srcaddr specifies what the source address must NOT be.
	SrcaddrNegate FirewallPolicySrcaddrNegate `json:"srcaddr-negate,omitempty"`

	// Incoming (ingress) interface.
	Srcintf []FirewallPolicySrcintf `json:"srcintf,omitempty"`

	// Enable to copy decrypted SSL traffic to a FortiGate interface (called SSL mirroring).
	SslMirror FirewallPolicySslMirror `json:"ssl-mirror,omitempty"`

	// SSL mirror interface name.
	SslMirrorIntf []FirewallPolicySslMirrorIntf `json:"ssl-mirror-intf,omitempty"`

	// Name of an existing SSL SSH profile.
	SslSshProfile string `json:"ssl-ssh-profile,omitempty"`

	// Enable or disable this policy.
	Status FirewallPolicyStatus `json:"status,omitempty"`

	// Names of object-tags applied to this policy.
	Tags []FirewallPolicyTags `json:"tags,omitempty"`

	// Receiver TCP maximum segment size (MSS).
	TcpMssReceiver int `json:"tcp-mss-receiver,omitempty"`

	// Sender TCP maximum segment size (MSS).
	TcpMssSender int `json:"tcp-mss-sender,omitempty"`

	// Enable/disable creation of TCP session without SYN flag.
	TcpSessionWithoutSyn FirewallPolicyTcpSessionWithoutSyn `json:"tcp-session-without-syn,omitempty"`

	// Enable/disable sending RST packets when TCP sessions expire.
	TimeoutSendRst FirewallPolicyTimeoutSendRst `json:"timeout-send-rst,omitempty"`

	// Traffic shaper.
	TrafficShaper string `json:"traffic-shaper,omitempty"`

	// Reverse traffic shaper.
	TrafficShaperReverse string `json:"traffic-shaper-reverse,omitempty"`

	// URL category ID list.
	UrlCategory []FirewallPolicyUrlCategory `json:"url-category,omitempty"`

	// Names of individual users that can authenticate with this policy.
	Users []FirewallPolicyUsers `json:"users,omitempty"`

	// Enable to add one or more security profiles (AV, IPS, etc.) to the firewall policy.
	UtmStatus FirewallPolicyUtmStatus `json:"utm-status,omitempty"`

	// Universally Unique Identifier (UUID; automatically assigned but can be manually reset).
	Uuid string `json:"uuid,omitempty"`

	// VLAN forward direction user priority: 255 passthrough, 0 lowest, 7 highest.
	VlanCosFwd int `json:"vlan-cos-fwd,omitempty"`

	// VLAN reverse direction user priority: 255 passthrough, 0 lowest, 7 highest..
	VlanCosRev int `json:"vlan-cos-rev,omitempty"`

	// Name of an existing VoIP profile.
	VoipProfile string `json:"voip-profile,omitempty"`

	// Policy-based IPsec VPN: name of the IPsec VPN Phase 1.
	Vpntunnel string `json:"vpntunnel,omitempty"`

	// Name of an existing Web application firewall profile.
	WafProfile string `json:"waf-profile,omitempty"`

	// Enable/disable forwarding traffic matching this policy to a configured WCCP server.
	Wccp FirewallPolicyWccp `json:"wccp,omitempty"`

	// Name of an existing Web filter profile.
	WebfilterProfile string `json:"webfilter-profile,omitempty"`

	// Enable/disable WiFi Single Sign On (WSSO).
	Wsso FirewallPolicyWsso `json:"wsso,omitempty"`
}

// Returns the value that identifies a FirewallPolicy
func (x *FirewallPolicy) MKey() int {
	return x.Policyid
}

// The results of a Get or List operation
type FirewallPolicyResults struct {
	Results []*FirewallPolicy `json:"results"`
	Mkey    int               `json:"mkey"`
	Result
}

// List all FirewallPolicys
func (c *WebClient) ListFirewallPolicys() (res []*FirewallPolicy, err error) {
	var errmsg Result
	var results FirewallPolicyResults
	_, err = c.napping.Get(c.URL+"/api/v2/firewall/policy", nil, &results, nil)
	if err != nil {
		return []*FirewallPolicy{}, fmt.Errorf("error listing FirewallPolicys: %s", err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return []*FirewallPolicy{}, fmt.Errorf("error listing FirewallPolicy: not found")
		} else {
			return []*FirewallPolicy{}, fmt.Errorf("error listing FirewallPolicy: %s", errmsg.Status)
		}
	}
	res = results.Results
	return
}

// Get a FirewallPolicy by name
func (c *WebClient) GetFirewallPolicy(mkey int) (res *FirewallPolicy, err error) {
	var errmsg Result
	var results FirewallPolicyResults
	_, err = c.napping.Get(c.URL+"/api/v2/firewall/policy/"+strconv.Itoa(mkey), nil, &results, &errmsg)
	if err != nil {
		return &FirewallPolicy{}, fmt.Errorf("error getting FirewallPolicy '%s': %s", strconv.Itoa(mkey), err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return &FirewallPolicy{}, fmt.Errorf("error getting FirewallPolicy '%s': not found", strconv.Itoa(mkey))
		} else {
			return &FirewallPolicy{}, fmt.Errorf("error getting FirewallPolicy '%s': %s", strconv.Itoa(mkey), errmsg.Status)
		}
	}
	if len(results.Results) == 0 {
		return &FirewallPolicy{}, fmt.Errorf("error getting FirewallPolicy '%s': not found", strconv.Itoa(mkey))
	}

	res = results.Results[0]
	return
}

// Create a new FirewallPolicy
func (c *WebClient) CreateFirewallPolicy(obj *FirewallPolicy) (id int, err error) {
	var errmsg Result
	var results FirewallPolicyResults
	_, err = c.napping.Post(c.URL+"/api/v2/firewall/policy", obj, &results, &errmsg)
	if err != nil {
		return 0, fmt.Errorf("error creating FirewallPolicy '%s': %s", strconv.Itoa(obj.Policyid), err.Error())
	}
	if results.HTTPStatus == 200 {
		return
	}
	if errmsg.HTTPStatus != 200 {
		return 0, fmt.Errorf("error creating FirewallPolicy '%s': %s", strconv.Itoa(obj.Policyid), errmsg.Status)
	}

	return
}

// Update a FirewallPolicy
func (c *WebClient) UpdateFirewallPolicy(obj *FirewallPolicy) (err error) {
	var errmsg Result
	var results FirewallPolicyResults
	_, err = c.napping.Put(c.URL+"/api/v2/firewall/policy/"+strconv.Itoa(obj.Policyid), obj, &results, &errmsg)
	if err != nil {
		return fmt.Errorf("error updating FirewallPolicy '%s': %s", strconv.Itoa(obj.Policyid), err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return fmt.Errorf("error updating FirewallPolicy '%s': not found", strconv.Itoa(obj.Policyid))
		} else {
			return fmt.Errorf("error updating FirewallPolicy '%s': %s", strconv.Itoa(obj.Policyid), errmsg.Status)
		}
	}

	return
}

// Delete a FirewallPolicy by name
func (c *WebClient) DeleteFirewallPolicy(mkey int) (err error) {
	var errmsg Result
	var results FirewallPolicyResults
	_, err = c.napping.Delete(c.URL+"/api/v2/firewall/policy/"+strconv.Itoa(mkey), nil, &results, &errmsg)
	if err != nil {
		return fmt.Errorf("error deleting FirewallPolicy '%s': %s", mkey, err.Error())
	}
	if results.HTTPStatus == 200 {
		return
	}
	if errmsg.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return fmt.Errorf("error deleting FirewallPolicy '%s': not found", mkey)
		}
		return fmt.Errorf("error deleting FirewallPolicy '%s': %s", mkey, errmsg.Status)
	}

	return
}

// List all FirewallPolicys
func (c *FakeClient) ListFirewallPolicys() (res []*FirewallPolicy, err error) {
	for _, r := range c.FirewallPolicys {
		res = append(res, r)
	}
	return
}

// Get a FirewallPolicy by name
func (c *FakeClient) GetFirewallPolicy(mkey int) (*FirewallPolicy, error) {
	if res, ok := c.FirewallPolicys[mkey]; ok {
		return res, nil
	} else {
		return &FirewallPolicy{}, fmt.Errorf("error getting FirewallPolicy '%s': not found", strconv.Itoa(mkey))
	}
}

// Create a new FirewallPolicy
func (c *FakeClient) CreateFirewallPolicy(obj *FirewallPolicy) (id int, err error) {
	id = c.FirewallPolicyCounter
	c.FirewallPolicyCounter++
	c.FirewallPolicys[id] = obj
	return
}

// Update a FirewallPolicy
func (c *FakeClient) UpdateFirewallPolicy(obj *FirewallPolicy) (err error) {
	c.FirewallPolicys[obj.Policyid] = obj
	return nil
}

// Delete a FirewallPolicy by name
func (c *FakeClient) DeleteFirewallPolicy(mkey int) (err error) {
	delete(c.FirewallPolicys, mkey)
	return nil
}

// IDs of one or more application categories that this shaper applies application control traffic shaping to.
type FirewallShapingPolicyAppCategory struct {

	// Category IDs.
	Id int `json:"id,omitempty"`
}

// IDs of one or more applications that this shaper applies application control traffic shaping to.
type FirewallShapingPolicyApplication struct {

	// Application IDs.
	Id int `json:"id,omitempty"`
}

// IPv4 destination address and address group names.
type FirewallShapingPolicyDstaddr struct {

	// Address name.
	Name string `json:"name,omitempty"`
}

// IPv6 destination address and address group names.
type FirewallShapingPolicyDstaddr6 struct {

	// Address name.
	Name string `json:"name,omitempty"`
}

// One or more outgoing (egress) interfaces.
type FirewallShapingPolicyDstintf struct {

	// Interface name.
	Name string `json:"name,omitempty"`
}

// Apply this traffic shaping policy to user groups that have authenticated with the FortiGate.
type FirewallShapingPolicyGroups struct {

	// Group name.
	Name string `json:"name,omitempty"`
}

// Apply this traffic shaping policy to IPv4 or IPv6 traffic.
type FirewallShapingPolicyIpVersion string

// Service and service group names.
type FirewallShapingPolicyService struct {

	// Service name.
	Name string `json:"name,omitempty"`
}

// IPv4 source address and address group names.
type FirewallShapingPolicySrcaddr struct {

	// Address name.
	Name string `json:"name,omitempty"`
}

// IPv6 source address and address group names.
type FirewallShapingPolicySrcaddr6 struct {

	// Address name.
	Name string `json:"name,omitempty"`
}

// Enable/disable this traffic shaping policy.
type FirewallShapingPolicyStatus string

// IDs of one or more FortiGuard Web Filtering categories that this shaper applies traffic shaping to.
type FirewallShapingPolicyUrlCategory struct {

	// URL category ID.
	Id int `json:"id,omitempty"`
}

// Apply this traffic shaping policy to individual users that have authenticated with the FortiGate.
type FirewallShapingPolicyUsers struct {

	// User name.
	Name string `json:"name,omitempty"`
}

const (
	// Use IPv4 addressing for Configuration Method.
	FirewallShapingPolicyIpVersion4 FirewallShapingPolicyIpVersion = "4"

	// Use IPv6 addressing for Configuration Method.
	FirewallShapingPolicyIpVersion6 FirewallShapingPolicyIpVersion = "6"
)

const (
	// Enable traffic shaping policy.
	FirewallShapingPolicyStatusEnable FirewallShapingPolicyStatus = "enable"

	// Disable traffic shaping policy.
	FirewallShapingPolicyStatusDisable FirewallShapingPolicyStatus = "disable"
)

// Configure shaping policies.
type FirewallShapingPolicy struct {

	// IDs of one or more application categories that this shaper applies application control traffic shaping to.
	AppCategory []FirewallShapingPolicyAppCategory `json:"app-category,omitempty"`

	// IDs of one or more applications that this shaper applies application control traffic shaping to.
	Application []FirewallShapingPolicyApplication `json:"application,omitempty"`

	// IPv4 destination address and address group names.
	Dstaddr []FirewallShapingPolicyDstaddr `json:"dstaddr,omitempty"`

	// IPv6 destination address and address group names.
	Dstaddr6 []FirewallShapingPolicyDstaddr6 `json:"dstaddr6,omitempty"`

	// One or more outgoing (egress) interfaces.
	Dstintf []FirewallShapingPolicyDstintf `json:"dstintf,omitempty"`

	// Apply this traffic shaping policy to user groups that have authenticated with the FortiGate.
	Groups []FirewallShapingPolicyGroups `json:"groups,omitempty"`

	// Shaping policy ID.
	Id int `json:"id,omitempty"`

	// Apply this traffic shaping policy to IPv4 or IPv6 traffic.
	IpVersion FirewallShapingPolicyIpVersion `json:"ip-version,omitempty"`

	// Per-IP traffic shaper to apply with this policy.
	PerIpShaper string `json:"per-ip-shaper,omitempty"`

	// Schedule name.
	Schedule string `json:"schedule,omitempty"`

	// Service and service group names.
	Service []FirewallShapingPolicyService `json:"service,omitempty"`

	// IPv4 source address and address group names.
	Srcaddr []FirewallShapingPolicySrcaddr `json:"srcaddr,omitempty"`

	// IPv6 source address and address group names.
	Srcaddr6 []FirewallShapingPolicySrcaddr6 `json:"srcaddr6,omitempty"`

	// Enable/disable this traffic shaping policy.
	Status FirewallShapingPolicyStatus `json:"status,omitempty"`

	// Traffic shaper to apply to traffic forwarded by the firewall policy.
	TrafficShaper string `json:"traffic-shaper,omitempty"`

	// Traffic shaper to apply to response traffic received by the firewall policy.
	TrafficShaperReverse string `json:"traffic-shaper-reverse,omitempty"`

	// IDs of one or more FortiGuard Web Filtering categories that this shaper applies traffic shaping to.
	UrlCategory []FirewallShapingPolicyUrlCategory `json:"url-category,omitempty"`

	// Apply this traffic shaping policy to individual users that have authenticated with the FortiGate.
	Users []FirewallShapingPolicyUsers `json:"users,omitempty"`
}

// Returns the value that identifies a FirewallShapingPolicy
func (x *FirewallShapingPolicy) MKey() int {
	return x.Id
}

// The results of a Get or List operation
type FirewallShapingPolicyResults struct {
	Results []*FirewallShapingPolicy `json:"results"`
	Mkey    int                      `json:"mkey"`
	Result
}

// List all FirewallShapingPolicys
func (c *WebClient) ListFirewallShapingPolicys() (res []*FirewallShapingPolicy, err error) {
	var errmsg Result
	var results FirewallShapingPolicyResults
	_, err = c.napping.Get(c.URL+"/api/v2/firewall/shaping-policy", nil, &results, nil)
	if err != nil {
		return []*FirewallShapingPolicy{}, fmt.Errorf("error listing FirewallShapingPolicys: %s", err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return []*FirewallShapingPolicy{}, fmt.Errorf("error listing FirewallShapingPolicy: not found")
		} else {
			return []*FirewallShapingPolicy{}, fmt.Errorf("error listing FirewallShapingPolicy: %s", errmsg.Status)
		}
	}
	res = results.Results
	return
}

// Get a FirewallShapingPolicy by name
func (c *WebClient) GetFirewallShapingPolicy(mkey int) (res *FirewallShapingPolicy, err error) {
	var errmsg Result
	var results FirewallShapingPolicyResults
	_, err = c.napping.Get(c.URL+"/api/v2/firewall/shaping-policy/"+strconv.Itoa(mkey), nil, &results, &errmsg)
	if err != nil {
		return &FirewallShapingPolicy{}, fmt.Errorf("error getting FirewallShapingPolicy '%s': %s", strconv.Itoa(mkey), err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return &FirewallShapingPolicy{}, fmt.Errorf("error getting FirewallShapingPolicy '%s': not found", strconv.Itoa(mkey))
		} else {
			return &FirewallShapingPolicy{}, fmt.Errorf("error getting FirewallShapingPolicy '%s': %s", strconv.Itoa(mkey), errmsg.Status)
		}
	}
	if len(results.Results) == 0 {
		return &FirewallShapingPolicy{}, fmt.Errorf("error getting FirewallShapingPolicy '%s': not found", strconv.Itoa(mkey))
	}

	res = results.Results[0]
	return
}

// Create a new FirewallShapingPolicy
func (c *WebClient) CreateFirewallShapingPolicy(obj *FirewallShapingPolicy) (id int, err error) {
	var errmsg Result
	var results FirewallShapingPolicyResults
	_, err = c.napping.Post(c.URL+"/api/v2/firewall/shaping-policy", obj, &results, &errmsg)
	if err != nil {
		return 0, fmt.Errorf("error creating FirewallShapingPolicy '%s': %s", strconv.Itoa(obj.Id), err.Error())
	}
	if results.HTTPStatus == 200 {
		return
	}
	if errmsg.HTTPStatus != 200 {
		return 0, fmt.Errorf("error creating FirewallShapingPolicy '%s': %s", strconv.Itoa(obj.Id), errmsg.Status)
	}

	return
}

// Update a FirewallShapingPolicy
func (c *WebClient) UpdateFirewallShapingPolicy(obj *FirewallShapingPolicy) (err error) {
	var errmsg Result
	var results FirewallShapingPolicyResults
	_, err = c.napping.Put(c.URL+"/api/v2/firewall/shaping-policy/"+strconv.Itoa(obj.Id), obj, &results, &errmsg)
	if err != nil {
		return fmt.Errorf("error updating FirewallShapingPolicy '%s': %s", strconv.Itoa(obj.Id), err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return fmt.Errorf("error updating FirewallShapingPolicy '%s': not found", strconv.Itoa(obj.Id))
		} else {
			return fmt.Errorf("error updating FirewallShapingPolicy '%s': %s", strconv.Itoa(obj.Id), errmsg.Status)
		}
	}

	return
}

// Delete a FirewallShapingPolicy by name
func (c *WebClient) DeleteFirewallShapingPolicy(mkey int) (err error) {
	var errmsg Result
	var results FirewallShapingPolicyResults
	_, err = c.napping.Delete(c.URL+"/api/v2/firewall/shaping-policy/"+strconv.Itoa(mkey), nil, &results, &errmsg)
	if err != nil {
		return fmt.Errorf("error deleting FirewallShapingPolicy '%s': %s", mkey, err.Error())
	}
	if results.HTTPStatus == 200 {
		return
	}
	if errmsg.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return fmt.Errorf("error deleting FirewallShapingPolicy '%s': not found", mkey)
		}
		return fmt.Errorf("error deleting FirewallShapingPolicy '%s': %s", mkey, errmsg.Status)
	}

	return
}

// List all FirewallShapingPolicys
func (c *FakeClient) ListFirewallShapingPolicys() (res []*FirewallShapingPolicy, err error) {
	for _, r := range c.FirewallShapingPolicys {
		res = append(res, r)
	}
	return
}

// Get a FirewallShapingPolicy by name
func (c *FakeClient) GetFirewallShapingPolicy(mkey int) (*FirewallShapingPolicy, error) {
	if res, ok := c.FirewallShapingPolicys[mkey]; ok {
		return res, nil
	} else {
		return &FirewallShapingPolicy{}, fmt.Errorf("error getting FirewallShapingPolicy '%s': not found", strconv.Itoa(mkey))
	}
}

// Create a new FirewallShapingPolicy
func (c *FakeClient) CreateFirewallShapingPolicy(obj *FirewallShapingPolicy) (id int, err error) {
	id = c.FirewallShapingPolicyCounter
	c.FirewallShapingPolicyCounter++
	c.FirewallShapingPolicys[id] = obj
	return
}

// Update a FirewallShapingPolicy
func (c *FakeClient) UpdateFirewallShapingPolicy(obj *FirewallShapingPolicy) (err error) {
	c.FirewallShapingPolicys[obj.Id] = obj
	return nil
}

// Delete a FirewallShapingPolicy by name
func (c *FakeClient) DeleteFirewallShapingPolicy(mkey int) (err error) {
	delete(c.FirewallShapingPolicys, mkey)
	return nil
}

// Action performed on traffic matching the policy (default = deny).
type FirewallLocalInPolicyAction string

// Destination address object from available options.
type FirewallLocalInPolicyDstaddr struct {

	// Address name.
	Name string `json:"name,omitempty"`
}

// Enable/disable dedicating the HA management interface only for local-in policy.
type FirewallLocalInPolicyHaMgmtIntfOnly string

// Service object from available options.
type FirewallLocalInPolicyService struct {

	// Service name.
	Name string `json:"name,omitempty"`
}

// Source address object from available options.
type FirewallLocalInPolicySrcaddr struct {

	// Address name.
	Name string `json:"name,omitempty"`
}

// Enable/disable this local-in policy.
type FirewallLocalInPolicyStatus string

const (
	// Allow traffic matching this policy.
	FirewallLocalInPolicyActionAccept FirewallLocalInPolicyAction = "accept"

	// Deny or block traffic matching this policy.
	FirewallLocalInPolicyActionDeny FirewallLocalInPolicyAction = "deny"
)

const (
	// Enable dedicating HA management interface only for local-in policy.
	FirewallLocalInPolicyHaMgmtIntfOnlyEnable FirewallLocalInPolicyHaMgmtIntfOnly = "enable"

	// Disable dedicating HA management interface only for local-in policy.
	FirewallLocalInPolicyHaMgmtIntfOnlyDisable FirewallLocalInPolicyHaMgmtIntfOnly = "disable"
)

const (
	// Enable this local-in policy.
	FirewallLocalInPolicyStatusEnable FirewallLocalInPolicyStatus = "enable"

	// Disable this local-in policy.
	FirewallLocalInPolicyStatusDisable FirewallLocalInPolicyStatus = "disable"
)

// Configure user defined IPv4 local-in policies.
type FirewallLocalInPolicy struct {

	// Action performed on traffic matching the policy (default = deny).
	Action FirewallLocalInPolicyAction `json:"action,omitempty"`

	// Destination address object from available options.
	Dstaddr []FirewallLocalInPolicyDstaddr `json:"dstaddr,omitempty"`

	// Enable/disable dedicating the HA management interface only for local-in policy.
	HaMgmtIntfOnly FirewallLocalInPolicyHaMgmtIntfOnly `json:"ha-mgmt-intf-only,omitempty"`

	// Incoming interface name from available options.
	Intf string `json:"intf,omitempty"`

	// User defined local in policy ID.
	Policyid int `json:"policyid,omitempty"`

	// Schedule object from available options.
	Schedule string `json:"schedule,omitempty"`

	// Service object from available options.
	Service []FirewallLocalInPolicyService `json:"service,omitempty"`

	// Source address object from available options.
	Srcaddr []FirewallLocalInPolicySrcaddr `json:"srcaddr,omitempty"`

	// Enable/disable this local-in policy.
	Status FirewallLocalInPolicyStatus `json:"status,omitempty"`
}

// Returns the value that identifies a FirewallLocalInPolicy
func (x *FirewallLocalInPolicy) MKey() int {
	return x.Policyid
}

// The results of a Get or List operation
type FirewallLocalInPolicyResults struct {
	Results []*FirewallLocalInPolicy `json:"results"`
	Mkey    int                      `json:"mkey"`
	Result
}

// List all FirewallLocalInPolicys
func (c *WebClient) ListFirewallLocalInPolicys() (res []*FirewallLocalInPolicy, err error) {
	var errmsg Result
	var results FirewallLocalInPolicyResults
	_, err = c.napping.Get(c.URL+"/api/v2/firewall/local-in-policy", nil, &results, nil)
	if err != nil {
		return []*FirewallLocalInPolicy{}, fmt.Errorf("error listing FirewallLocalInPolicys: %s", err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return []*FirewallLocalInPolicy{}, fmt.Errorf("error listing FirewallLocalInPolicy: not found")
		} else {
			return []*FirewallLocalInPolicy{}, fmt.Errorf("error listing FirewallLocalInPolicy: %s", errmsg.Status)
		}
	}
	res = results.Results
	return
}

// Get a FirewallLocalInPolicy by name
func (c *WebClient) GetFirewallLocalInPolicy(mkey int) (res *FirewallLocalInPolicy, err error) {
	var errmsg Result
	var results FirewallLocalInPolicyResults
	_, err = c.napping.Get(c.URL+"/api/v2/firewall/local-in-policy/"+strconv.Itoa(mkey), nil, &results, &errmsg)
	if err != nil {
		return &FirewallLocalInPolicy{}, fmt.Errorf("error getting FirewallLocalInPolicy '%s': %s", strconv.Itoa(mkey), err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return &FirewallLocalInPolicy{}, fmt.Errorf("error getting FirewallLocalInPolicy '%s': not found", strconv.Itoa(mkey))
		} else {
			return &FirewallLocalInPolicy{}, fmt.Errorf("error getting FirewallLocalInPolicy '%s': %s", strconv.Itoa(mkey), errmsg.Status)
		}
	}
	if len(results.Results) == 0 {
		return &FirewallLocalInPolicy{}, fmt.Errorf("error getting FirewallLocalInPolicy '%s': not found", strconv.Itoa(mkey))
	}

	res = results.Results[0]
	return
}

// Create a new FirewallLocalInPolicy
func (c *WebClient) CreateFirewallLocalInPolicy(obj *FirewallLocalInPolicy) (id int, err error) {
	var errmsg Result
	var results FirewallLocalInPolicyResults
	_, err = c.napping.Post(c.URL+"/api/v2/firewall/local-in-policy", obj, &results, &errmsg)
	if err != nil {
		return 0, fmt.Errorf("error creating FirewallLocalInPolicy '%s': %s", strconv.Itoa(obj.Policyid), err.Error())
	}
	if results.HTTPStatus == 200 {
		return
	}
	if errmsg.HTTPStatus != 200 {
		return 0, fmt.Errorf("error creating FirewallLocalInPolicy '%s': %s", strconv.Itoa(obj.Policyid), errmsg.Status)
	}

	return
}

// Update a FirewallLocalInPolicy
func (c *WebClient) UpdateFirewallLocalInPolicy(obj *FirewallLocalInPolicy) (err error) {
	var errmsg Result
	var results FirewallLocalInPolicyResults
	_, err = c.napping.Put(c.URL+"/api/v2/firewall/local-in-policy/"+strconv.Itoa(obj.Policyid), obj, &results, &errmsg)
	if err != nil {
		return fmt.Errorf("error updating FirewallLocalInPolicy '%s': %s", strconv.Itoa(obj.Policyid), err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return fmt.Errorf("error updating FirewallLocalInPolicy '%s': not found", strconv.Itoa(obj.Policyid))
		} else {
			return fmt.Errorf("error updating FirewallLocalInPolicy '%s': %s", strconv.Itoa(obj.Policyid), errmsg.Status)
		}
	}

	return
}

// Delete a FirewallLocalInPolicy by name
func (c *WebClient) DeleteFirewallLocalInPolicy(mkey int) (err error) {
	var errmsg Result
	var results FirewallLocalInPolicyResults
	_, err = c.napping.Delete(c.URL+"/api/v2/firewall/local-in-policy/"+strconv.Itoa(mkey), nil, &results, &errmsg)
	if err != nil {
		return fmt.Errorf("error deleting FirewallLocalInPolicy '%s': %s", mkey, err.Error())
	}
	if results.HTTPStatus == 200 {
		return
	}
	if errmsg.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return fmt.Errorf("error deleting FirewallLocalInPolicy '%s': not found", mkey)
		}
		return fmt.Errorf("error deleting FirewallLocalInPolicy '%s': %s", mkey, errmsg.Status)
	}

	return
}

// List all FirewallLocalInPolicys
func (c *FakeClient) ListFirewallLocalInPolicys() (res []*FirewallLocalInPolicy, err error) {
	for _, r := range c.FirewallLocalInPolicys {
		res = append(res, r)
	}
	return
}

// Get a FirewallLocalInPolicy by name
func (c *FakeClient) GetFirewallLocalInPolicy(mkey int) (*FirewallLocalInPolicy, error) {
	if res, ok := c.FirewallLocalInPolicys[mkey]; ok {
		return res, nil
	} else {
		return &FirewallLocalInPolicy{}, fmt.Errorf("error getting FirewallLocalInPolicy '%s': not found", strconv.Itoa(mkey))
	}
}

// Create a new FirewallLocalInPolicy
func (c *FakeClient) CreateFirewallLocalInPolicy(obj *FirewallLocalInPolicy) (id int, err error) {
	id = c.FirewallLocalInPolicyCounter
	c.FirewallLocalInPolicyCounter++
	c.FirewallLocalInPolicys[id] = obj
	return
}

// Update a FirewallLocalInPolicy
func (c *FakeClient) UpdateFirewallLocalInPolicy(obj *FirewallLocalInPolicy) (err error) {
	c.FirewallLocalInPolicys[obj.Policyid] = obj
	return nil
}

// Delete a FirewallLocalInPolicy by name
func (c *FakeClient) DeleteFirewallLocalInPolicy(mkey int) (err error) {
	delete(c.FirewallLocalInPolicys, mkey)
	return nil
}

// Policy action (allow/deny/ipsec).
type FirewallPolicy6Action string

// Application category ID list.
type FirewallPolicy6AppCategory struct {

	// Category IDs.
	Id int `json:"id,omitempty"`
}

// Application ID list.
type FirewallPolicy6Application struct {

	// Application IDs.
	Id int `json:"id,omitempty"`
}

// Log field index numbers to append custom log fields to log messages for this policy.
type FirewallPolicy6CustomLogFields struct {

	// Custom log field.
	FieldId string `json:"field-id,omitempty"`
}

// Names of devices or device groups that can be matched by the policy.
type FirewallPolicy6Devices struct {

	// Device or group name.
	Name string `json:"name,omitempty"`
}

// Enable to change packet's DiffServ values to the specified diffservcode-forward value.
type FirewallPolicy6DiffservForward string

// Enable to change packet's reverse (reply) DiffServ values to the specified diffservcode-rev value.
type FirewallPolicy6DiffservReverse string

// Enable DSCP check.
type FirewallPolicy6DscpMatch string

// Enable negated DSCP match.
type FirewallPolicy6DscpNegate string

// Enable DSRI to ignore HTTP server responses.
type FirewallPolicy6Dsri string

// Destination address and address group names.
type FirewallPolicy6Dstaddr struct {

	// Address name.
	Name string `json:"name,omitempty"`
}

// When enabled dstaddr specifies what the destination address must NOT be.
type FirewallPolicy6DstaddrNegate string

// Outgoing (egress) interface.
type FirewallPolicy6Dstintf struct {

	// Interface name.
	Name string `json:"name,omitempty"`
}

// How to handle sessions if the configuration of this firewall policy changes.
type FirewallPolicy6FirewallSessionDirty string

// Enable to prevent source NAT from changing a session's source port.
type FirewallPolicy6Fixedport string

// Names of user groups that can authenticate with this policy.
type FirewallPolicy6Groups struct {

	// Group name.
	Name string `json:"name,omitempty"`
}

// Policy-based IPsec VPN: only traffic from the remote network can initiate a VPN.
type FirewallPolicy6Inbound string

// Enable to use IP Pools for source NAT.
type FirewallPolicy6Ippool string

// Enable or disable logging. Log all sessions or security profile sessions.
type FirewallPolicy6Logtraffic string

// Record logs when a session starts and ends.
type FirewallPolicy6LogtrafficStart string

// Enable/disable source NAT.
type FirewallPolicy6Nat string

// Policy-based IPsec VPN: apply destination NAT to inbound traffic.
type FirewallPolicy6Natinbound string

// Policy-based IPsec VPN: apply source NAT to outbound traffic.
type FirewallPolicy6Natoutbound string

// Policy-based IPsec VPN: only traffic from the internal network can initiate a VPN.
type FirewallPolicy6Outbound string

// IP Pool names.
type FirewallPolicy6Poolname struct {

	// IP pool name.
	Name string `json:"name,omitempty"`
}

// Determine whether the firewall policy allows security profile groups or single profiles only.
type FirewallPolicy6ProfileType string

// Enable/disable RADIUS single sign-on (RSSO).
type FirewallPolicy6Rsso string

// Enable/disable return of deny-packet.
type FirewallPolicy6SendDenyPacket string

// Service and service group names.
type FirewallPolicy6Service struct {

	// Address name.
	Name string `json:"name,omitempty"`
}

// When enabled service specifies what the service must NOT be.
type FirewallPolicy6ServiceNegate string

// Source address and address group names.
type FirewallPolicy6Srcaddr struct {

	// Address name.
	Name string `json:"name,omitempty"`
}

// When enabled srcaddr specifies what the source address must NOT be.
type FirewallPolicy6SrcaddrNegate string

// Incoming (ingress) interface.
type FirewallPolicy6Srcintf struct {

	// Interface name.
	Name string `json:"name,omitempty"`
}

// Enable to copy decrypted SSL traffic to a FortiGate interface (called SSL mirroring).
type FirewallPolicy6SslMirror string

// SSL mirror interface name.
type FirewallPolicy6SslMirrorIntf struct {

	// Interface name.
	Name string `json:"name,omitempty"`
}

// Enable or disable this policy.
type FirewallPolicy6Status string

// Names of object-tags applied to this policy.
type FirewallPolicy6Tags struct {

	// Tag name.
	Name string `json:"name,omitempty"`
}

// Enable/disable creation of TCP session without SYN flag.
type FirewallPolicy6TcpSessionWithoutSyn string

// Enable/disable sending RST packets when TCP sessions expire.
type FirewallPolicy6TimeoutSendRst string

// URL category ID list.
type FirewallPolicy6UrlCategory struct {

	// URL category ID.
	Id int `json:"id,omitempty"`
}

// Names of individual users that can authenticate with this policy.
type FirewallPolicy6Users struct {

	// Names of individual users that can authenticate with this policy.
	Name string `json:"name,omitempty"`
}

// Enable AV/web/ips protection profile.
type FirewallPolicy6UtmStatus string

const (
	// Allows session that match the firewall policy.
	FirewallPolicy6ActionAccept FirewallPolicy6Action = "accept"

	// Blocks sessions that match the firewall policy.
	FirewallPolicy6ActionDeny FirewallPolicy6Action = "deny"

	// Firewall policy becomes a policy-based IPsec VPN policy.
	FirewallPolicy6ActionIpsec FirewallPolicy6Action = "ipsec"
)

const (
	// Enable forward (original) traffic DiffServ.
	FirewallPolicy6DiffservForwardEnable FirewallPolicy6DiffservForward = "enable"

	// Disable forward (original) traffic DiffServ.
	FirewallPolicy6DiffservForwardDisable FirewallPolicy6DiffservForward = "disable"
)

const (
	// Enable reverse (reply) traffic DiffServ.
	FirewallPolicy6DiffservReverseEnable FirewallPolicy6DiffservReverse = "enable"

	// Disable reverse (reply) traffic DiffServ.
	FirewallPolicy6DiffservReverseDisable FirewallPolicy6DiffservReverse = "disable"
)

const (
	// Enable DSCP check.
	FirewallPolicy6DscpMatchEnable FirewallPolicy6DscpMatch = "enable"

	// Disable DSCP check.
	FirewallPolicy6DscpMatchDisable FirewallPolicy6DscpMatch = "disable"
)

const (
	// Enable DSCP negate.
	FirewallPolicy6DscpNegateEnable FirewallPolicy6DscpNegate = "enable"

	// Disable DSCP negate.
	FirewallPolicy6DscpNegateDisable FirewallPolicy6DscpNegate = "disable"
)

const (
	// Enable DSRI.
	FirewallPolicy6DsriEnable FirewallPolicy6Dsri = "enable"

	// Disable DSRI.
	FirewallPolicy6DsriDisable FirewallPolicy6Dsri = "disable"
)

const (
	// Enable source address negate.
	FirewallPolicy6DstaddrNegateEnable FirewallPolicy6DstaddrNegate = "enable"

	// Disable destination address negate.
	FirewallPolicy6DstaddrNegateDisable FirewallPolicy6DstaddrNegate = "disable"
)

const (
	// Flush all current sessions accepted by this policy. These sessions must be started and re-matched with policies.
	FirewallPolicy6FirewallSessionDirtyCheckAll FirewallPolicy6FirewallSessionDirty = "check-all"

	// Continue to allow sessions already accepted by this policy.
	FirewallPolicy6FirewallSessionDirtyCheckNew FirewallPolicy6FirewallSessionDirty = "check-new"
)

const (
	// Enable setting.
	FirewallPolicy6FixedportEnable FirewallPolicy6Fixedport = "enable"

	// Disable setting.
	FirewallPolicy6FixedportDisable FirewallPolicy6Fixedport = "disable"
)

const (
	// Enable setting.
	FirewallPolicy6InboundEnable FirewallPolicy6Inbound = "enable"

	// Disable setting.
	FirewallPolicy6InboundDisable FirewallPolicy6Inbound = "disable"
)

const (
	// Enable setting.
	FirewallPolicy6IppoolEnable FirewallPolicy6Ippool = "enable"

	// Disable setting.
	FirewallPolicy6IppoolDisable FirewallPolicy6Ippool = "disable"
)

const (
	// Log all sessions accepted or denied by this policy.
	FirewallPolicy6LogtrafficAll FirewallPolicy6Logtraffic = "all"

	// Log traffic that has a security profile applied to it.
	FirewallPolicy6LogtrafficUtm FirewallPolicy6Logtraffic = "utm"

	// Disable all logging for this policy.
	FirewallPolicy6LogtrafficDisable FirewallPolicy6Logtraffic = "disable"
)

const (
	// Enable setting.
	FirewallPolicy6LogtrafficStartEnable FirewallPolicy6LogtrafficStart = "enable"

	// Disable setting.
	FirewallPolicy6LogtrafficStartDisable FirewallPolicy6LogtrafficStart = "disable"
)

const (
	// Enable setting.
	FirewallPolicy6NatEnable FirewallPolicy6Nat = "enable"

	// Disable setting.
	FirewallPolicy6NatDisable FirewallPolicy6Nat = "disable"
)

const (
	// Enable setting.
	FirewallPolicy6NatinboundEnable FirewallPolicy6Natinbound = "enable"

	// Disable setting.
	FirewallPolicy6NatinboundDisable FirewallPolicy6Natinbound = "disable"
)

const (
	// Enable setting.
	FirewallPolicy6NatoutboundEnable FirewallPolicy6Natoutbound = "enable"

	// Disable setting.
	FirewallPolicy6NatoutboundDisable FirewallPolicy6Natoutbound = "disable"
)

const (
	// Enable setting.
	FirewallPolicy6OutboundEnable FirewallPolicy6Outbound = "enable"

	// Disable setting.
	FirewallPolicy6OutboundDisable FirewallPolicy6Outbound = "disable"
)

const (
	// Do not allow security profile groups.
	FirewallPolicy6ProfileTypeSingle FirewallPolicy6ProfileType = "single"

	// Allow security profile groups.
	FirewallPolicy6ProfileTypeGroup FirewallPolicy6ProfileType = "group"
)

const (
	// Enable setting.
	FirewallPolicy6RssoEnable FirewallPolicy6Rsso = "enable"

	// Disable setting.
	FirewallPolicy6RssoDisable FirewallPolicy6Rsso = "disable"
)

const (
	// Enable setting.
	FirewallPolicy6SendDenyPacketEnable FirewallPolicy6SendDenyPacket = "enable"

	// Disable setting.
	FirewallPolicy6SendDenyPacketDisable FirewallPolicy6SendDenyPacket = "disable"
)

const (
	// Enable negated service match.
	FirewallPolicy6ServiceNegateEnable FirewallPolicy6ServiceNegate = "enable"

	// Disable negated service match.
	FirewallPolicy6ServiceNegateDisable FirewallPolicy6ServiceNegate = "disable"
)

const (
	// Enable source address negate.
	FirewallPolicy6SrcaddrNegateEnable FirewallPolicy6SrcaddrNegate = "enable"

	// Disable destination address negate.
	FirewallPolicy6SrcaddrNegateDisable FirewallPolicy6SrcaddrNegate = "disable"
)

const (
	// Enable SSL mirror.
	FirewallPolicy6SslMirrorEnable FirewallPolicy6SslMirror = "enable"

	// Disable SSL mirror.
	FirewallPolicy6SslMirrorDisable FirewallPolicy6SslMirror = "disable"
)

const (
	// Enable setting.
	FirewallPolicy6StatusEnable FirewallPolicy6Status = "enable"

	// Disable setting.
	FirewallPolicy6StatusDisable FirewallPolicy6Status = "disable"
)

const (
	// Enable TCP session without SYN.
	FirewallPolicy6TcpSessionWithoutSynAll FirewallPolicy6TcpSessionWithoutSyn = "all"

	// Enable TCP session data only.
	FirewallPolicy6TcpSessionWithoutSynDataOnly FirewallPolicy6TcpSessionWithoutSyn = "data-only"

	// Disable TCP session without SYN.
	FirewallPolicy6TcpSessionWithoutSynDisable FirewallPolicy6TcpSessionWithoutSyn = "disable"
)

const (
	// Send RST when session times out.
	FirewallPolicy6TimeoutSendRstEnable FirewallPolicy6TimeoutSendRst = "enable"

	// Donot send RST when session times out.
	FirewallPolicy6TimeoutSendRstDisable FirewallPolicy6TimeoutSendRst = "disable"
)

const (
	// Enable setting.
	FirewallPolicy6UtmStatusEnable FirewallPolicy6UtmStatus = "enable"

	// Disable setting.
	FirewallPolicy6UtmStatusDisable FirewallPolicy6UtmStatus = "disable"
)

// Configure IPv6 policies.
type FirewallPolicy6 struct {

	// Policy action (allow/deny/ipsec).
	Action FirewallPolicy6Action `json:"action,omitempty"`

	// Application category ID list.
	AppCategory []FirewallPolicy6AppCategory `json:"app-category,omitempty"`

	// Application ID list.
	Application []FirewallPolicy6Application `json:"application,omitempty"`

	// Name of an existing Application list.
	ApplicationList string `json:"application-list,omitempty"`

	// Name of an existing Antivirus profile.
	AvProfile string `json:"av-profile,omitempty"`

	// Comment.
	Comments string `json:"comments,omitempty"`

	// Log field index numbers to append custom log fields to log messages for this policy.
	CustomLogFields []FirewallPolicy6CustomLogFields `json:"custom-log-fields,omitempty"`

	// Names of devices or device groups that can be matched by the policy.
	Devices []FirewallPolicy6Devices `json:"devices,omitempty"`

	// Enable to change packet's DiffServ values to the specified diffservcode-forward value.
	DiffservForward FirewallPolicy6DiffservForward `json:"diffserv-forward,omitempty"`

	// Enable to change packet's reverse (reply) DiffServ values to the specified diffservcode-rev value.
	DiffservReverse FirewallPolicy6DiffservReverse `json:"diffserv-reverse,omitempty"`

	// Change packet's DiffServ to this value.
	DiffservcodeForward string `json:"diffservcode-forward,omitempty"`

	// Change packet's reverse (reply) DiffServ to this value.
	DiffservcodeRev string `json:"diffservcode-rev,omitempty"`

	// Name of an existing DLP sensor.
	DlpSensor string `json:"dlp-sensor,omitempty"`

	// Enable DSCP check.
	DscpMatch FirewallPolicy6DscpMatch `json:"dscp-match,omitempty"`

	// Enable negated DSCP match.
	DscpNegate FirewallPolicy6DscpNegate `json:"dscp-negate,omitempty"`

	// DSCP value.
	DscpValue string `json:"dscp-value,omitempty"`

	// Enable DSRI to ignore HTTP server responses.
	Dsri FirewallPolicy6Dsri `json:"dsri,omitempty"`

	// Destination address and address group names.
	Dstaddr []FirewallPolicy6Dstaddr `json:"dstaddr,omitempty"`

	// When enabled dstaddr specifies what the destination address must NOT be.
	DstaddrNegate FirewallPolicy6DstaddrNegate `json:"dstaddr-negate,omitempty"`

	// Outgoing (egress) interface.
	Dstintf []FirewallPolicy6Dstintf `json:"dstintf,omitempty"`

	// How to handle sessions if the configuration of this firewall policy changes.
	FirewallSessionDirty FirewallPolicy6FirewallSessionDirty `json:"firewall-session-dirty,omitempty"`

	// Enable to prevent source NAT from changing a session's source port.
	Fixedport FirewallPolicy6Fixedport `json:"fixedport,omitempty"`

	// Label for the policy that appears when the GUI is in Global View mode.
	GlobalLabel string `json:"global-label,omitempty"`

	// Names of user groups that can authenticate with this policy.
	Groups []FirewallPolicy6Groups `json:"groups,omitempty"`

	// Name of an existing ICAP profile.
	IcapProfile string `json:"icap-profile,omitempty"`

	// Policy-based IPsec VPN: only traffic from the remote network can initiate a VPN.
	Inbound FirewallPolicy6Inbound `json:"inbound,omitempty"`

	// Enable to use IP Pools for source NAT.
	Ippool FirewallPolicy6Ippool `json:"ippool,omitempty"`

	// Name of an existing IPS sensor.
	IpsSensor string `json:"ips-sensor,omitempty"`

	// Label for the policy that appears when the GUI is in Section View mode.
	Label string `json:"label,omitempty"`

	// Enable or disable logging. Log all sessions or security profile sessions.
	Logtraffic FirewallPolicy6Logtraffic `json:"logtraffic,omitempty"`

	// Record logs when a session starts and ends.
	LogtrafficStart FirewallPolicy6LogtrafficStart `json:"logtraffic-start,omitempty"`

	// Policy name.
	Name string `json:"name,omitempty"`

	// Enable/disable source NAT.
	Nat FirewallPolicy6Nat `json:"nat,omitempty"`

	// Policy-based IPsec VPN: apply destination NAT to inbound traffic.
	Natinbound FirewallPolicy6Natinbound `json:"natinbound,omitempty"`

	// Policy-based IPsec VPN: apply source NAT to outbound traffic.
	Natoutbound FirewallPolicy6Natoutbound `json:"natoutbound,omitempty"`

	// Policy-based IPsec VPN: only traffic from the internal network can initiate a VPN.
	Outbound FirewallPolicy6Outbound `json:"outbound,omitempty"`

	// Per-IP traffic shaper.
	PerIpShaper string `json:"per-ip-shaper,omitempty"`

	// Policy ID.
	Policyid int `json:"policyid,omitempty"`

	// IP Pool names.
	Poolname []FirewallPolicy6Poolname `json:"poolname,omitempty"`

	// Name of profile group.
	ProfileGroup string `json:"profile-group,omitempty"`

	// Name of an existing Protocol options profile.
	ProfileProtocolOptions string `json:"profile-protocol-options,omitempty"`

	// Determine whether the firewall policy allows security profile groups or single profiles only.
	ProfileType FirewallPolicy6ProfileType `json:"profile-type,omitempty"`

	// Override the default replacement message group for this policy.
	ReplacemsgOverrideGroup string `json:"replacemsg-override-group,omitempty"`

	// Enable/disable RADIUS single sign-on (RSSO).
	Rsso FirewallPolicy6Rsso `json:"rsso,omitempty"`

	// Schedule name.
	Schedule string `json:"schedule,omitempty"`

	// Enable/disable return of deny-packet.
	SendDenyPacket FirewallPolicy6SendDenyPacket `json:"send-deny-packet,omitempty"`

	// Service and service group names.
	Service []FirewallPolicy6Service `json:"service,omitempty"`

	// When enabled service specifies what the service must NOT be.
	ServiceNegate FirewallPolicy6ServiceNegate `json:"service-negate,omitempty"`

	// Session TTL in seconds for sessions accepted by this policy. 0 means use the system default session TTL.
	SessionTtl int `json:"session-ttl,omitempty"`

	// Name of an existing Spam filter profile.
	SpamfilterProfile string `json:"spamfilter-profile,omitempty"`

	// Source address and address group names.
	Srcaddr []FirewallPolicy6Srcaddr `json:"srcaddr,omitempty"`

	// When enabled srcaddr specifies what the source address must NOT be.
	SrcaddrNegate FirewallPolicy6SrcaddrNegate `json:"srcaddr-negate,omitempty"`

	// Incoming (ingress) interface.
	Srcintf []FirewallPolicy6Srcintf `json:"srcintf,omitempty"`

	// Enable to copy decrypted SSL traffic to a FortiGate interface (called SSL mirroring).
	SslMirror FirewallPolicy6SslMirror `json:"ssl-mirror,omitempty"`

	// SSL mirror interface name.
	SslMirrorIntf []FirewallPolicy6SslMirrorIntf `json:"ssl-mirror-intf,omitempty"`

	// Name of an existing SSL SSH profile.
	SslSshProfile string `json:"ssl-ssh-profile,omitempty"`

	// Enable or disable this policy.
	Status FirewallPolicy6Status `json:"status,omitempty"`

	// Names of object-tags applied to this policy.
	Tags []FirewallPolicy6Tags `json:"tags,omitempty"`

	// Receiver TCP maximum segment size (MSS).
	TcpMssReceiver int `json:"tcp-mss-receiver,omitempty"`

	// Sender TCP maximum segment size (MSS).
	TcpMssSender int `json:"tcp-mss-sender,omitempty"`

	// Enable/disable creation of TCP session without SYN flag.
	TcpSessionWithoutSyn FirewallPolicy6TcpSessionWithoutSyn `json:"tcp-session-without-syn,omitempty"`

	// Enable/disable sending RST packets when TCP sessions expire.
	TimeoutSendRst FirewallPolicy6TimeoutSendRst `json:"timeout-send-rst,omitempty"`

	// Reverse traffic shaper.
	TrafficShaper string `json:"traffic-shaper,omitempty"`

	// Reverse traffic shaper.
	TrafficShaperReverse string `json:"traffic-shaper-reverse,omitempty"`

	// URL category ID list.
	UrlCategory []FirewallPolicy6UrlCategory `json:"url-category,omitempty"`

	// Names of individual users that can authenticate with this policy.
	Users []FirewallPolicy6Users `json:"users,omitempty"`

	// Enable AV/web/ips protection profile.
	UtmStatus FirewallPolicy6UtmStatus `json:"utm-status,omitempty"`

	// Universally Unique Identifier (UUID; automatically assigned but can be manually reset).
	Uuid string `json:"uuid,omitempty"`

	// VLAN forward direction user priority: 255 passthrough, 0 lowest, 7 highest
	VlanCosFwd int `json:"vlan-cos-fwd,omitempty"`

	// VLAN reverse direction user priority: 255 passthrough, 0 lowest, 7 highest
	VlanCosRev int `json:"vlan-cos-rev,omitempty"`

	// Name of an existing VoIP profile.
	VoipProfile string `json:"voip-profile,omitempty"`

	// Policy-based IPsec VPN: name of the IPsec VPN Phase 1.
	Vpntunnel string `json:"vpntunnel,omitempty"`

	// Name of an existing Web filter profile.
	WebfilterProfile string `json:"webfilter-profile,omitempty"`
}

// Returns the value that identifies a FirewallPolicy6
func (x *FirewallPolicy6) MKey() int {
	return x.Policyid
}

// The results of a Get or List operation
type FirewallPolicy6Results struct {
	Results []*FirewallPolicy6 `json:"results"`
	Mkey    int                `json:"mkey"`
	Result
}

// List all FirewallPolicy6s
func (c *WebClient) ListFirewallPolicy6s() (res []*FirewallPolicy6, err error) {
	var errmsg Result
	var results FirewallPolicy6Results
	_, err = c.napping.Get(c.URL+"/api/v2/firewall/policy6", nil, &results, nil)
	if err != nil {
		return []*FirewallPolicy6{}, fmt.Errorf("error listing FirewallPolicy6s: %s", err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return []*FirewallPolicy6{}, fmt.Errorf("error listing FirewallPolicy6: not found")
		} else {
			return []*FirewallPolicy6{}, fmt.Errorf("error listing FirewallPolicy6: %s", errmsg.Status)
		}
	}
	res = results.Results
	return
}

// Get a FirewallPolicy6 by name
func (c *WebClient) GetFirewallPolicy6(mkey int) (res *FirewallPolicy6, err error) {
	var errmsg Result
	var results FirewallPolicy6Results
	_, err = c.napping.Get(c.URL+"/api/v2/firewall/policy6/"+strconv.Itoa(mkey), nil, &results, &errmsg)
	if err != nil {
		return &FirewallPolicy6{}, fmt.Errorf("error getting FirewallPolicy6 '%s': %s", strconv.Itoa(mkey), err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return &FirewallPolicy6{}, fmt.Errorf("error getting FirewallPolicy6 '%s': not found", strconv.Itoa(mkey))
		} else {
			return &FirewallPolicy6{}, fmt.Errorf("error getting FirewallPolicy6 '%s': %s", strconv.Itoa(mkey), errmsg.Status)
		}
	}
	if len(results.Results) == 0 {
		return &FirewallPolicy6{}, fmt.Errorf("error getting FirewallPolicy6 '%s': not found", strconv.Itoa(mkey))
	}

	res = results.Results[0]
	return
}

// Create a new FirewallPolicy6
func (c *WebClient) CreateFirewallPolicy6(obj *FirewallPolicy6) (id int, err error) {
	var errmsg Result
	var results FirewallPolicy6Results
	_, err = c.napping.Post(c.URL+"/api/v2/firewall/policy6", obj, &results, &errmsg)
	if err != nil {
		return 0, fmt.Errorf("error creating FirewallPolicy6 '%s': %s", strconv.Itoa(obj.Policyid), err.Error())
	}
	if results.HTTPStatus == 200 {
		return
	}
	if errmsg.HTTPStatus != 200 {
		return 0, fmt.Errorf("error creating FirewallPolicy6 '%s': %s", strconv.Itoa(obj.Policyid), errmsg.Status)
	}

	return
}

// Update a FirewallPolicy6
func (c *WebClient) UpdateFirewallPolicy6(obj *FirewallPolicy6) (err error) {
	var errmsg Result
	var results FirewallPolicy6Results
	_, err = c.napping.Put(c.URL+"/api/v2/firewall/policy6/"+strconv.Itoa(obj.Policyid), obj, &results, &errmsg)
	if err != nil {
		return fmt.Errorf("error updating FirewallPolicy6 '%s': %s", strconv.Itoa(obj.Policyid), err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return fmt.Errorf("error updating FirewallPolicy6 '%s': not found", strconv.Itoa(obj.Policyid))
		} else {
			return fmt.Errorf("error updating FirewallPolicy6 '%s': %s", strconv.Itoa(obj.Policyid), errmsg.Status)
		}
	}

	return
}

// Delete a FirewallPolicy6 by name
func (c *WebClient) DeleteFirewallPolicy6(mkey int) (err error) {
	var errmsg Result
	var results FirewallPolicy6Results
	_, err = c.napping.Delete(c.URL+"/api/v2/firewall/policy6/"+strconv.Itoa(mkey), nil, &results, &errmsg)
	if err != nil {
		return fmt.Errorf("error deleting FirewallPolicy6 '%s': %s", mkey, err.Error())
	}
	if results.HTTPStatus == 200 {
		return
	}
	if errmsg.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return fmt.Errorf("error deleting FirewallPolicy6 '%s': not found", mkey)
		}
		return fmt.Errorf("error deleting FirewallPolicy6 '%s': %s", mkey, errmsg.Status)
	}

	return
}

// List all FirewallPolicy6s
func (c *FakeClient) ListFirewallPolicy6s() (res []*FirewallPolicy6, err error) {
	for _, r := range c.FirewallPolicy6s {
		res = append(res, r)
	}
	return
}

// Get a FirewallPolicy6 by name
func (c *FakeClient) GetFirewallPolicy6(mkey int) (*FirewallPolicy6, error) {
	if res, ok := c.FirewallPolicy6s[mkey]; ok {
		return res, nil
	} else {
		return &FirewallPolicy6{}, fmt.Errorf("error getting FirewallPolicy6 '%s': not found", strconv.Itoa(mkey))
	}
}

// Create a new FirewallPolicy6
func (c *FakeClient) CreateFirewallPolicy6(obj *FirewallPolicy6) (id int, err error) {
	id = c.FirewallPolicy6Counter
	c.FirewallPolicy6Counter++
	c.FirewallPolicy6s[id] = obj
	return
}

// Update a FirewallPolicy6
func (c *FakeClient) UpdateFirewallPolicy6(obj *FirewallPolicy6) (err error) {
	c.FirewallPolicy6s[obj.Policyid] = obj
	return nil
}

// Delete a FirewallPolicy6 by name
func (c *FakeClient) DeleteFirewallPolicy6(mkey int) (err error) {
	delete(c.FirewallPolicy6s, mkey)
	return nil
}

// Action performed on traffic matching the policy (default = deny).
type FirewallLocalInPolicy6Action string

// Destination address object from available options.
type FirewallLocalInPolicy6Dstaddr struct {

	// Address name.
	Name string `json:"name,omitempty"`
}

// Service object from available options. Separate names with a space.
type FirewallLocalInPolicy6Service struct {

	// Service name.
	Name string `json:"name,omitempty"`
}

// Source address object from available options.
type FirewallLocalInPolicy6Srcaddr struct {

	// Address name.
	Name string `json:"name,omitempty"`
}

// Enable/disable this local-in policy.
type FirewallLocalInPolicy6Status string

const (
	// Allow local-in traffic matching this policy.
	FirewallLocalInPolicy6ActionAccept FirewallLocalInPolicy6Action = "accept"

	// Deny or block local-in traffic matching this policy.
	FirewallLocalInPolicy6ActionDeny FirewallLocalInPolicy6Action = "deny"
)

const (
	// Enable this local-in policy.
	FirewallLocalInPolicy6StatusEnable FirewallLocalInPolicy6Status = "enable"

	// Disable this local-in policy.
	FirewallLocalInPolicy6StatusDisable FirewallLocalInPolicy6Status = "disable"
)

// Configure user defined IPv6 local-in policies.
type FirewallLocalInPolicy6 struct {

	// Action performed on traffic matching the policy (default = deny).
	Action FirewallLocalInPolicy6Action `json:"action,omitempty"`

	// Destination address object from available options.
	Dstaddr []FirewallLocalInPolicy6Dstaddr `json:"dstaddr,omitempty"`

	// Incoming interface name from available options.
	Intf string `json:"intf,omitempty"`

	// User defined local in policy ID.
	Policyid int `json:"policyid,omitempty"`

	// Schedule object from available options.
	Schedule string `json:"schedule,omitempty"`

	// Service object from available options. Separate names with a space.
	Service []FirewallLocalInPolicy6Service `json:"service,omitempty"`

	// Source address object from available options.
	Srcaddr []FirewallLocalInPolicy6Srcaddr `json:"srcaddr,omitempty"`

	// Enable/disable this local-in policy.
	Status FirewallLocalInPolicy6Status `json:"status,omitempty"`
}

// Returns the value that identifies a FirewallLocalInPolicy6
func (x *FirewallLocalInPolicy6) MKey() int {
	return x.Policyid
}

// The results of a Get or List operation
type FirewallLocalInPolicy6Results struct {
	Results []*FirewallLocalInPolicy6 `json:"results"`
	Mkey    int                       `json:"mkey"`
	Result
}

// List all FirewallLocalInPolicy6s
func (c *WebClient) ListFirewallLocalInPolicy6s() (res []*FirewallLocalInPolicy6, err error) {
	var errmsg Result
	var results FirewallLocalInPolicy6Results
	_, err = c.napping.Get(c.URL+"/api/v2/firewall/local-in-policy6", nil, &results, nil)
	if err != nil {
		return []*FirewallLocalInPolicy6{}, fmt.Errorf("error listing FirewallLocalInPolicy6s: %s", err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return []*FirewallLocalInPolicy6{}, fmt.Errorf("error listing FirewallLocalInPolicy6: not found")
		} else {
			return []*FirewallLocalInPolicy6{}, fmt.Errorf("error listing FirewallLocalInPolicy6: %s", errmsg.Status)
		}
	}
	res = results.Results
	return
}

// Get a FirewallLocalInPolicy6 by name
func (c *WebClient) GetFirewallLocalInPolicy6(mkey int) (res *FirewallLocalInPolicy6, err error) {
	var errmsg Result
	var results FirewallLocalInPolicy6Results
	_, err = c.napping.Get(c.URL+"/api/v2/firewall/local-in-policy6/"+strconv.Itoa(mkey), nil, &results, &errmsg)
	if err != nil {
		return &FirewallLocalInPolicy6{}, fmt.Errorf("error getting FirewallLocalInPolicy6 '%s': %s", strconv.Itoa(mkey), err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return &FirewallLocalInPolicy6{}, fmt.Errorf("error getting FirewallLocalInPolicy6 '%s': not found", strconv.Itoa(mkey))
		} else {
			return &FirewallLocalInPolicy6{}, fmt.Errorf("error getting FirewallLocalInPolicy6 '%s': %s", strconv.Itoa(mkey), errmsg.Status)
		}
	}
	if len(results.Results) == 0 {
		return &FirewallLocalInPolicy6{}, fmt.Errorf("error getting FirewallLocalInPolicy6 '%s': not found", strconv.Itoa(mkey))
	}

	res = results.Results[0]
	return
}

// Create a new FirewallLocalInPolicy6
func (c *WebClient) CreateFirewallLocalInPolicy6(obj *FirewallLocalInPolicy6) (id int, err error) {
	var errmsg Result
	var results FirewallLocalInPolicy6Results
	_, err = c.napping.Post(c.URL+"/api/v2/firewall/local-in-policy6", obj, &results, &errmsg)
	if err != nil {
		return 0, fmt.Errorf("error creating FirewallLocalInPolicy6 '%s': %s", strconv.Itoa(obj.Policyid), err.Error())
	}
	if results.HTTPStatus == 200 {
		return
	}
	if errmsg.HTTPStatus != 200 {
		return 0, fmt.Errorf("error creating FirewallLocalInPolicy6 '%s': %s", strconv.Itoa(obj.Policyid), errmsg.Status)
	}

	return
}

// Update a FirewallLocalInPolicy6
func (c *WebClient) UpdateFirewallLocalInPolicy6(obj *FirewallLocalInPolicy6) (err error) {
	var errmsg Result
	var results FirewallLocalInPolicy6Results
	_, err = c.napping.Put(c.URL+"/api/v2/firewall/local-in-policy6/"+strconv.Itoa(obj.Policyid), obj, &results, &errmsg)
	if err != nil {
		return fmt.Errorf("error updating FirewallLocalInPolicy6 '%s': %s", strconv.Itoa(obj.Policyid), err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return fmt.Errorf("error updating FirewallLocalInPolicy6 '%s': not found", strconv.Itoa(obj.Policyid))
		} else {
			return fmt.Errorf("error updating FirewallLocalInPolicy6 '%s': %s", strconv.Itoa(obj.Policyid), errmsg.Status)
		}
	}

	return
}

// Delete a FirewallLocalInPolicy6 by name
func (c *WebClient) DeleteFirewallLocalInPolicy6(mkey int) (err error) {
	var errmsg Result
	var results FirewallLocalInPolicy6Results
	_, err = c.napping.Delete(c.URL+"/api/v2/firewall/local-in-policy6/"+strconv.Itoa(mkey), nil, &results, &errmsg)
	if err != nil {
		return fmt.Errorf("error deleting FirewallLocalInPolicy6 '%s': %s", mkey, err.Error())
	}
	if results.HTTPStatus == 200 {
		return
	}
	if errmsg.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return fmt.Errorf("error deleting FirewallLocalInPolicy6 '%s': not found", mkey)
		}
		return fmt.Errorf("error deleting FirewallLocalInPolicy6 '%s': %s", mkey, errmsg.Status)
	}

	return
}

// List all FirewallLocalInPolicy6s
func (c *FakeClient) ListFirewallLocalInPolicy6s() (res []*FirewallLocalInPolicy6, err error) {
	for _, r := range c.FirewallLocalInPolicy6s {
		res = append(res, r)
	}
	return
}

// Get a FirewallLocalInPolicy6 by name
func (c *FakeClient) GetFirewallLocalInPolicy6(mkey int) (*FirewallLocalInPolicy6, error) {
	if res, ok := c.FirewallLocalInPolicy6s[mkey]; ok {
		return res, nil
	} else {
		return &FirewallLocalInPolicy6{}, fmt.Errorf("error getting FirewallLocalInPolicy6 '%s': not found", strconv.Itoa(mkey))
	}
}

// Create a new FirewallLocalInPolicy6
func (c *FakeClient) CreateFirewallLocalInPolicy6(obj *FirewallLocalInPolicy6) (id int, err error) {
	id = c.FirewallLocalInPolicy6Counter
	c.FirewallLocalInPolicy6Counter++
	c.FirewallLocalInPolicy6s[id] = obj
	return
}

// Update a FirewallLocalInPolicy6
func (c *FakeClient) UpdateFirewallLocalInPolicy6(obj *FirewallLocalInPolicy6) (err error) {
	c.FirewallLocalInPolicy6s[obj.Policyid] = obj
	return nil
}

// Delete a FirewallLocalInPolicy6 by name
func (c *FakeClient) DeleteFirewallLocalInPolicy6(mkey int) (err error) {
	delete(c.FirewallLocalInPolicy6s, mkey)
	return nil
}

// Action to be performed on traffic matching this policy (default = deny).
type FirewallTtlPolicyAction string

// Service object(s) from available options. Separate multiple names with a space.
type FirewallTtlPolicyService struct {

	// Service name.
	Name string `json:"name,omitempty"`
}

// Source address object(s) from available options. Separate multiple names with a space.
type FirewallTtlPolicySrcaddr struct {

	// Address name.
	Name string `json:"name,omitempty"`
}

// Enable/disable this TTL policy.
type FirewallTtlPolicyStatus string

const (
	// Allow traffic matching this policy.
	FirewallTtlPolicyActionAccept FirewallTtlPolicyAction = "accept"

	// Deny or block traffic matching this policy.
	FirewallTtlPolicyActionDeny FirewallTtlPolicyAction = "deny"
)

const (
	// Enable this TTL policy.
	FirewallTtlPolicyStatusEnable FirewallTtlPolicyStatus = "enable"

	// Disable this TTL policy.
	FirewallTtlPolicyStatusDisable FirewallTtlPolicyStatus = "disable"
)

// Configure TTL policies.
type FirewallTtlPolicy struct {

	// Action to be performed on traffic matching this policy (default = deny).
	Action FirewallTtlPolicyAction `json:"action,omitempty"`

	// ID.
	Id int `json:"id,omitempty"`

	// Schedule object from available options.
	Schedule string `json:"schedule,omitempty"`

	// Service object(s) from available options. Separate multiple names with a space.
	Service []FirewallTtlPolicyService `json:"service,omitempty"`

	// Source address object(s) from available options. Separate multiple names with a space.
	Srcaddr []FirewallTtlPolicySrcaddr `json:"srcaddr,omitempty"`

	// Source interface name from available interfaces.
	Srcintf string `json:"srcintf,omitempty"`

	// Enable/disable this TTL policy.
	Status FirewallTtlPolicyStatus `json:"status,omitempty"`

	// Value/range to match against the packet's Time to Live value (format: ttl[ - ttl_high], 1 - 255).
	Ttl string `json:"ttl,omitempty"`
}

// Returns the value that identifies a FirewallTtlPolicy
func (x *FirewallTtlPolicy) MKey() int {
	return x.Id
}

// The results of a Get or List operation
type FirewallTtlPolicyResults struct {
	Results []*FirewallTtlPolicy `json:"results"`
	Mkey    int                  `json:"mkey"`
	Result
}

// List all FirewallTtlPolicys
func (c *WebClient) ListFirewallTtlPolicys() (res []*FirewallTtlPolicy, err error) {
	var errmsg Result
	var results FirewallTtlPolicyResults
	_, err = c.napping.Get(c.URL+"/api/v2/firewall/ttl-policy", nil, &results, nil)
	if err != nil {
		return []*FirewallTtlPolicy{}, fmt.Errorf("error listing FirewallTtlPolicys: %s", err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return []*FirewallTtlPolicy{}, fmt.Errorf("error listing FirewallTtlPolicy: not found")
		} else {
			return []*FirewallTtlPolicy{}, fmt.Errorf("error listing FirewallTtlPolicy: %s", errmsg.Status)
		}
	}
	res = results.Results
	return
}

// Get a FirewallTtlPolicy by name
func (c *WebClient) GetFirewallTtlPolicy(mkey int) (res *FirewallTtlPolicy, err error) {
	var errmsg Result
	var results FirewallTtlPolicyResults
	_, err = c.napping.Get(c.URL+"/api/v2/firewall/ttl-policy/"+strconv.Itoa(mkey), nil, &results, &errmsg)
	if err != nil {
		return &FirewallTtlPolicy{}, fmt.Errorf("error getting FirewallTtlPolicy '%s': %s", strconv.Itoa(mkey), err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return &FirewallTtlPolicy{}, fmt.Errorf("error getting FirewallTtlPolicy '%s': not found", strconv.Itoa(mkey))
		} else {
			return &FirewallTtlPolicy{}, fmt.Errorf("error getting FirewallTtlPolicy '%s': %s", strconv.Itoa(mkey), errmsg.Status)
		}
	}
	if len(results.Results) == 0 {
		return &FirewallTtlPolicy{}, fmt.Errorf("error getting FirewallTtlPolicy '%s': not found", strconv.Itoa(mkey))
	}

	res = results.Results[0]
	return
}

// Create a new FirewallTtlPolicy
func (c *WebClient) CreateFirewallTtlPolicy(obj *FirewallTtlPolicy) (id int, err error) {
	var errmsg Result
	var results FirewallTtlPolicyResults
	_, err = c.napping.Post(c.URL+"/api/v2/firewall/ttl-policy", obj, &results, &errmsg)
	if err != nil {
		return 0, fmt.Errorf("error creating FirewallTtlPolicy '%s': %s", strconv.Itoa(obj.Id), err.Error())
	}
	if results.HTTPStatus == 200 {
		return
	}
	if errmsg.HTTPStatus != 200 {
		return 0, fmt.Errorf("error creating FirewallTtlPolicy '%s': %s", strconv.Itoa(obj.Id), errmsg.Status)
	}

	return
}

// Update a FirewallTtlPolicy
func (c *WebClient) UpdateFirewallTtlPolicy(obj *FirewallTtlPolicy) (err error) {
	var errmsg Result
	var results FirewallTtlPolicyResults
	_, err = c.napping.Put(c.URL+"/api/v2/firewall/ttl-policy/"+strconv.Itoa(obj.Id), obj, &results, &errmsg)
	if err != nil {
		return fmt.Errorf("error updating FirewallTtlPolicy '%s': %s", strconv.Itoa(obj.Id), err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return fmt.Errorf("error updating FirewallTtlPolicy '%s': not found", strconv.Itoa(obj.Id))
		} else {
			return fmt.Errorf("error updating FirewallTtlPolicy '%s': %s", strconv.Itoa(obj.Id), errmsg.Status)
		}
	}

	return
}

// Delete a FirewallTtlPolicy by name
func (c *WebClient) DeleteFirewallTtlPolicy(mkey int) (err error) {
	var errmsg Result
	var results FirewallTtlPolicyResults
	_, err = c.napping.Delete(c.URL+"/api/v2/firewall/ttl-policy/"+strconv.Itoa(mkey), nil, &results, &errmsg)
	if err != nil {
		return fmt.Errorf("error deleting FirewallTtlPolicy '%s': %s", mkey, err.Error())
	}
	if results.HTTPStatus == 200 {
		return
	}
	if errmsg.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return fmt.Errorf("error deleting FirewallTtlPolicy '%s': not found", mkey)
		}
		return fmt.Errorf("error deleting FirewallTtlPolicy '%s': %s", mkey, errmsg.Status)
	}

	return
}

// List all FirewallTtlPolicys
func (c *FakeClient) ListFirewallTtlPolicys() (res []*FirewallTtlPolicy, err error) {
	for _, r := range c.FirewallTtlPolicys {
		res = append(res, r)
	}
	return
}

// Get a FirewallTtlPolicy by name
func (c *FakeClient) GetFirewallTtlPolicy(mkey int) (*FirewallTtlPolicy, error) {
	if res, ok := c.FirewallTtlPolicys[mkey]; ok {
		return res, nil
	} else {
		return &FirewallTtlPolicy{}, fmt.Errorf("error getting FirewallTtlPolicy '%s': not found", strconv.Itoa(mkey))
	}
}

// Create a new FirewallTtlPolicy
func (c *FakeClient) CreateFirewallTtlPolicy(obj *FirewallTtlPolicy) (id int, err error) {
	id = c.FirewallTtlPolicyCounter
	c.FirewallTtlPolicyCounter++
	c.FirewallTtlPolicys[id] = obj
	return
}

// Update a FirewallTtlPolicy
func (c *FakeClient) UpdateFirewallTtlPolicy(obj *FirewallTtlPolicy) (err error) {
	c.FirewallTtlPolicys[obj.Id] = obj
	return nil
}

// Delete a FirewallTtlPolicy by name
func (c *FakeClient) DeleteFirewallTtlPolicy(mkey int) (err error) {
	delete(c.FirewallTtlPolicys, mkey)
	return nil
}

// Policy action.
type FirewallPolicy64Action string

// Destination address name.
type FirewallPolicy64Dstaddr struct {

	// Address name.
	Name string `json:"name,omitempty"`
}

// Enable/disable policy fixed port.
type FirewallPolicy64Fixedport string

// Enable/disable policy64 IP pool.
type FirewallPolicy64Ippool string

// Enable/disable policy log traffic.
type FirewallPolicy64Logtraffic string

// Enable/disable permit any host in.
type FirewallPolicy64PermitAnyHost string

// Policy IP pool names.
type FirewallPolicy64Poolname struct {

	// IP pool name.
	Name string `json:"name,omitempty"`
}

// Service name.
type FirewallPolicy64Service struct {

	// Address name.
	Name string `json:"name,omitempty"`
}

// Source address name.
type FirewallPolicy64Srcaddr struct {

	// Address name.
	Name string `json:"name,omitempty"`
}

// Enable/disable policy status.
type FirewallPolicy64Status string

// Applied object tags.
type FirewallPolicy64Tags struct {

	// Tag name.
	Name string `json:"name,omitempty"`
}

const (
	// Action accept.
	FirewallPolicy64ActionAccept FirewallPolicy64Action = "accept"

	// Action deny.
	FirewallPolicy64ActionDeny FirewallPolicy64Action = "deny"
)

const (
	// Enable setting.
	FirewallPolicy64FixedportEnable FirewallPolicy64Fixedport = "enable"

	// Disable setting.
	FirewallPolicy64FixedportDisable FirewallPolicy64Fixedport = "disable"
)

const (
	// Enable setting.
	FirewallPolicy64IppoolEnable FirewallPolicy64Ippool = "enable"

	// Disable setting.
	FirewallPolicy64IppoolDisable FirewallPolicy64Ippool = "disable"
)

const (
	// Enable setting.
	FirewallPolicy64LogtrafficEnable FirewallPolicy64Logtraffic = "enable"

	// Disable setting.
	FirewallPolicy64LogtrafficDisable FirewallPolicy64Logtraffic = "disable"
)

const (
	// Enable setting.
	FirewallPolicy64PermitAnyHostEnable FirewallPolicy64PermitAnyHost = "enable"

	// Disable setting.
	FirewallPolicy64PermitAnyHostDisable FirewallPolicy64PermitAnyHost = "disable"
)

const (
	// Enable setting.
	FirewallPolicy64StatusEnable FirewallPolicy64Status = "enable"

	// Disable setting.
	FirewallPolicy64StatusDisable FirewallPolicy64Status = "disable"
)

// Configure IPv6 to IPv4 policies.
type FirewallPolicy64 struct {

	// Policy action.
	Action FirewallPolicy64Action `json:"action,omitempty"`

	// Comment.
	Comments string `json:"comments,omitempty"`

	// Destination address name.
	Dstaddr []FirewallPolicy64Dstaddr `json:"dstaddr,omitempty"`

	// Destination interface name.
	Dstintf string `json:"dstintf,omitempty"`

	// Enable/disable policy fixed port.
	Fixedport FirewallPolicy64Fixedport `json:"fixedport,omitempty"`

	// Enable/disable policy64 IP pool.
	Ippool FirewallPolicy64Ippool `json:"ippool,omitempty"`

	// Enable/disable policy log traffic.
	Logtraffic FirewallPolicy64Logtraffic `json:"logtraffic,omitempty"`

	// Per-IP traffic shaper.
	PerIpShaper string `json:"per-ip-shaper,omitempty"`

	// Enable/disable permit any host in.
	PermitAnyHost FirewallPolicy64PermitAnyHost `json:"permit-any-host,omitempty"`

	// Policy ID.
	Policyid int `json:"policyid,omitempty"`

	// Policy IP pool names.
	Poolname []FirewallPolicy64Poolname `json:"poolname,omitempty"`

	// Schedule name.
	Schedule string `json:"schedule,omitempty"`

	// Service name.
	Service []FirewallPolicy64Service `json:"service,omitempty"`

	// Source address name.
	Srcaddr []FirewallPolicy64Srcaddr `json:"srcaddr,omitempty"`

	// Source interface name.
	Srcintf string `json:"srcintf,omitempty"`

	// Enable/disable policy status.
	Status FirewallPolicy64Status `json:"status,omitempty"`

	// Applied object tags.
	Tags []FirewallPolicy64Tags `json:"tags,omitempty"`

	// TCP MSS value of receiver.
	TcpMssReceiver int `json:"tcp-mss-receiver,omitempty"`

	// TCP MSS value of sender.
	TcpMssSender int `json:"tcp-mss-sender,omitempty"`

	// Traffic shaper.
	TrafficShaper string `json:"traffic-shaper,omitempty"`

	// Reverse traffic shaper.
	TrafficShaperReverse string `json:"traffic-shaper-reverse,omitempty"`

	// Universally Unique Identifier (UUID; automatically assigned but can be manually reset).
	Uuid string `json:"uuid,omitempty"`
}

// Returns the value that identifies a FirewallPolicy64
func (x *FirewallPolicy64) MKey() int {
	return x.Policyid
}

// The results of a Get or List operation
type FirewallPolicy64Results struct {
	Results []*FirewallPolicy64 `json:"results"`
	Mkey    int                 `json:"mkey"`
	Result
}

// List all FirewallPolicy64s
func (c *WebClient) ListFirewallPolicy64s() (res []*FirewallPolicy64, err error) {
	var errmsg Result
	var results FirewallPolicy64Results
	_, err = c.napping.Get(c.URL+"/api/v2/firewall/policy64", nil, &results, nil)
	if err != nil {
		return []*FirewallPolicy64{}, fmt.Errorf("error listing FirewallPolicy64s: %s", err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return []*FirewallPolicy64{}, fmt.Errorf("error listing FirewallPolicy64: not found")
		} else {
			return []*FirewallPolicy64{}, fmt.Errorf("error listing FirewallPolicy64: %s", errmsg.Status)
		}
	}
	res = results.Results
	return
}

// Get a FirewallPolicy64 by name
func (c *WebClient) GetFirewallPolicy64(mkey int) (res *FirewallPolicy64, err error) {
	var errmsg Result
	var results FirewallPolicy64Results
	_, err = c.napping.Get(c.URL+"/api/v2/firewall/policy64/"+strconv.Itoa(mkey), nil, &results, &errmsg)
	if err != nil {
		return &FirewallPolicy64{}, fmt.Errorf("error getting FirewallPolicy64 '%s': %s", strconv.Itoa(mkey), err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return &FirewallPolicy64{}, fmt.Errorf("error getting FirewallPolicy64 '%s': not found", strconv.Itoa(mkey))
		} else {
			return &FirewallPolicy64{}, fmt.Errorf("error getting FirewallPolicy64 '%s': %s", strconv.Itoa(mkey), errmsg.Status)
		}
	}
	if len(results.Results) == 0 {
		return &FirewallPolicy64{}, fmt.Errorf("error getting FirewallPolicy64 '%s': not found", strconv.Itoa(mkey))
	}

	res = results.Results[0]
	return
}

// Create a new FirewallPolicy64
func (c *WebClient) CreateFirewallPolicy64(obj *FirewallPolicy64) (id int, err error) {
	var errmsg Result
	var results FirewallPolicy64Results
	_, err = c.napping.Post(c.URL+"/api/v2/firewall/policy64", obj, &results, &errmsg)
	if err != nil {
		return 0, fmt.Errorf("error creating FirewallPolicy64 '%s': %s", strconv.Itoa(obj.Policyid), err.Error())
	}
	if results.HTTPStatus == 200 {
		return
	}
	if errmsg.HTTPStatus != 200 {
		return 0, fmt.Errorf("error creating FirewallPolicy64 '%s': %s", strconv.Itoa(obj.Policyid), errmsg.Status)
	}

	return
}

// Update a FirewallPolicy64
func (c *WebClient) UpdateFirewallPolicy64(obj *FirewallPolicy64) (err error) {
	var errmsg Result
	var results FirewallPolicy64Results
	_, err = c.napping.Put(c.URL+"/api/v2/firewall/policy64/"+strconv.Itoa(obj.Policyid), obj, &results, &errmsg)
	if err != nil {
		return fmt.Errorf("error updating FirewallPolicy64 '%s': %s", strconv.Itoa(obj.Policyid), err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return fmt.Errorf("error updating FirewallPolicy64 '%s': not found", strconv.Itoa(obj.Policyid))
		} else {
			return fmt.Errorf("error updating FirewallPolicy64 '%s': %s", strconv.Itoa(obj.Policyid), errmsg.Status)
		}
	}

	return
}

// Delete a FirewallPolicy64 by name
func (c *WebClient) DeleteFirewallPolicy64(mkey int) (err error) {
	var errmsg Result
	var results FirewallPolicy64Results
	_, err = c.napping.Delete(c.URL+"/api/v2/firewall/policy64/"+strconv.Itoa(mkey), nil, &results, &errmsg)
	if err != nil {
		return fmt.Errorf("error deleting FirewallPolicy64 '%s': %s", mkey, err.Error())
	}
	if results.HTTPStatus == 200 {
		return
	}
	if errmsg.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return fmt.Errorf("error deleting FirewallPolicy64 '%s': not found", mkey)
		}
		return fmt.Errorf("error deleting FirewallPolicy64 '%s': %s", mkey, errmsg.Status)
	}

	return
}

// List all FirewallPolicy64s
func (c *FakeClient) ListFirewallPolicy64s() (res []*FirewallPolicy64, err error) {
	for _, r := range c.FirewallPolicy64s {
		res = append(res, r)
	}
	return
}

// Get a FirewallPolicy64 by name
func (c *FakeClient) GetFirewallPolicy64(mkey int) (*FirewallPolicy64, error) {
	if res, ok := c.FirewallPolicy64s[mkey]; ok {
		return res, nil
	} else {
		return &FirewallPolicy64{}, fmt.Errorf("error getting FirewallPolicy64 '%s': not found", strconv.Itoa(mkey))
	}
}

// Create a new FirewallPolicy64
func (c *FakeClient) CreateFirewallPolicy64(obj *FirewallPolicy64) (id int, err error) {
	id = c.FirewallPolicy64Counter
	c.FirewallPolicy64Counter++
	c.FirewallPolicy64s[id] = obj
	return
}

// Update a FirewallPolicy64
func (c *FakeClient) UpdateFirewallPolicy64(obj *FirewallPolicy64) (err error) {
	c.FirewallPolicy64s[obj.Policyid] = obj
	return nil
}

// Delete a FirewallPolicy64 by name
func (c *FakeClient) DeleteFirewallPolicy64(mkey int) (err error) {
	delete(c.FirewallPolicy64s, mkey)
	return nil
}

// Accept or deny traffic matching the policy.
type FirewallPolicy46Action string

// Destination address objects.
type FirewallPolicy46Dstaddr struct {

	// Address name.
	Name string `json:"name,omitempty"`
}

// Enable/disable fixed port for this policy.
type FirewallPolicy46Fixedport string

// Enable/disable traffic logging for this policy.
type FirewallPolicy46Logtraffic string

// Enable/disable allowing any host.
type FirewallPolicy46PermitAnyHost string

// Service name.
type FirewallPolicy46Service struct {

	// Service name.
	Name string `json:"name,omitempty"`
}

// Source address objects.
type FirewallPolicy46Srcaddr struct {

	// Address name.
	Name string `json:"name,omitempty"`
}

// Enable/disable this policy.
type FirewallPolicy46Status string

// Applied object tags.
type FirewallPolicy46Tags struct {

	// Names of object-tags (as configured in config system object-tag) applied to address.
	Name string `json:"name,omitempty"`
}

const (
	// Accept matching traffic.
	FirewallPolicy46ActionAccept FirewallPolicy46Action = "accept"

	// Deny matching traffic.
	FirewallPolicy46ActionDeny FirewallPolicy46Action = "deny"
)

const (
	// Enable fixed port for this policy.
	FirewallPolicy46FixedportEnable FirewallPolicy46Fixedport = "enable"

	// Disable fixed port for this policy.
	FirewallPolicy46FixedportDisable FirewallPolicy46Fixedport = "disable"
)

const (
	// Enable traffic logging.
	FirewallPolicy46LogtrafficEnable FirewallPolicy46Logtraffic = "enable"

	// Disable traffic logging.
	FirewallPolicy46LogtrafficDisable FirewallPolicy46Logtraffic = "disable"
)

const (
	// Allow any host.
	FirewallPolicy46PermitAnyHostEnable FirewallPolicy46PermitAnyHost = "enable"

	// Do not allow any host.
	FirewallPolicy46PermitAnyHostDisable FirewallPolicy46PermitAnyHost = "disable"
)

const (
	// Enable this policy.
	FirewallPolicy46StatusEnable FirewallPolicy46Status = "enable"

	// Disable this policy.
	FirewallPolicy46StatusDisable FirewallPolicy46Status = "disable"
)

// Configure IPv4 to IPv6 policies.
type FirewallPolicy46 struct {

	// Accept or deny traffic matching the policy.
	Action FirewallPolicy46Action `json:"action,omitempty"`

	// Comment.
	Comments string `json:"comments,omitempty"`

	// Destination address objects.
	Dstaddr []FirewallPolicy46Dstaddr `json:"dstaddr,omitempty"`

	// Destination interface name.
	Dstintf string `json:"dstintf,omitempty"`

	// Enable/disable fixed port for this policy.
	Fixedport FirewallPolicy46Fixedport `json:"fixedport,omitempty"`

	// Enable/disable traffic logging for this policy.
	Logtraffic FirewallPolicy46Logtraffic `json:"logtraffic,omitempty"`

	// Per IP traffic shaper.
	PerIpShaper string `json:"per-ip-shaper,omitempty"`

	// Enable/disable allowing any host.
	PermitAnyHost FirewallPolicy46PermitAnyHost `json:"permit-any-host,omitempty"`

	// Policy ID.
	Policyid int `json:"policyid,omitempty"`

	// Schedule name.
	Schedule string `json:"schedule,omitempty"`

	// Service name.
	Service []FirewallPolicy46Service `json:"service,omitempty"`

	// Source address objects.
	Srcaddr []FirewallPolicy46Srcaddr `json:"srcaddr,omitempty"`

	// Source interface name.
	Srcintf string `json:"srcintf,omitempty"`

	// Enable/disable this policy.
	Status FirewallPolicy46Status `json:"status,omitempty"`

	// Applied object tags.
	Tags []FirewallPolicy46Tags `json:"tags,omitempty"`

	// TCP Maximum Segment Size value of receiver (0 - 65535, default = 0)
	TcpMssReceiver int `json:"tcp-mss-receiver,omitempty"`

	// TCP Maximum Segment Size value of sender (0 - 65535, default = 0).
	TcpMssSender int `json:"tcp-mss-sender,omitempty"`

	// Traffic shaper.
	TrafficShaper string `json:"traffic-shaper,omitempty"`

	// Reverse traffic shaper.
	TrafficShaperReverse string `json:"traffic-shaper-reverse,omitempty"`

	// Universally Unique Identifier (UUID; automatically assigned but can be manually reset).
	Uuid string `json:"uuid,omitempty"`
}

// Returns the value that identifies a FirewallPolicy46
func (x *FirewallPolicy46) MKey() int {
	return x.Policyid
}

// The results of a Get or List operation
type FirewallPolicy46Results struct {
	Results []*FirewallPolicy46 `json:"results"`
	Mkey    int                 `json:"mkey"`
	Result
}

// List all FirewallPolicy46s
func (c *WebClient) ListFirewallPolicy46s() (res []*FirewallPolicy46, err error) {
	var errmsg Result
	var results FirewallPolicy46Results
	_, err = c.napping.Get(c.URL+"/api/v2/firewall/policy46", nil, &results, nil)
	if err != nil {
		return []*FirewallPolicy46{}, fmt.Errorf("error listing FirewallPolicy46s: %s", err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return []*FirewallPolicy46{}, fmt.Errorf("error listing FirewallPolicy46: not found")
		} else {
			return []*FirewallPolicy46{}, fmt.Errorf("error listing FirewallPolicy46: %s", errmsg.Status)
		}
	}
	res = results.Results
	return
}

// Get a FirewallPolicy46 by name
func (c *WebClient) GetFirewallPolicy46(mkey int) (res *FirewallPolicy46, err error) {
	var errmsg Result
	var results FirewallPolicy46Results
	_, err = c.napping.Get(c.URL+"/api/v2/firewall/policy46/"+strconv.Itoa(mkey), nil, &results, &errmsg)
	if err != nil {
		return &FirewallPolicy46{}, fmt.Errorf("error getting FirewallPolicy46 '%s': %s", strconv.Itoa(mkey), err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return &FirewallPolicy46{}, fmt.Errorf("error getting FirewallPolicy46 '%s': not found", strconv.Itoa(mkey))
		} else {
			return &FirewallPolicy46{}, fmt.Errorf("error getting FirewallPolicy46 '%s': %s", strconv.Itoa(mkey), errmsg.Status)
		}
	}
	if len(results.Results) == 0 {
		return &FirewallPolicy46{}, fmt.Errorf("error getting FirewallPolicy46 '%s': not found", strconv.Itoa(mkey))
	}

	res = results.Results[0]
	return
}

// Create a new FirewallPolicy46
func (c *WebClient) CreateFirewallPolicy46(obj *FirewallPolicy46) (id int, err error) {
	var errmsg Result
	var results FirewallPolicy46Results
	_, err = c.napping.Post(c.URL+"/api/v2/firewall/policy46", obj, &results, &errmsg)
	if err != nil {
		return 0, fmt.Errorf("error creating FirewallPolicy46 '%s': %s", strconv.Itoa(obj.Policyid), err.Error())
	}
	if results.HTTPStatus == 200 {
		return
	}
	if errmsg.HTTPStatus != 200 {
		return 0, fmt.Errorf("error creating FirewallPolicy46 '%s': %s", strconv.Itoa(obj.Policyid), errmsg.Status)
	}

	return
}

// Update a FirewallPolicy46
func (c *WebClient) UpdateFirewallPolicy46(obj *FirewallPolicy46) (err error) {
	var errmsg Result
	var results FirewallPolicy46Results
	_, err = c.napping.Put(c.URL+"/api/v2/firewall/policy46/"+strconv.Itoa(obj.Policyid), obj, &results, &errmsg)
	if err != nil {
		return fmt.Errorf("error updating FirewallPolicy46 '%s': %s", strconv.Itoa(obj.Policyid), err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return fmt.Errorf("error updating FirewallPolicy46 '%s': not found", strconv.Itoa(obj.Policyid))
		} else {
			return fmt.Errorf("error updating FirewallPolicy46 '%s': %s", strconv.Itoa(obj.Policyid), errmsg.Status)
		}
	}

	return
}

// Delete a FirewallPolicy46 by name
func (c *WebClient) DeleteFirewallPolicy46(mkey int) (err error) {
	var errmsg Result
	var results FirewallPolicy46Results
	_, err = c.napping.Delete(c.URL+"/api/v2/firewall/policy46/"+strconv.Itoa(mkey), nil, &results, &errmsg)
	if err != nil {
		return fmt.Errorf("error deleting FirewallPolicy46 '%s': %s", mkey, err.Error())
	}
	if results.HTTPStatus == 200 {
		return
	}
	if errmsg.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return fmt.Errorf("error deleting FirewallPolicy46 '%s': not found", mkey)
		}
		return fmt.Errorf("error deleting FirewallPolicy46 '%s': %s", mkey, errmsg.Status)
	}

	return
}

// List all FirewallPolicy46s
func (c *FakeClient) ListFirewallPolicy46s() (res []*FirewallPolicy46, err error) {
	for _, r := range c.FirewallPolicy46s {
		res = append(res, r)
	}
	return
}

// Get a FirewallPolicy46 by name
func (c *FakeClient) GetFirewallPolicy46(mkey int) (*FirewallPolicy46, error) {
	if res, ok := c.FirewallPolicy46s[mkey]; ok {
		return res, nil
	} else {
		return &FirewallPolicy46{}, fmt.Errorf("error getting FirewallPolicy46 '%s': not found", strconv.Itoa(mkey))
	}
}

// Create a new FirewallPolicy46
func (c *FakeClient) CreateFirewallPolicy46(obj *FirewallPolicy46) (id int, err error) {
	id = c.FirewallPolicy46Counter
	c.FirewallPolicy46Counter++
	c.FirewallPolicy46s[id] = obj
	return
}

// Update a FirewallPolicy46
func (c *FakeClient) UpdateFirewallPolicy46(obj *FirewallPolicy46) (err error) {
	c.FirewallPolicy46s[obj.Policyid] = obj
	return nil
}

// Delete a FirewallPolicy46 by name
func (c *FakeClient) DeleteFirewallPolicy46(mkey int) (err error) {
	delete(c.FirewallPolicy46s, mkey)
	return nil
}

// Enable to make the pattern case sensitive.
type FirewallProxyAddressCaseSensitivity string

// FortiGuard category ID.
type FirewallProxyAddressCategory struct {

	// Fortiguard category id.
	Id int `json:"id,omitempty"`
}

// HTTP header group.
type FirewallProxyAddressHeaderGroup struct {

	// Case sensitivity in pattern.
	CaseSensitivity string `json:"case-sensitivity,omitempty"`

	// HTTP header regular expression.
	Header string `json:"header,omitempty"`

	// HTTP header.
	HeaderName string `json:"header-name,omitempty"`

	// ID.
	Id int `json:"id,omitempty"`
}

// HTTP request methods to be used.
type FirewallProxyAddressMethod string

// Enable/disable use of referrer field in the HTTP header to match the address.
type FirewallProxyAddressReferrer string

// Names of object-tags (as configured in config system object-tag) applied to address.
type FirewallProxyAddressTags struct {

	// Tag name.
	Name string `json:"name,omitempty"`
}

// Proxy address type.
type FirewallProxyAddressType string

// Names of browsers to be used as user agent.
type FirewallProxyAddressUa string

// Enable/disable visibility of the object in the GUI.
type FirewallProxyAddressVisibility string

const (
	// Case insensitive in pattern.
	FirewallProxyAddressCaseSensitivityDisable FirewallProxyAddressCaseSensitivity = "disable"

	// Case sensitive in pattern.
	FirewallProxyAddressCaseSensitivityEnable FirewallProxyAddressCaseSensitivity = "enable"
)

const (
	// GET method.
	FirewallProxyAddressMethodGet FirewallProxyAddressMethod = "get"

	// POST method.
	FirewallProxyAddressMethodPost FirewallProxyAddressMethod = "post"

	// PUT method.
	FirewallProxyAddressMethodPut FirewallProxyAddressMethod = "put"

	// HEAD method.
	FirewallProxyAddressMethodHead FirewallProxyAddressMethod = "head"

	// CONNECT method.
	FirewallProxyAddressMethodConnect FirewallProxyAddressMethod = "connect"

	// TRACE method.
	FirewallProxyAddressMethodTrace FirewallProxyAddressMethod = "trace"

	// OPTIONS method.
	FirewallProxyAddressMethodOptions FirewallProxyAddressMethod = "options"

	// DELETE method.
	FirewallProxyAddressMethodDelete FirewallProxyAddressMethod = "delete"
)

const (
	// Enable setting.
	FirewallProxyAddressReferrerEnable FirewallProxyAddressReferrer = "enable"

	// Disable setting.
	FirewallProxyAddressReferrerDisable FirewallProxyAddressReferrer = "disable"
)

const (
	// Host regular expression.
	FirewallProxyAddressTypeHostRegex FirewallProxyAddressType = "host-regex"

	// HTTP URL.
	FirewallProxyAddressTypeUrl FirewallProxyAddressType = "url"

	// FortiGuard URL catgegory.
	FirewallProxyAddressTypeCategory FirewallProxyAddressType = "category"

	// HTTP request method.
	FirewallProxyAddressTypeMethod FirewallProxyAddressType = "method"

	// HTTP request user agent.
	FirewallProxyAddressTypeUa FirewallProxyAddressType = "ua"

	// HTTP request header.
	FirewallProxyAddressTypeHeader FirewallProxyAddressType = "header"

	// HTTP advanced source criteria.
	FirewallProxyAddressTypeSrcAdvanced FirewallProxyAddressType = "src-advanced"

	// HTTP advanced destination criteria.
	FirewallProxyAddressTypeDstAdvanced FirewallProxyAddressType = "dst-advanced"
)

const (
	// Google Chrome.
	FirewallProxyAddressUaChrome FirewallProxyAddressUa = "chrome"

	// Microsoft Internet Explorer or EDGE.
	FirewallProxyAddressUaMs FirewallProxyAddressUa = "ms"

	// Mozilla Firefox.
	FirewallProxyAddressUaFirefox FirewallProxyAddressUa = "firefox"

	// Apple Safari.
	FirewallProxyAddressUaSafari FirewallProxyAddressUa = "safari"

	// Other browsers.
	FirewallProxyAddressUaOther FirewallProxyAddressUa = "other"
)

const (
	// Enable setting.
	FirewallProxyAddressVisibilityEnable FirewallProxyAddressVisibility = "enable"

	// Disable setting.
	FirewallProxyAddressVisibilityDisable FirewallProxyAddressVisibility = "disable"
)

// Web proxy address configuration.
type FirewallProxyAddress struct {

	// Enable to make the pattern case sensitive.
	CaseSensitivity FirewallProxyAddressCaseSensitivity `json:"case-sensitivity,omitempty"`

	// FortiGuard category ID.
	Category []FirewallProxyAddressCategory `json:"category,omitempty"`

	// Integer value to determine the color of the icon in the GUI (1 - 32, default = 0, which sets value to 1).
	Color int `json:"color,omitempty"`

	// Optional comments.
	Comment string `json:"comment,omitempty"`

	// HTTP header name as a regular expression.
	Header string `json:"header,omitempty"`

	// HTTP header group.
	HeaderGroup []FirewallProxyAddressHeaderGroup `json:"header-group,omitempty"`

	// Name of HTTP header.
	HeaderName string `json:"header-name,omitempty"`

	// Address object for the host.
	Host string `json:"host,omitempty"`

	// Host name as a regular expression.
	HostRegex string `json:"host-regex,omitempty"`

	// HTTP request methods to be used.
	Method FirewallProxyAddressMethod `json:"method,omitempty"`

	// Address name.
	Name string `json:"name,omitempty"`

	// URL path as a regular expression.
	Path string `json:"path,omitempty"`

	// Match the query part of the URL as a regular expression.
	Query string `json:"query,omitempty"`

	// Enable/disable use of referrer field in the HTTP header to match the address.
	Referrer FirewallProxyAddressReferrer `json:"referrer,omitempty"`

	// Names of object-tags (as configured in config system object-tag) applied to address.
	Tags []FirewallProxyAddressTags `json:"tags,omitempty"`

	// Proxy address type.
	Type FirewallProxyAddressType `json:"type,omitempty"`

	// Names of browsers to be used as user agent.
	Ua FirewallProxyAddressUa `json:"ua,omitempty"`

	// Universally Unique Identifier (UUID; automatically assigned but can be manually reset).
	Uuid string `json:"uuid,omitempty"`

	// Enable/disable visibility of the object in the GUI.
	Visibility FirewallProxyAddressVisibility `json:"visibility,omitempty"`
}

// Returns the value that identifies a FirewallProxyAddress
func (x *FirewallProxyAddress) MKey() string {
	return x.Name
}

// The results of a Get or List operation
type FirewallProxyAddressResults struct {
	Results []*FirewallProxyAddress `json:"results"`
	Mkey    string                  `json:"mkey"`
	Result
}

// List all FirewallProxyAddresss
func (c *WebClient) ListFirewallProxyAddresss() (res []*FirewallProxyAddress, err error) {
	var errmsg Result
	var results FirewallProxyAddressResults
	_, err = c.napping.Get(c.URL+"/api/v2/firewall/proxy-address", nil, &results, nil)
	if err != nil {
		return []*FirewallProxyAddress{}, fmt.Errorf("error listing FirewallProxyAddresss: %s", err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return []*FirewallProxyAddress{}, fmt.Errorf("error listing FirewallProxyAddress: not found")
		} else {
			return []*FirewallProxyAddress{}, fmt.Errorf("error listing FirewallProxyAddress: %s", errmsg.Status)
		}
	}
	res = results.Results
	return
}

// Get a FirewallProxyAddress by name
func (c *WebClient) GetFirewallProxyAddress(mkey string) (res *FirewallProxyAddress, err error) {
	var errmsg Result
	var results FirewallProxyAddressResults
	_, err = c.napping.Get(c.URL+"/api/v2/firewall/proxy-address/"+mkey, nil, &results, &errmsg)
	if err != nil {
		return &FirewallProxyAddress{}, fmt.Errorf("error getting FirewallProxyAddress '%s': %s", mkey, err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return &FirewallProxyAddress{}, fmt.Errorf("error getting FirewallProxyAddress '%s': not found", mkey)
		} else {
			return &FirewallProxyAddress{}, fmt.Errorf("error getting FirewallProxyAddress '%s': %s", mkey, errmsg.Status)
		}
	}
	if len(results.Results) == 0 {
		return &FirewallProxyAddress{}, fmt.Errorf("error getting FirewallProxyAddress '%s': not found", mkey)
	}

	res = results.Results[0]
	return
}

// Create a new FirewallProxyAddress
func (c *WebClient) CreateFirewallProxyAddress(obj *FirewallProxyAddress) (id string, err error) {
	var errmsg Result
	var results FirewallProxyAddressResults
	_, err = c.napping.Post(c.URL+"/api/v2/firewall/proxy-address", obj, &results, &errmsg)
	if err != nil {
		return "", fmt.Errorf("error creating FirewallProxyAddress '%s': %s", obj.Name, err.Error())
	}
	if results.HTTPStatus == 200 {
		return
	}
	if errmsg.HTTPStatus != 200 {
		return "", fmt.Errorf("error creating FirewallProxyAddress '%s': %s", obj.Name, errmsg.Status)
	}

	return
}

// Update a FirewallProxyAddress
func (c *WebClient) UpdateFirewallProxyAddress(obj *FirewallProxyAddress) (err error) {
	var errmsg Result
	var results FirewallProxyAddressResults
	_, err = c.napping.Put(c.URL+"/api/v2/firewall/proxy-address/"+obj.Name, obj, &results, &errmsg)
	if err != nil {
		return fmt.Errorf("error updating FirewallProxyAddress '%s': %s", obj.Name, err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return fmt.Errorf("error updating FirewallProxyAddress '%s': not found", obj.Name)
		} else {
			return fmt.Errorf("error updating FirewallProxyAddress '%s': %s", obj.Name, errmsg.Status)
		}
	}

	return
}

// Delete a FirewallProxyAddress by name
func (c *WebClient) DeleteFirewallProxyAddress(mkey string) (err error) {
	var errmsg Result
	var results FirewallProxyAddressResults
	_, err = c.napping.Delete(c.URL+"/api/v2/firewall/proxy-address/"+mkey, nil, &results, &errmsg)
	if err != nil {
		return fmt.Errorf("error deleting FirewallProxyAddress '%s': %s", mkey, err.Error())
	}
	if results.HTTPStatus == 200 {
		return
	}
	if errmsg.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return fmt.Errorf("error deleting FirewallProxyAddress '%s': not found", mkey)
		}
		return fmt.Errorf("error deleting FirewallProxyAddress '%s': %s", mkey, errmsg.Status)
	}

	return
}

// List all FirewallProxyAddresss
func (c *FakeClient) ListFirewallProxyAddresss() (res []*FirewallProxyAddress, err error) {
	for _, r := range c.FirewallProxyAddresss {
		res = append(res, r)
	}
	return
}

// Get a FirewallProxyAddress by name
func (c *FakeClient) GetFirewallProxyAddress(mkey string) (*FirewallProxyAddress, error) {
	if res, ok := c.FirewallProxyAddresss[mkey]; ok {
		return res, nil
	} else {
		return &FirewallProxyAddress{}, fmt.Errorf("error getting FirewallProxyAddress '%s': not found", mkey)
	}
}

// Create a new FirewallProxyAddress
func (c *FakeClient) CreateFirewallProxyAddress(obj *FirewallProxyAddress) (id string, err error) {
	id = obj.Name
	c.FirewallProxyAddresss[id] = obj
	return
}

// Update a FirewallProxyAddress
func (c *FakeClient) UpdateFirewallProxyAddress(obj *FirewallProxyAddress) (err error) {
	c.FirewallProxyAddresss[obj.Name] = obj
	return nil
}

// Delete a FirewallProxyAddress by name
func (c *FakeClient) DeleteFirewallProxyAddress(mkey string) (err error) {
	delete(c.FirewallProxyAddresss, mkey)
	return nil
}

// Members of address group.
type FirewallProxyAddrgrpMember struct {

	// Address name.
	Name string `json:"name,omitempty"`
}

// Names of object-tags (as configured in config system object-tag) applied to address.
type FirewallProxyAddrgrpTags struct {

	// Tag name.
	Name string `json:"name,omitempty"`
}

// Source or destination address group type.
type FirewallProxyAddrgrpType string

// Enable/disable visibility of the object in the GUI.
type FirewallProxyAddrgrpVisibility string

const (
	// Source group.
	FirewallProxyAddrgrpTypeSrc FirewallProxyAddrgrpType = "src"

	// Destination group.
	FirewallProxyAddrgrpTypeDst FirewallProxyAddrgrpType = "dst"
)

const (
	// Enable setting.
	FirewallProxyAddrgrpVisibilityEnable FirewallProxyAddrgrpVisibility = "enable"

	// Disable setting.
	FirewallProxyAddrgrpVisibilityDisable FirewallProxyAddrgrpVisibility = "disable"
)

// Web proxy address group configuration.
type FirewallProxyAddrgrp struct {

	// Integer value to determine the color of the icon in the GUI (1 - 32, default = 0, which sets value to 1).
	Color int `json:"color,omitempty"`

	// Optional comments.
	Comment string `json:"comment,omitempty"`

	// Members of address group.
	Member []FirewallProxyAddrgrpMember `json:"member,omitempty"`

	// Address group name.
	Name string `json:"name,omitempty"`

	// Names of object-tags (as configured in config system object-tag) applied to address.
	Tags []FirewallProxyAddrgrpTags `json:"tags,omitempty"`

	// Source or destination address group type.
	Type FirewallProxyAddrgrpType `json:"type,omitempty"`

	// Universally Unique Identifier (UUID; automatically assigned but can be manually reset).
	Uuid string `json:"uuid,omitempty"`

	// Enable/disable visibility of the object in the GUI.
	Visibility FirewallProxyAddrgrpVisibility `json:"visibility,omitempty"`
}

// Returns the value that identifies a FirewallProxyAddrgrp
func (x *FirewallProxyAddrgrp) MKey() string {
	return x.Name
}

// The results of a Get or List operation
type FirewallProxyAddrgrpResults struct {
	Results []*FirewallProxyAddrgrp `json:"results"`
	Mkey    string                  `json:"mkey"`
	Result
}

// List all FirewallProxyAddrgrps
func (c *WebClient) ListFirewallProxyAddrgrps() (res []*FirewallProxyAddrgrp, err error) {
	var errmsg Result
	var results FirewallProxyAddrgrpResults
	_, err = c.napping.Get(c.URL+"/api/v2/firewall/proxy-addrgrp", nil, &results, nil)
	if err != nil {
		return []*FirewallProxyAddrgrp{}, fmt.Errorf("error listing FirewallProxyAddrgrps: %s", err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return []*FirewallProxyAddrgrp{}, fmt.Errorf("error listing FirewallProxyAddrgrp: not found")
		} else {
			return []*FirewallProxyAddrgrp{}, fmt.Errorf("error listing FirewallProxyAddrgrp: %s", errmsg.Status)
		}
	}
	res = results.Results
	return
}

// Get a FirewallProxyAddrgrp by name
func (c *WebClient) GetFirewallProxyAddrgrp(mkey string) (res *FirewallProxyAddrgrp, err error) {
	var errmsg Result
	var results FirewallProxyAddrgrpResults
	_, err = c.napping.Get(c.URL+"/api/v2/firewall/proxy-addrgrp/"+mkey, nil, &results, &errmsg)
	if err != nil {
		return &FirewallProxyAddrgrp{}, fmt.Errorf("error getting FirewallProxyAddrgrp '%s': %s", mkey, err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return &FirewallProxyAddrgrp{}, fmt.Errorf("error getting FirewallProxyAddrgrp '%s': not found", mkey)
		} else {
			return &FirewallProxyAddrgrp{}, fmt.Errorf("error getting FirewallProxyAddrgrp '%s': %s", mkey, errmsg.Status)
		}
	}
	if len(results.Results) == 0 {
		return &FirewallProxyAddrgrp{}, fmt.Errorf("error getting FirewallProxyAddrgrp '%s': not found", mkey)
	}

	res = results.Results[0]
	return
}

// Create a new FirewallProxyAddrgrp
func (c *WebClient) CreateFirewallProxyAddrgrp(obj *FirewallProxyAddrgrp) (id string, err error) {
	var errmsg Result
	var results FirewallProxyAddrgrpResults
	_, err = c.napping.Post(c.URL+"/api/v2/firewall/proxy-addrgrp", obj, &results, &errmsg)
	if err != nil {
		return "", fmt.Errorf("error creating FirewallProxyAddrgrp '%s': %s", obj.Name, err.Error())
	}
	if results.HTTPStatus == 200 {
		return
	}
	if errmsg.HTTPStatus != 200 {
		return "", fmt.Errorf("error creating FirewallProxyAddrgrp '%s': %s", obj.Name, errmsg.Status)
	}

	return
}

// Update a FirewallProxyAddrgrp
func (c *WebClient) UpdateFirewallProxyAddrgrp(obj *FirewallProxyAddrgrp) (err error) {
	var errmsg Result
	var results FirewallProxyAddrgrpResults
	_, err = c.napping.Put(c.URL+"/api/v2/firewall/proxy-addrgrp/"+obj.Name, obj, &results, &errmsg)
	if err != nil {
		return fmt.Errorf("error updating FirewallProxyAddrgrp '%s': %s", obj.Name, err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return fmt.Errorf("error updating FirewallProxyAddrgrp '%s': not found", obj.Name)
		} else {
			return fmt.Errorf("error updating FirewallProxyAddrgrp '%s': %s", obj.Name, errmsg.Status)
		}
	}

	return
}

// Delete a FirewallProxyAddrgrp by name
func (c *WebClient) DeleteFirewallProxyAddrgrp(mkey string) (err error) {
	var errmsg Result
	var results FirewallProxyAddrgrpResults
	_, err = c.napping.Delete(c.URL+"/api/v2/firewall/proxy-addrgrp/"+mkey, nil, &results, &errmsg)
	if err != nil {
		return fmt.Errorf("error deleting FirewallProxyAddrgrp '%s': %s", mkey, err.Error())
	}
	if results.HTTPStatus == 200 {
		return
	}
	if errmsg.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return fmt.Errorf("error deleting FirewallProxyAddrgrp '%s': not found", mkey)
		}
		return fmt.Errorf("error deleting FirewallProxyAddrgrp '%s': %s", mkey, errmsg.Status)
	}

	return
}

// List all FirewallProxyAddrgrps
func (c *FakeClient) ListFirewallProxyAddrgrps() (res []*FirewallProxyAddrgrp, err error) {
	for _, r := range c.FirewallProxyAddrgrps {
		res = append(res, r)
	}
	return
}

// Get a FirewallProxyAddrgrp by name
func (c *FakeClient) GetFirewallProxyAddrgrp(mkey string) (*FirewallProxyAddrgrp, error) {
	if res, ok := c.FirewallProxyAddrgrps[mkey]; ok {
		return res, nil
	} else {
		return &FirewallProxyAddrgrp{}, fmt.Errorf("error getting FirewallProxyAddrgrp '%s': not found", mkey)
	}
}

// Create a new FirewallProxyAddrgrp
func (c *FakeClient) CreateFirewallProxyAddrgrp(obj *FirewallProxyAddrgrp) (id string, err error) {
	id = obj.Name
	c.FirewallProxyAddrgrps[id] = obj
	return
}

// Update a FirewallProxyAddrgrp
func (c *FakeClient) UpdateFirewallProxyAddrgrp(obj *FirewallProxyAddrgrp) (err error) {
	c.FirewallProxyAddrgrps[obj.Name] = obj
	return nil
}

// Delete a FirewallProxyAddrgrp by name
func (c *FakeClient) DeleteFirewallProxyAddrgrp(mkey string) (err error) {
	delete(c.FirewallProxyAddrgrps, mkey)
	return nil
}

// Accept or deny traffic matching the policy parameters.
type FirewallProxyPolicyAction string

// Web proxy disclaimer setting: by domain, policy, or user.
type FirewallProxyPolicyDisclaimer string

// Destination address objects.
type FirewallProxyPolicyDstaddr struct {

	// Address name.
	Name string `json:"name,omitempty"`
}

// When enabled, destination addresses match against any address EXCEPT the specified destination addresses.
type FirewallProxyPolicyDstaddrNegate string

// IPv6 destination address objects.
type FirewallProxyPolicyDstaddr6 struct {

	// Address name.
	Name string `json:"name,omitempty"`
}

// Destination interface names.
type FirewallProxyPolicyDstintf struct {

	// Interface name.
	Name string `json:"name,omitempty"`
}

// Names of group objects.
type FirewallProxyPolicyGroups struct {

	// Group name.
	Name string `json:"name,omitempty"`
}

// Enable/disable HTTP tunnel authentication.
type FirewallProxyPolicyHttpTunnelAuth string

// Enable/disable use of Internet Services for this policy. If enabled, destination address and service are not used.
type FirewallProxyPolicyInternetService string

// Custom Internet Service name.
type FirewallProxyPolicyInternetServiceCustom struct {

	// Custom name.
	Name string `json:"name,omitempty"`
}

// Internet Service ID.
type FirewallProxyPolicyInternetServiceId struct {

	// Internet Service ID.
	Id int `json:"id,omitempty"`
}

// When enabled, Internet Services match against any internet service EXCEPT the selected Internet Service.
type FirewallProxyPolicyInternetServiceNegate string

// Enable/disable logging traffic through the policy.
type FirewallProxyPolicyLogtraffic string

// Enable/disable policy log traffic start.
type FirewallProxyPolicyLogtrafficStart string

// Name of IP pool object.
type FirewallProxyPolicyPoolname struct {

	// IP pool name.
	Name string `json:"name,omitempty"`
}

// Determine whether the firewall policy allows security profile groups or single profiles only.
type FirewallProxyPolicyProfileType string

// Type of explicit proxy.
type FirewallProxyPolicyProxy string

// Enable/disable scanning of connections to Botnet servers.
type FirewallProxyPolicyScanBotnetConnections string

// Name of service objects.
type FirewallProxyPolicyService struct {

	// Service name.
	Name string `json:"name,omitempty"`
}

// When enabled, services match against any service EXCEPT the specified destination services.
type FirewallProxyPolicyServiceNegate string

// Source address objects (must be set when using Web proxy).
type FirewallProxyPolicySrcaddr struct {

	// Address name.
	Name string `json:"name,omitempty"`
}

// When enabled, source addresses match against any address EXCEPT the specified source addresses.
type FirewallProxyPolicySrcaddrNegate string

// IPv6 source address objects.
type FirewallProxyPolicySrcaddr6 struct {

	// Address name.
	Name string `json:"name,omitempty"`
}

// Source interface names.
type FirewallProxyPolicySrcintf struct {

	// Interface name.
	Name string `json:"name,omitempty"`
}

// Enable/disable the active status of the policy.
type FirewallProxyPolicyStatus string

// Names of object-tags applied to address. Tags need to be preconfigured in config system object-tag. Separate multiple tags with a space.
type FirewallProxyPolicyTags struct {

	// Tag name.
	Name string `json:"name,omitempty"`
}

// Enable to use the IP address of the client to connect to the server.
type FirewallProxyPolicyTransparent string

// Names of user objects.
type FirewallProxyPolicyUsers struct {

	// Group name.
	Name string `json:"name,omitempty"`
}

// Enable the use of UTM profiles/sensors/lists.
type FirewallProxyPolicyUtmStatus string

const (
	// Action accept.
	FirewallProxyPolicyActionAccept FirewallProxyPolicyAction = "accept"

	// Action deny.
	FirewallProxyPolicyActionDeny FirewallProxyPolicyAction = "deny"

	// Action redirect.
	FirewallProxyPolicyActionRedirect FirewallProxyPolicyAction = "redirect"
)

const (
	// Disable disclaimer.
	FirewallProxyPolicyDisclaimerDisable FirewallProxyPolicyDisclaimer = "disable"

	// Display disclaimer for domain
	FirewallProxyPolicyDisclaimerDomain FirewallProxyPolicyDisclaimer = "domain"

	// Display disclaimer for policy
	FirewallProxyPolicyDisclaimerPolicy FirewallProxyPolicyDisclaimer = "policy"

	// Display disclaimer for current user
	FirewallProxyPolicyDisclaimerUser FirewallProxyPolicyDisclaimer = "user"
)

const (
	// Enable source address negate.
	FirewallProxyPolicyDstaddrNegateEnable FirewallProxyPolicyDstaddrNegate = "enable"

	// Disable destination address negate.
	FirewallProxyPolicyDstaddrNegateDisable FirewallProxyPolicyDstaddrNegate = "disable"
)

const (
	// Enable setting.
	FirewallProxyPolicyHttpTunnelAuthEnable FirewallProxyPolicyHttpTunnelAuth = "enable"

	// Disable setting.
	FirewallProxyPolicyHttpTunnelAuthDisable FirewallProxyPolicyHttpTunnelAuth = "disable"
)

const (
	// Enable use of Internet Services in policy.
	FirewallProxyPolicyInternetServiceEnable FirewallProxyPolicyInternetService = "enable"

	// Disable use of Internet Services in policy.
	FirewallProxyPolicyInternetServiceDisable FirewallProxyPolicyInternetService = "disable"
)

const (
	// Enable negated Internet Service match.
	FirewallProxyPolicyInternetServiceNegateEnable FirewallProxyPolicyInternetServiceNegate = "enable"

	// Disable negated Internet Service match.
	FirewallProxyPolicyInternetServiceNegateDisable FirewallProxyPolicyInternetServiceNegate = "disable"
)

const (
	// Log all sessions.
	FirewallProxyPolicyLogtrafficAll FirewallProxyPolicyLogtraffic = "all"

	// UTM event and matched application traffic log.
	FirewallProxyPolicyLogtrafficUtm FirewallProxyPolicyLogtraffic = "utm"

	// Disable traffic and application log.
	FirewallProxyPolicyLogtrafficDisable FirewallProxyPolicyLogtraffic = "disable"
)

const (
	// Enable setting.
	FirewallProxyPolicyLogtrafficStartEnable FirewallProxyPolicyLogtrafficStart = "enable"

	// Disable setting.
	FirewallProxyPolicyLogtrafficStartDisable FirewallProxyPolicyLogtrafficStart = "disable"
)

const (
	// Do not allow security profile groups.
	FirewallProxyPolicyProfileTypeSingle FirewallProxyPolicyProfileType = "single"

	// Allow security profile groups.
	FirewallProxyPolicyProfileTypeGroup FirewallProxyPolicyProfileType = "group"
)

const (
	// Explicit Web Proxy
	FirewallProxyPolicyProxyExplicitWeb FirewallProxyPolicyProxy = "explicit-web"

	// Transparent Web Proxy
	FirewallProxyPolicyProxyTransparentWeb FirewallProxyPolicyProxy = "transparent-web"

	// Explicit FTP Proxy
	FirewallProxyPolicyProxyFtp FirewallProxyPolicyProxy = "ftp"
)

const (
	// Do not scan connections to botnet servers.
	FirewallProxyPolicyScanBotnetConnectionsDisable FirewallProxyPolicyScanBotnetConnections = "disable"

	// Block connections to botnet servers.
	FirewallProxyPolicyScanBotnetConnectionsBlock FirewallProxyPolicyScanBotnetConnections = "block"

	// Log connections to botnet servers.
	FirewallProxyPolicyScanBotnetConnectionsMonitor FirewallProxyPolicyScanBotnetConnections = "monitor"
)

const (
	// Enable negated service match.
	FirewallProxyPolicyServiceNegateEnable FirewallProxyPolicyServiceNegate = "enable"

	// Disable negated service match.
	FirewallProxyPolicyServiceNegateDisable FirewallProxyPolicyServiceNegate = "disable"
)

const (
	// Enable source address negate.
	FirewallProxyPolicySrcaddrNegateEnable FirewallProxyPolicySrcaddrNegate = "enable"

	// Disable destination address negate.
	FirewallProxyPolicySrcaddrNegateDisable FirewallProxyPolicySrcaddrNegate = "disable"
)

const (
	// Enable setting.
	FirewallProxyPolicyStatusEnable FirewallProxyPolicyStatus = "enable"

	// Disable setting.
	FirewallProxyPolicyStatusDisable FirewallProxyPolicyStatus = "disable"
)

const (
	// Enable use of IP address of client to connect to server.
	FirewallProxyPolicyTransparentEnable FirewallProxyPolicyTransparent = "enable"

	// Disable use of IP address of client to connect to server.
	FirewallProxyPolicyTransparentDisable FirewallProxyPolicyTransparent = "disable"
)

const (
	// Enable setting.
	FirewallProxyPolicyUtmStatusEnable FirewallProxyPolicyUtmStatus = "enable"

	// Disable setting.
	FirewallProxyPolicyUtmStatusDisable FirewallProxyPolicyUtmStatus = "disable"
)

// Configure proxy policies.
type FirewallProxyPolicy struct {

	// Accept or deny traffic matching the policy parameters.
	Action FirewallProxyPolicyAction `json:"action,omitempty"`

	// Name of an existing Application list.
	ApplicationList string `json:"application-list,omitempty"`

	// Name of an existing Antivirus profile.
	AvProfile string `json:"av-profile,omitempty"`

	// Optional comments.
	Comments string `json:"comments,omitempty"`

	// Web proxy disclaimer setting: by domain, policy, or user.
	Disclaimer FirewallProxyPolicyDisclaimer `json:"disclaimer,omitempty"`

	// Name of an existing DLP sensor.
	DlpSensor string `json:"dlp-sensor,omitempty"`

	// Destination address objects.
	Dstaddr []FirewallProxyPolicyDstaddr `json:"dstaddr,omitempty"`

	// When enabled, destination addresses match against any address EXCEPT the specified destination addresses.
	DstaddrNegate FirewallProxyPolicyDstaddrNegate `json:"dstaddr-negate,omitempty"`

	// IPv6 destination address objects.
	Dstaddr6 []FirewallProxyPolicyDstaddr6 `json:"dstaddr6,omitempty"`

	// Destination interface names.
	Dstintf []FirewallProxyPolicyDstintf `json:"dstintf,omitempty"`

	// Global web-based manager visible label.
	GlobalLabel string `json:"global-label,omitempty"`

	// Names of group objects.
	Groups []FirewallProxyPolicyGroups `json:"groups,omitempty"`

	// Enable/disable HTTP tunnel authentication.
	HttpTunnelAuth FirewallProxyPolicyHttpTunnelAuth `json:"http-tunnel-auth,omitempty"`

	// Name of an existing ICAP profile.
	IcapProfile string `json:"icap-profile,omitempty"`

	// Enable/disable use of Internet Services for this policy. If enabled, destination address and service are not used.
	InternetService FirewallProxyPolicyInternetService `json:"internet-service,omitempty"`

	// Custom Internet Service name.
	InternetServiceCustom []FirewallProxyPolicyInternetServiceCustom `json:"internet-service-custom,omitempty"`

	// Internet Service ID.
	InternetServiceId []FirewallProxyPolicyInternetServiceId `json:"internet-service-id,omitempty"`

	// When enabled, Internet Services match against any internet service EXCEPT the selected Internet Service.
	InternetServiceNegate FirewallProxyPolicyInternetServiceNegate `json:"internet-service-negate,omitempty"`

	// Name of an existing IPS sensor.
	IpsSensor string `json:"ips-sensor,omitempty"`

	// VDOM-specific GUI visible label.
	Label string `json:"label,omitempty"`

	// Enable/disable logging traffic through the policy.
	Logtraffic FirewallProxyPolicyLogtraffic `json:"logtraffic,omitempty"`

	// Enable/disable policy log traffic start.
	LogtrafficStart FirewallProxyPolicyLogtrafficStart `json:"logtraffic-start,omitempty"`

	// Policy ID.
	Policyid int `json:"policyid,omitempty"`

	// Name of IP pool object.
	Poolname []FirewallProxyPolicyPoolname `json:"poolname,omitempty"`

	// Name of profile group.
	ProfileGroup string `json:"profile-group,omitempty"`

	// Name of an existing Protocol options profile.
	ProfileProtocolOptions string `json:"profile-protocol-options,omitempty"`

	// Determine whether the firewall policy allows security profile groups or single profiles only.
	ProfileType FirewallProxyPolicyProfileType `json:"profile-type,omitempty"`

	// Type of explicit proxy.
	Proxy FirewallProxyPolicyProxy `json:"proxy,omitempty"`

	// Redirect URL for further explicit web proxy processing.
	RedirectUrl string `json:"redirect-url,omitempty"`

	// Authentication replacement message override group.
	ReplacemsgOverrideGroup string `json:"replacemsg-override-group,omitempty"`

	// Enable/disable scanning of connections to Botnet servers.
	ScanBotnetConnections FirewallProxyPolicyScanBotnetConnections `json:"scan-botnet-connections,omitempty"`

	// Name of schedule object.
	Schedule string `json:"schedule,omitempty"`

	// Name of service objects.
	Service []FirewallProxyPolicyService `json:"service,omitempty"`

	// When enabled, services match against any service EXCEPT the specified destination services.
	ServiceNegate FirewallProxyPolicyServiceNegate `json:"service-negate,omitempty"`

	// Name of an existing Spam filter profile.
	SpamfilterProfile string `json:"spamfilter-profile,omitempty"`

	// Source address objects (must be set when using Web proxy).
	Srcaddr []FirewallProxyPolicySrcaddr `json:"srcaddr,omitempty"`

	// When enabled, source addresses match against any address EXCEPT the specified source addresses.
	SrcaddrNegate FirewallProxyPolicySrcaddrNegate `json:"srcaddr-negate,omitempty"`

	// IPv6 source address objects.
	Srcaddr6 []FirewallProxyPolicySrcaddr6 `json:"srcaddr6,omitempty"`

	// Source interface names.
	Srcintf []FirewallProxyPolicySrcintf `json:"srcintf,omitempty"`

	// Name of an existing SSL SSH profile.
	SslSshProfile string `json:"ssl-ssh-profile,omitempty"`

	// Enable/disable the active status of the policy.
	Status FirewallProxyPolicyStatus `json:"status,omitempty"`

	// Names of object-tags applied to address. Tags need to be preconfigured in config system object-tag. Separate multiple tags with a space.
	Tags []FirewallProxyPolicyTags `json:"tags,omitempty"`

	// Enable to use the IP address of the client to connect to the server.
	Transparent FirewallProxyPolicyTransparent `json:"transparent,omitempty"`

	// Names of user objects.
	Users []FirewallProxyPolicyUsers `json:"users,omitempty"`

	// Enable the use of UTM profiles/sensors/lists.
	UtmStatus FirewallProxyPolicyUtmStatus `json:"utm-status,omitempty"`

	// Universally Unique Identifier (UUID; automatically assigned but can be manually reset).
	Uuid string `json:"uuid,omitempty"`

	// Name of an existing Web application firewall profile.
	WafProfile string `json:"waf-profile,omitempty"`

	// Name of an existing Web filter profile.
	WebfilterProfile string `json:"webfilter-profile,omitempty"`

	// Name of web proxy forward server.
	WebproxyForwardServer string `json:"webproxy-forward-server,omitempty"`

	// Name of web proxy profile.
	WebproxyProfile string `json:"webproxy-profile,omitempty"`
}

// Returns the value that identifies a FirewallProxyPolicy
func (x *FirewallProxyPolicy) MKey() int {
	return x.Policyid
}

// The results of a Get or List operation
type FirewallProxyPolicyResults struct {
	Results []*FirewallProxyPolicy `json:"results"`
	Mkey    int                    `json:"mkey"`
	Result
}

// List all FirewallProxyPolicys
func (c *WebClient) ListFirewallProxyPolicys() (res []*FirewallProxyPolicy, err error) {
	var errmsg Result
	var results FirewallProxyPolicyResults
	_, err = c.napping.Get(c.URL+"/api/v2/firewall/proxy-policy", nil, &results, nil)
	if err != nil {
		return []*FirewallProxyPolicy{}, fmt.Errorf("error listing FirewallProxyPolicys: %s", err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return []*FirewallProxyPolicy{}, fmt.Errorf("error listing FirewallProxyPolicy: not found")
		} else {
			return []*FirewallProxyPolicy{}, fmt.Errorf("error listing FirewallProxyPolicy: %s", errmsg.Status)
		}
	}
	res = results.Results
	return
}

// Get a FirewallProxyPolicy by name
func (c *WebClient) GetFirewallProxyPolicy(mkey int) (res *FirewallProxyPolicy, err error) {
	var errmsg Result
	var results FirewallProxyPolicyResults
	_, err = c.napping.Get(c.URL+"/api/v2/firewall/proxy-policy/"+strconv.Itoa(mkey), nil, &results, &errmsg)
	if err != nil {
		return &FirewallProxyPolicy{}, fmt.Errorf("error getting FirewallProxyPolicy '%s': %s", strconv.Itoa(mkey), err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return &FirewallProxyPolicy{}, fmt.Errorf("error getting FirewallProxyPolicy '%s': not found", strconv.Itoa(mkey))
		} else {
			return &FirewallProxyPolicy{}, fmt.Errorf("error getting FirewallProxyPolicy '%s': %s", strconv.Itoa(mkey), errmsg.Status)
		}
	}
	if len(results.Results) == 0 {
		return &FirewallProxyPolicy{}, fmt.Errorf("error getting FirewallProxyPolicy '%s': not found", strconv.Itoa(mkey))
	}

	res = results.Results[0]
	return
}

// Create a new FirewallProxyPolicy
func (c *WebClient) CreateFirewallProxyPolicy(obj *FirewallProxyPolicy) (id int, err error) {
	var errmsg Result
	var results FirewallProxyPolicyResults
	_, err = c.napping.Post(c.URL+"/api/v2/firewall/proxy-policy", obj, &results, &errmsg)
	if err != nil {
		return 0, fmt.Errorf("error creating FirewallProxyPolicy '%s': %s", strconv.Itoa(obj.Policyid), err.Error())
	}
	if results.HTTPStatus == 200 {
		return
	}
	if errmsg.HTTPStatus != 200 {
		return 0, fmt.Errorf("error creating FirewallProxyPolicy '%s': %s", strconv.Itoa(obj.Policyid), errmsg.Status)
	}

	return
}

// Update a FirewallProxyPolicy
func (c *WebClient) UpdateFirewallProxyPolicy(obj *FirewallProxyPolicy) (err error) {
	var errmsg Result
	var results FirewallProxyPolicyResults
	_, err = c.napping.Put(c.URL+"/api/v2/firewall/proxy-policy/"+strconv.Itoa(obj.Policyid), obj, &results, &errmsg)
	if err != nil {
		return fmt.Errorf("error updating FirewallProxyPolicy '%s': %s", strconv.Itoa(obj.Policyid), err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return fmt.Errorf("error updating FirewallProxyPolicy '%s': not found", strconv.Itoa(obj.Policyid))
		} else {
			return fmt.Errorf("error updating FirewallProxyPolicy '%s': %s", strconv.Itoa(obj.Policyid), errmsg.Status)
		}
	}

	return
}

// Delete a FirewallProxyPolicy by name
func (c *WebClient) DeleteFirewallProxyPolicy(mkey int) (err error) {
	var errmsg Result
	var results FirewallProxyPolicyResults
	_, err = c.napping.Delete(c.URL+"/api/v2/firewall/proxy-policy/"+strconv.Itoa(mkey), nil, &results, &errmsg)
	if err != nil {
		return fmt.Errorf("error deleting FirewallProxyPolicy '%s': %s", mkey, err.Error())
	}
	if results.HTTPStatus == 200 {
		return
	}
	if errmsg.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return fmt.Errorf("error deleting FirewallProxyPolicy '%s': not found", mkey)
		}
		return fmt.Errorf("error deleting FirewallProxyPolicy '%s': %s", mkey, errmsg.Status)
	}

	return
}

// List all FirewallProxyPolicys
func (c *FakeClient) ListFirewallProxyPolicys() (res []*FirewallProxyPolicy, err error) {
	for _, r := range c.FirewallProxyPolicys {
		res = append(res, r)
	}
	return
}

// Get a FirewallProxyPolicy by name
func (c *FakeClient) GetFirewallProxyPolicy(mkey int) (*FirewallProxyPolicy, error) {
	if res, ok := c.FirewallProxyPolicys[mkey]; ok {
		return res, nil
	} else {
		return &FirewallProxyPolicy{}, fmt.Errorf("error getting FirewallProxyPolicy '%s': not found", strconv.Itoa(mkey))
	}
}

// Create a new FirewallProxyPolicy
func (c *FakeClient) CreateFirewallProxyPolicy(obj *FirewallProxyPolicy) (id int, err error) {
	id = c.FirewallProxyPolicyCounter
	c.FirewallProxyPolicyCounter++
	c.FirewallProxyPolicys[id] = obj
	return
}

// Update a FirewallProxyPolicy
func (c *FakeClient) UpdateFirewallProxyPolicy(obj *FirewallProxyPolicy) (err error) {
	c.FirewallProxyPolicys[obj.Policyid] = obj
	return nil
}

// Delete a FirewallProxyPolicy by name
func (c *FakeClient) DeleteFirewallProxyPolicy(mkey int) (err error) {
	delete(c.FirewallProxyPolicys, mkey)
	return nil
}

// Configure DNS translation.
type FirewallDnstranslation struct {

	// IPv4 address or subnet on the external network to substitute for the resolved address in DNS query replies. Can be single IP address or subnet on the external network, but number of addresses must equal number of mapped IP addresses in src.
	Dst string `json:"dst,omitempty"`

	// ID.
	Id int `json:"id,omitempty"`

	// If src and dst are subnets rather than single IP addresses, enter the netmask for both src and dst.
	Netmask string `json:"netmask,omitempty"`

	// IPv4 address or subnet on the internal network to compare with the resolved address in DNS query replies. If the resolved address matches, the resolved address is substituted with dst.
	Src string `json:"src,omitempty"`
}

// Returns the value that identifies a FirewallDnstranslation
func (x *FirewallDnstranslation) MKey() int {
	return x.Id
}

// The results of a Get or List operation
type FirewallDnstranslationResults struct {
	Results []*FirewallDnstranslation `json:"results"`
	Mkey    int                       `json:"mkey"`
	Result
}

// List all FirewallDnstranslations
func (c *WebClient) ListFirewallDnstranslations() (res []*FirewallDnstranslation, err error) {
	var errmsg Result
	var results FirewallDnstranslationResults
	_, err = c.napping.Get(c.URL+"/api/v2/firewall/dnstranslation", nil, &results, nil)
	if err != nil {
		return []*FirewallDnstranslation{}, fmt.Errorf("error listing FirewallDnstranslations: %s", err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return []*FirewallDnstranslation{}, fmt.Errorf("error listing FirewallDnstranslation: not found")
		} else {
			return []*FirewallDnstranslation{}, fmt.Errorf("error listing FirewallDnstranslation: %s", errmsg.Status)
		}
	}
	res = results.Results
	return
}

// Get a FirewallDnstranslation by name
func (c *WebClient) GetFirewallDnstranslation(mkey int) (res *FirewallDnstranslation, err error) {
	var errmsg Result
	var results FirewallDnstranslationResults
	_, err = c.napping.Get(c.URL+"/api/v2/firewall/dnstranslation/"+strconv.Itoa(mkey), nil, &results, &errmsg)
	if err != nil {
		return &FirewallDnstranslation{}, fmt.Errorf("error getting FirewallDnstranslation '%s': %s", strconv.Itoa(mkey), err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return &FirewallDnstranslation{}, fmt.Errorf("error getting FirewallDnstranslation '%s': not found", strconv.Itoa(mkey))
		} else {
			return &FirewallDnstranslation{}, fmt.Errorf("error getting FirewallDnstranslation '%s': %s", strconv.Itoa(mkey), errmsg.Status)
		}
	}
	if len(results.Results) == 0 {
		return &FirewallDnstranslation{}, fmt.Errorf("error getting FirewallDnstranslation '%s': not found", strconv.Itoa(mkey))
	}

	res = results.Results[0]
	return
}

// Create a new FirewallDnstranslation
func (c *WebClient) CreateFirewallDnstranslation(obj *FirewallDnstranslation) (id int, err error) {
	var errmsg Result
	var results FirewallDnstranslationResults
	_, err = c.napping.Post(c.URL+"/api/v2/firewall/dnstranslation", obj, &results, &errmsg)
	if err != nil {
		return 0, fmt.Errorf("error creating FirewallDnstranslation '%s': %s", strconv.Itoa(obj.Id), err.Error())
	}
	if results.HTTPStatus == 200 {
		return
	}
	if errmsg.HTTPStatus != 200 {
		return 0, fmt.Errorf("error creating FirewallDnstranslation '%s': %s", strconv.Itoa(obj.Id), errmsg.Status)
	}

	return
}

// Update a FirewallDnstranslation
func (c *WebClient) UpdateFirewallDnstranslation(obj *FirewallDnstranslation) (err error) {
	var errmsg Result
	var results FirewallDnstranslationResults
	_, err = c.napping.Put(c.URL+"/api/v2/firewall/dnstranslation/"+strconv.Itoa(obj.Id), obj, &results, &errmsg)
	if err != nil {
		return fmt.Errorf("error updating FirewallDnstranslation '%s': %s", strconv.Itoa(obj.Id), err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return fmt.Errorf("error updating FirewallDnstranslation '%s': not found", strconv.Itoa(obj.Id))
		} else {
			return fmt.Errorf("error updating FirewallDnstranslation '%s': %s", strconv.Itoa(obj.Id), errmsg.Status)
		}
	}

	return
}

// Delete a FirewallDnstranslation by name
func (c *WebClient) DeleteFirewallDnstranslation(mkey int) (err error) {
	var errmsg Result
	var results FirewallDnstranslationResults
	_, err = c.napping.Delete(c.URL+"/api/v2/firewall/dnstranslation/"+strconv.Itoa(mkey), nil, &results, &errmsg)
	if err != nil {
		return fmt.Errorf("error deleting FirewallDnstranslation '%s': %s", mkey, err.Error())
	}
	if results.HTTPStatus == 200 {
		return
	}
	if errmsg.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return fmt.Errorf("error deleting FirewallDnstranslation '%s': not found", mkey)
		}
		return fmt.Errorf("error deleting FirewallDnstranslation '%s': %s", mkey, errmsg.Status)
	}

	return
}

// List all FirewallDnstranslations
func (c *FakeClient) ListFirewallDnstranslations() (res []*FirewallDnstranslation, err error) {
	for _, r := range c.FirewallDnstranslations {
		res = append(res, r)
	}
	return
}

// Get a FirewallDnstranslation by name
func (c *FakeClient) GetFirewallDnstranslation(mkey int) (*FirewallDnstranslation, error) {
	if res, ok := c.FirewallDnstranslations[mkey]; ok {
		return res, nil
	} else {
		return &FirewallDnstranslation{}, fmt.Errorf("error getting FirewallDnstranslation '%s': not found", strconv.Itoa(mkey))
	}
}

// Create a new FirewallDnstranslation
func (c *FakeClient) CreateFirewallDnstranslation(obj *FirewallDnstranslation) (id int, err error) {
	id = c.FirewallDnstranslationCounter
	c.FirewallDnstranslationCounter++
	c.FirewallDnstranslations[id] = obj
	return
}

// Update a FirewallDnstranslation
func (c *FakeClient) UpdateFirewallDnstranslation(obj *FirewallDnstranslation) (err error) {
	c.FirewallDnstranslations[obj.Id] = obj
	return nil
}

// Delete a FirewallDnstranslation by name
func (c *FakeClient) DeleteFirewallDnstranslation(mkey int) (err error) {
	delete(c.FirewallDnstranslations, mkey)
	return nil
}

// Accept or deny traffic matching the policy.
type FirewallMulticastPolicyAction string

// Destination address objects.
type FirewallMulticastPolicyDstaddr struct {

	// Destination address objects.
	Name string `json:"name,omitempty"`
}

// Enable/disable logging traffic accepted by this policy.
type FirewallMulticastPolicyLogtraffic string

// Enable/disable substitution of the outgoing interface IP address for the original source IP address (called source NAT or SNAT).
type FirewallMulticastPolicySnat string

// Source address objects.
type FirewallMulticastPolicySrcaddr struct {

	// Source address objects.
	Name string `json:"name,omitempty"`
}

// Enable/disable this policy.
type FirewallMulticastPolicyStatus string

const (
	// Accept traffic matching the policy.
	FirewallMulticastPolicyActionAccept FirewallMulticastPolicyAction = "accept"

	// Deny or block traffic matching the policy.
	FirewallMulticastPolicyActionDeny FirewallMulticastPolicyAction = "deny"
)

const (
	// Enable logging traffic accepted by this policy.
	FirewallMulticastPolicyLogtrafficEnable FirewallMulticastPolicyLogtraffic = "enable"

	// Disable logging traffic accepted by this policy.
	FirewallMulticastPolicyLogtrafficDisable FirewallMulticastPolicyLogtraffic = "disable"
)

const (
	// Enable source NAT.
	FirewallMulticastPolicySnatEnable FirewallMulticastPolicySnat = "enable"

	// Disable source NAT.
	FirewallMulticastPolicySnatDisable FirewallMulticastPolicySnat = "disable"
)

const (
	// Enable this policy.
	FirewallMulticastPolicyStatusEnable FirewallMulticastPolicyStatus = "enable"

	// Disable this policy.
	FirewallMulticastPolicyStatusDisable FirewallMulticastPolicyStatus = "disable"
)

// Configure multicast NAT policies.
type FirewallMulticastPolicy struct {

	// Accept or deny traffic matching the policy.
	Action FirewallMulticastPolicyAction `json:"action,omitempty"`

	// IPv4 DNAT address used for multicast destination addresses.
	Dnat string `json:"dnat,omitempty"`

	// Destination address objects.
	Dstaddr []FirewallMulticastPolicyDstaddr `json:"dstaddr,omitempty"`

	// Destination interface name.
	Dstintf string `json:"dstintf,omitempty"`

	//  Integer value for ending TCP/UDP/SCTP destination port in range (1 - 65535, default = 1).
	EndPort int `json:"end-port,omitempty"`

	// Policy ID.
	Id int `json:"id,omitempty"`

	// Enable/disable logging traffic accepted by this policy.
	Logtraffic FirewallMulticastPolicyLogtraffic `json:"logtraffic,omitempty"`

	// Integer value for the protocol type as defined by IANA (0 - 255, default = 0).
	Protocol int `json:"protocol,omitempty"`

	// Enable/disable substitution of the outgoing interface IP address for the original source IP address (called source NAT or SNAT).
	Snat FirewallMulticastPolicySnat `json:"snat,omitempty"`

	// IPv4 address to be used as the source address for NATed traffic.
	SnatIp string `json:"snat-ip,omitempty"`

	// Source address objects.
	Srcaddr []FirewallMulticastPolicySrcaddr `json:"srcaddr,omitempty"`

	// Source interface name.
	Srcintf string `json:"srcintf,omitempty"`

	// Integer value for starting TCP/UDP/SCTP destination port in range (1 - 65535, default = 1).
	StartPort int `json:"start-port,omitempty"`

	// Enable/disable this policy.
	Status FirewallMulticastPolicyStatus `json:"status,omitempty"`
}

// Returns the value that identifies a FirewallMulticastPolicy
func (x *FirewallMulticastPolicy) MKey() int {
	return x.Id
}

// The results of a Get or List operation
type FirewallMulticastPolicyResults struct {
	Results []*FirewallMulticastPolicy `json:"results"`
	Mkey    int                        `json:"mkey"`
	Result
}

// List all FirewallMulticastPolicys
func (c *WebClient) ListFirewallMulticastPolicys() (res []*FirewallMulticastPolicy, err error) {
	var errmsg Result
	var results FirewallMulticastPolicyResults
	_, err = c.napping.Get(c.URL+"/api/v2/firewall/multicast-policy", nil, &results, nil)
	if err != nil {
		return []*FirewallMulticastPolicy{}, fmt.Errorf("error listing FirewallMulticastPolicys: %s", err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return []*FirewallMulticastPolicy{}, fmt.Errorf("error listing FirewallMulticastPolicy: not found")
		} else {
			return []*FirewallMulticastPolicy{}, fmt.Errorf("error listing FirewallMulticastPolicy: %s", errmsg.Status)
		}
	}
	res = results.Results
	return
}

// Get a FirewallMulticastPolicy by name
func (c *WebClient) GetFirewallMulticastPolicy(mkey int) (res *FirewallMulticastPolicy, err error) {
	var errmsg Result
	var results FirewallMulticastPolicyResults
	_, err = c.napping.Get(c.URL+"/api/v2/firewall/multicast-policy/"+strconv.Itoa(mkey), nil, &results, &errmsg)
	if err != nil {
		return &FirewallMulticastPolicy{}, fmt.Errorf("error getting FirewallMulticastPolicy '%s': %s", strconv.Itoa(mkey), err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return &FirewallMulticastPolicy{}, fmt.Errorf("error getting FirewallMulticastPolicy '%s': not found", strconv.Itoa(mkey))
		} else {
			return &FirewallMulticastPolicy{}, fmt.Errorf("error getting FirewallMulticastPolicy '%s': %s", strconv.Itoa(mkey), errmsg.Status)
		}
	}
	if len(results.Results) == 0 {
		return &FirewallMulticastPolicy{}, fmt.Errorf("error getting FirewallMulticastPolicy '%s': not found", strconv.Itoa(mkey))
	}

	res = results.Results[0]
	return
}

// Create a new FirewallMulticastPolicy
func (c *WebClient) CreateFirewallMulticastPolicy(obj *FirewallMulticastPolicy) (id int, err error) {
	var errmsg Result
	var results FirewallMulticastPolicyResults
	_, err = c.napping.Post(c.URL+"/api/v2/firewall/multicast-policy", obj, &results, &errmsg)
	if err != nil {
		return 0, fmt.Errorf("error creating FirewallMulticastPolicy '%s': %s", strconv.Itoa(obj.Id), err.Error())
	}
	if results.HTTPStatus == 200 {
		return
	}
	if errmsg.HTTPStatus != 200 {
		return 0, fmt.Errorf("error creating FirewallMulticastPolicy '%s': %s", strconv.Itoa(obj.Id), errmsg.Status)
	}

	return
}

// Update a FirewallMulticastPolicy
func (c *WebClient) UpdateFirewallMulticastPolicy(obj *FirewallMulticastPolicy) (err error) {
	var errmsg Result
	var results FirewallMulticastPolicyResults
	_, err = c.napping.Put(c.URL+"/api/v2/firewall/multicast-policy/"+strconv.Itoa(obj.Id), obj, &results, &errmsg)
	if err != nil {
		return fmt.Errorf("error updating FirewallMulticastPolicy '%s': %s", strconv.Itoa(obj.Id), err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return fmt.Errorf("error updating FirewallMulticastPolicy '%s': not found", strconv.Itoa(obj.Id))
		} else {
			return fmt.Errorf("error updating FirewallMulticastPolicy '%s': %s", strconv.Itoa(obj.Id), errmsg.Status)
		}
	}

	return
}

// Delete a FirewallMulticastPolicy by name
func (c *WebClient) DeleteFirewallMulticastPolicy(mkey int) (err error) {
	var errmsg Result
	var results FirewallMulticastPolicyResults
	_, err = c.napping.Delete(c.URL+"/api/v2/firewall/multicast-policy/"+strconv.Itoa(mkey), nil, &results, &errmsg)
	if err != nil {
		return fmt.Errorf("error deleting FirewallMulticastPolicy '%s': %s", mkey, err.Error())
	}
	if results.HTTPStatus == 200 {
		return
	}
	if errmsg.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return fmt.Errorf("error deleting FirewallMulticastPolicy '%s': not found", mkey)
		}
		return fmt.Errorf("error deleting FirewallMulticastPolicy '%s': %s", mkey, errmsg.Status)
	}

	return
}

// List all FirewallMulticastPolicys
func (c *FakeClient) ListFirewallMulticastPolicys() (res []*FirewallMulticastPolicy, err error) {
	for _, r := range c.FirewallMulticastPolicys {
		res = append(res, r)
	}
	return
}

// Get a FirewallMulticastPolicy by name
func (c *FakeClient) GetFirewallMulticastPolicy(mkey int) (*FirewallMulticastPolicy, error) {
	if res, ok := c.FirewallMulticastPolicys[mkey]; ok {
		return res, nil
	} else {
		return &FirewallMulticastPolicy{}, fmt.Errorf("error getting FirewallMulticastPolicy '%s': not found", strconv.Itoa(mkey))
	}
}

// Create a new FirewallMulticastPolicy
func (c *FakeClient) CreateFirewallMulticastPolicy(obj *FirewallMulticastPolicy) (id int, err error) {
	id = c.FirewallMulticastPolicyCounter
	c.FirewallMulticastPolicyCounter++
	c.FirewallMulticastPolicys[id] = obj
	return
}

// Update a FirewallMulticastPolicy
func (c *FakeClient) UpdateFirewallMulticastPolicy(obj *FirewallMulticastPolicy) (err error) {
	c.FirewallMulticastPolicys[obj.Id] = obj
	return nil
}

// Delete a FirewallMulticastPolicy by name
func (c *FakeClient) DeleteFirewallMulticastPolicy(mkey int) (err error) {
	delete(c.FirewallMulticastPolicys, mkey)
	return nil
}

// Accept or deny traffic matching the policy.
type FirewallMulticastPolicy6Action string

// IPv6 destination address name.
type FirewallMulticastPolicy6Dstaddr struct {

	// Address name.
	Name string `json:"name,omitempty"`
}

// Enable/disable logging traffic accepted by this policy.
type FirewallMulticastPolicy6Logtraffic string

// IPv6 source address name.
type FirewallMulticastPolicy6Srcaddr struct {

	// Address name.
	Name string `json:"name,omitempty"`
}

// Enable/disable this policy.
type FirewallMulticastPolicy6Status string

const (
	// Accept.
	FirewallMulticastPolicy6ActionAccept FirewallMulticastPolicy6Action = "accept"

	// Deny.
	FirewallMulticastPolicy6ActionDeny FirewallMulticastPolicy6Action = "deny"
)

const (
	// Enable logging traffic accepted by this policy.
	FirewallMulticastPolicy6LogtrafficEnable FirewallMulticastPolicy6Logtraffic = "enable"

	// Disable logging traffic accepted by this policy.
	FirewallMulticastPolicy6LogtrafficDisable FirewallMulticastPolicy6Logtraffic = "disable"
)

const (
	// Enable this policy.
	FirewallMulticastPolicy6StatusEnable FirewallMulticastPolicy6Status = "enable"

	// Disable this policy.
	FirewallMulticastPolicy6StatusDisable FirewallMulticastPolicy6Status = "disable"
)

// Configure IPv6 multicast NAT policies.
type FirewallMulticastPolicy6 struct {

	// Accept or deny traffic matching the policy.
	Action FirewallMulticastPolicy6Action `json:"action,omitempty"`

	// IPv6 destination address name.
	Dstaddr []FirewallMulticastPolicy6Dstaddr `json:"dstaddr,omitempty"`

	// IPv6 destination interface name.
	Dstintf string `json:"dstintf,omitempty"`

	// Integer value for ending TCP/UDP/SCTP destination port in range (1 - 65535, default = 65535).
	EndPort int `json:"end-port,omitempty"`

	// Policy ID.
	Id int `json:"id,omitempty"`

	// Enable/disable logging traffic accepted by this policy.
	Logtraffic FirewallMulticastPolicy6Logtraffic `json:"logtraffic,omitempty"`

	// Integer value for the protocol type as defined by IANA (0 - 255, default = 0).
	Protocol int `json:"protocol,omitempty"`

	// IPv6 source address name.
	Srcaddr []FirewallMulticastPolicy6Srcaddr `json:"srcaddr,omitempty"`

	// IPv6 source interface name.
	Srcintf string `json:"srcintf,omitempty"`

	// Integer value for starting TCP/UDP/SCTP destination port in range (1 - 65535, default = 1).
	StartPort int `json:"start-port,omitempty"`

	// Enable/disable this policy.
	Status FirewallMulticastPolicy6Status `json:"status,omitempty"`
}

// Returns the value that identifies a FirewallMulticastPolicy6
func (x *FirewallMulticastPolicy6) MKey() int {
	return x.Id
}

// The results of a Get or List operation
type FirewallMulticastPolicy6Results struct {
	Results []*FirewallMulticastPolicy6 `json:"results"`
	Mkey    int                         `json:"mkey"`
	Result
}

// List all FirewallMulticastPolicy6s
func (c *WebClient) ListFirewallMulticastPolicy6s() (res []*FirewallMulticastPolicy6, err error) {
	var errmsg Result
	var results FirewallMulticastPolicy6Results
	_, err = c.napping.Get(c.URL+"/api/v2/firewall/multicast-policy6", nil, &results, nil)
	if err != nil {
		return []*FirewallMulticastPolicy6{}, fmt.Errorf("error listing FirewallMulticastPolicy6s: %s", err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return []*FirewallMulticastPolicy6{}, fmt.Errorf("error listing FirewallMulticastPolicy6: not found")
		} else {
			return []*FirewallMulticastPolicy6{}, fmt.Errorf("error listing FirewallMulticastPolicy6: %s", errmsg.Status)
		}
	}
	res = results.Results
	return
}

// Get a FirewallMulticastPolicy6 by name
func (c *WebClient) GetFirewallMulticastPolicy6(mkey int) (res *FirewallMulticastPolicy6, err error) {
	var errmsg Result
	var results FirewallMulticastPolicy6Results
	_, err = c.napping.Get(c.URL+"/api/v2/firewall/multicast-policy6/"+strconv.Itoa(mkey), nil, &results, &errmsg)
	if err != nil {
		return &FirewallMulticastPolicy6{}, fmt.Errorf("error getting FirewallMulticastPolicy6 '%s': %s", strconv.Itoa(mkey), err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return &FirewallMulticastPolicy6{}, fmt.Errorf("error getting FirewallMulticastPolicy6 '%s': not found", strconv.Itoa(mkey))
		} else {
			return &FirewallMulticastPolicy6{}, fmt.Errorf("error getting FirewallMulticastPolicy6 '%s': %s", strconv.Itoa(mkey), errmsg.Status)
		}
	}
	if len(results.Results) == 0 {
		return &FirewallMulticastPolicy6{}, fmt.Errorf("error getting FirewallMulticastPolicy6 '%s': not found", strconv.Itoa(mkey))
	}

	res = results.Results[0]
	return
}

// Create a new FirewallMulticastPolicy6
func (c *WebClient) CreateFirewallMulticastPolicy6(obj *FirewallMulticastPolicy6) (id int, err error) {
	var errmsg Result
	var results FirewallMulticastPolicy6Results
	_, err = c.napping.Post(c.URL+"/api/v2/firewall/multicast-policy6", obj, &results, &errmsg)
	if err != nil {
		return 0, fmt.Errorf("error creating FirewallMulticastPolicy6 '%s': %s", strconv.Itoa(obj.Id), err.Error())
	}
	if results.HTTPStatus == 200 {
		return
	}
	if errmsg.HTTPStatus != 200 {
		return 0, fmt.Errorf("error creating FirewallMulticastPolicy6 '%s': %s", strconv.Itoa(obj.Id), errmsg.Status)
	}

	return
}

// Update a FirewallMulticastPolicy6
func (c *WebClient) UpdateFirewallMulticastPolicy6(obj *FirewallMulticastPolicy6) (err error) {
	var errmsg Result
	var results FirewallMulticastPolicy6Results
	_, err = c.napping.Put(c.URL+"/api/v2/firewall/multicast-policy6/"+strconv.Itoa(obj.Id), obj, &results, &errmsg)
	if err != nil {
		return fmt.Errorf("error updating FirewallMulticastPolicy6 '%s': %s", strconv.Itoa(obj.Id), err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return fmt.Errorf("error updating FirewallMulticastPolicy6 '%s': not found", strconv.Itoa(obj.Id))
		} else {
			return fmt.Errorf("error updating FirewallMulticastPolicy6 '%s': %s", strconv.Itoa(obj.Id), errmsg.Status)
		}
	}

	return
}

// Delete a FirewallMulticastPolicy6 by name
func (c *WebClient) DeleteFirewallMulticastPolicy6(mkey int) (err error) {
	var errmsg Result
	var results FirewallMulticastPolicy6Results
	_, err = c.napping.Delete(c.URL+"/api/v2/firewall/multicast-policy6/"+strconv.Itoa(mkey), nil, &results, &errmsg)
	if err != nil {
		return fmt.Errorf("error deleting FirewallMulticastPolicy6 '%s': %s", mkey, err.Error())
	}
	if results.HTTPStatus == 200 {
		return
	}
	if errmsg.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return fmt.Errorf("error deleting FirewallMulticastPolicy6 '%s': not found", mkey)
		}
		return fmt.Errorf("error deleting FirewallMulticastPolicy6 '%s': %s", mkey, errmsg.Status)
	}

	return
}

// List all FirewallMulticastPolicy6s
func (c *FakeClient) ListFirewallMulticastPolicy6s() (res []*FirewallMulticastPolicy6, err error) {
	for _, r := range c.FirewallMulticastPolicy6s {
		res = append(res, r)
	}
	return
}

// Get a FirewallMulticastPolicy6 by name
func (c *FakeClient) GetFirewallMulticastPolicy6(mkey int) (*FirewallMulticastPolicy6, error) {
	if res, ok := c.FirewallMulticastPolicy6s[mkey]; ok {
		return res, nil
	} else {
		return &FirewallMulticastPolicy6{}, fmt.Errorf("error getting FirewallMulticastPolicy6 '%s': not found", strconv.Itoa(mkey))
	}
}

// Create a new FirewallMulticastPolicy6
func (c *FakeClient) CreateFirewallMulticastPolicy6(obj *FirewallMulticastPolicy6) (id int, err error) {
	id = c.FirewallMulticastPolicy6Counter
	c.FirewallMulticastPolicy6Counter++
	c.FirewallMulticastPolicy6s[id] = obj
	return
}

// Update a FirewallMulticastPolicy6
func (c *FakeClient) UpdateFirewallMulticastPolicy6(obj *FirewallMulticastPolicy6) (err error) {
	c.FirewallMulticastPolicy6s[obj.Id] = obj
	return nil
}

// Delete a FirewallMulticastPolicy6 by name
func (c *FakeClient) DeleteFirewallMulticastPolicy6(mkey int) (err error) {
	delete(c.FirewallMulticastPolicy6s, mkey)
	return nil
}

// Policy address type (IPv4 or IPv6).
type FirewallInterfacePolicyAddressType string

// Enable/disable application control.
type FirewallInterfacePolicyApplicationListStatus string

// Enable/disable antivirus.
type FirewallInterfacePolicyAvProfileStatus string

// Enable/disable DLP.
type FirewallInterfacePolicyDlpSensorStatus string

// Enable/disable DSRI.
type FirewallInterfacePolicyDsri string

// Address object to limit traffic monitoring to network traffic sent to the specified address or range.
type FirewallInterfacePolicyDstaddr struct {

	// Address name.
	Name string `json:"name,omitempty"`
}

// Enable/disable IPS.
type FirewallInterfacePolicyIpsSensorStatus string

// Logging type to be used in this policy (Options: all | utm | disable, Default: utm).
type FirewallInterfacePolicyLogtraffic string

// Enable/disable scanning for connections to Botnet servers.
type FirewallInterfacePolicyScanBotnetConnections string

// Service object from available options.
type FirewallInterfacePolicyService struct {

	// Service name.
	Name string `json:"name,omitempty"`
}

// Enable/disable antispam.
type FirewallInterfacePolicySpamfilterProfileStatus string

// Address object to limit traffic monitoring to network traffic sent from the specified address or range.
type FirewallInterfacePolicySrcaddr struct {

	// Address name.
	Name string `json:"name,omitempty"`
}

// Enable/disable this policy.
type FirewallInterfacePolicyStatus string

// Enable/disable web filtering.
type FirewallInterfacePolicyWebfilterProfileStatus string

const (
	// IPv4.
	FirewallInterfacePolicyAddressTypeIpv4 FirewallInterfacePolicyAddressType = "ipv4"

	// IPv6.
	FirewallInterfacePolicyAddressTypeIpv6 FirewallInterfacePolicyAddressType = "ipv6"
)

const (
	// Enable application control
	FirewallInterfacePolicyApplicationListStatusEnable FirewallInterfacePolicyApplicationListStatus = "enable"

	// Disable application control
	FirewallInterfacePolicyApplicationListStatusDisable FirewallInterfacePolicyApplicationListStatus = "disable"
)

const (
	// Enable antivirus
	FirewallInterfacePolicyAvProfileStatusEnable FirewallInterfacePolicyAvProfileStatus = "enable"

	// Disable antivirus
	FirewallInterfacePolicyAvProfileStatusDisable FirewallInterfacePolicyAvProfileStatus = "disable"
)

const (
	// Enable setting.
	FirewallInterfacePolicyDlpSensorStatusEnable FirewallInterfacePolicyDlpSensorStatus = "enable"

	// Disable setting.
	FirewallInterfacePolicyDlpSensorStatusDisable FirewallInterfacePolicyDlpSensorStatus = "disable"
)

const (
	// Enable DSRI.
	FirewallInterfacePolicyDsriEnable FirewallInterfacePolicyDsri = "enable"

	// Disable DSRI.
	FirewallInterfacePolicyDsriDisable FirewallInterfacePolicyDsri = "disable"
)

const (
	// Enable IPS.
	FirewallInterfacePolicyIpsSensorStatusEnable FirewallInterfacePolicyIpsSensorStatus = "enable"

	// Disable IPS.
	FirewallInterfacePolicyIpsSensorStatusDisable FirewallInterfacePolicyIpsSensorStatus = "disable"
)

const (
	// Log all sessions accepted or denied by this policy.
	FirewallInterfacePolicyLogtrafficAll FirewallInterfacePolicyLogtraffic = "all"

	// Log traffic that has a security profile applied to it.
	FirewallInterfacePolicyLogtrafficUtm FirewallInterfacePolicyLogtraffic = "utm"

	// Disable all logging for this policy.
	FirewallInterfacePolicyLogtrafficDisable FirewallInterfacePolicyLogtraffic = "disable"
)

const (
	// Do not scan for connections to botnet servers.
	FirewallInterfacePolicyScanBotnetConnectionsDisable FirewallInterfacePolicyScanBotnetConnections = "disable"

	// Block connections to botnet servers.
	FirewallInterfacePolicyScanBotnetConnectionsBlock FirewallInterfacePolicyScanBotnetConnections = "block"

	// Log connections to botnet servers.
	FirewallInterfacePolicyScanBotnetConnectionsMonitor FirewallInterfacePolicyScanBotnetConnections = "monitor"
)

const (
	// Enable antispam.
	FirewallInterfacePolicySpamfilterProfileStatusEnable FirewallInterfacePolicySpamfilterProfileStatus = "enable"

	// Disable antispam.
	FirewallInterfacePolicySpamfilterProfileStatusDisable FirewallInterfacePolicySpamfilterProfileStatus = "disable"
)

const (
	// Enable this policy.
	FirewallInterfacePolicyStatusEnable FirewallInterfacePolicyStatus = "enable"

	// Disable this policy.
	FirewallInterfacePolicyStatusDisable FirewallInterfacePolicyStatus = "disable"
)

const (
	// Enable web filtering.
	FirewallInterfacePolicyWebfilterProfileStatusEnable FirewallInterfacePolicyWebfilterProfileStatus = "enable"

	// Disable web filtering.
	FirewallInterfacePolicyWebfilterProfileStatusDisable FirewallInterfacePolicyWebfilterProfileStatus = "disable"
)

// Configure IPv4 interface policies.
type FirewallInterfacePolicy struct {

	// Policy address type (IPv4 or IPv6).
	AddressType FirewallInterfacePolicyAddressType `json:"address-type,omitempty"`

	// Application list name.
	ApplicationList string `json:"application-list,omitempty"`

	// Enable/disable application control.
	ApplicationListStatus FirewallInterfacePolicyApplicationListStatus `json:"application-list-status,omitempty"`

	// Antivirus profile.
	AvProfile string `json:"av-profile,omitempty"`

	// Enable/disable antivirus.
	AvProfileStatus FirewallInterfacePolicyAvProfileStatus `json:"av-profile-status,omitempty"`

	// Comments.
	Comments string `json:"comments,omitempty"`

	// DLP sensor name.
	DlpSensor string `json:"dlp-sensor,omitempty"`

	// Enable/disable DLP.
	DlpSensorStatus FirewallInterfacePolicyDlpSensorStatus `json:"dlp-sensor-status,omitempty"`

	// Enable/disable DSRI.
	Dsri FirewallInterfacePolicyDsri `json:"dsri,omitempty"`

	// Address object to limit traffic monitoring to network traffic sent to the specified address or range.
	Dstaddr []FirewallInterfacePolicyDstaddr `json:"dstaddr,omitempty"`

	// Monitored interface name from available interfaces.
	Interface string `json:"interface,omitempty"`

	// IPS sensor name.
	IpsSensor string `json:"ips-sensor,omitempty"`

	// Enable/disable IPS.
	IpsSensorStatus FirewallInterfacePolicyIpsSensorStatus `json:"ips-sensor-status,omitempty"`

	// Label.
	Label string `json:"label,omitempty"`

	// Logging type to be used in this policy (Options: all | utm | disable, Default: utm).
	Logtraffic FirewallInterfacePolicyLogtraffic `json:"logtraffic,omitempty"`

	// Policy ID.
	Policyid int `json:"policyid,omitempty"`

	// Enable/disable scanning for connections to Botnet servers.
	ScanBotnetConnections FirewallInterfacePolicyScanBotnetConnections `json:"scan-botnet-connections,omitempty"`

	// Service object from available options.
	Service []FirewallInterfacePolicyService `json:"service,omitempty"`

	// Antispam profile.
	SpamfilterProfile string `json:"spamfilter-profile,omitempty"`

	// Enable/disable antispam.
	SpamfilterProfileStatus FirewallInterfacePolicySpamfilterProfileStatus `json:"spamfilter-profile-status,omitempty"`

	// Address object to limit traffic monitoring to network traffic sent from the specified address or range.
	Srcaddr []FirewallInterfacePolicySrcaddr `json:"srcaddr,omitempty"`

	// Enable/disable this policy.
	Status FirewallInterfacePolicyStatus `json:"status,omitempty"`

	// Web filter profile.
	WebfilterProfile string `json:"webfilter-profile,omitempty"`

	// Enable/disable web filtering.
	WebfilterProfileStatus FirewallInterfacePolicyWebfilterProfileStatus `json:"webfilter-profile-status,omitempty"`
}

// Returns the value that identifies a FirewallInterfacePolicy
func (x *FirewallInterfacePolicy) MKey() int {
	return x.Policyid
}

// The results of a Get or List operation
type FirewallInterfacePolicyResults struct {
	Results []*FirewallInterfacePolicy `json:"results"`
	Mkey    int                        `json:"mkey"`
	Result
}

// List all FirewallInterfacePolicys
func (c *WebClient) ListFirewallInterfacePolicys() (res []*FirewallInterfacePolicy, err error) {
	var errmsg Result
	var results FirewallInterfacePolicyResults
	_, err = c.napping.Get(c.URL+"/api/v2/firewall/interface-policy", nil, &results, nil)
	if err != nil {
		return []*FirewallInterfacePolicy{}, fmt.Errorf("error listing FirewallInterfacePolicys: %s", err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return []*FirewallInterfacePolicy{}, fmt.Errorf("error listing FirewallInterfacePolicy: not found")
		} else {
			return []*FirewallInterfacePolicy{}, fmt.Errorf("error listing FirewallInterfacePolicy: %s", errmsg.Status)
		}
	}
	res = results.Results
	return
}

// Get a FirewallInterfacePolicy by name
func (c *WebClient) GetFirewallInterfacePolicy(mkey int) (res *FirewallInterfacePolicy, err error) {
	var errmsg Result
	var results FirewallInterfacePolicyResults
	_, err = c.napping.Get(c.URL+"/api/v2/firewall/interface-policy/"+strconv.Itoa(mkey), nil, &results, &errmsg)
	if err != nil {
		return &FirewallInterfacePolicy{}, fmt.Errorf("error getting FirewallInterfacePolicy '%s': %s", strconv.Itoa(mkey), err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return &FirewallInterfacePolicy{}, fmt.Errorf("error getting FirewallInterfacePolicy '%s': not found", strconv.Itoa(mkey))
		} else {
			return &FirewallInterfacePolicy{}, fmt.Errorf("error getting FirewallInterfacePolicy '%s': %s", strconv.Itoa(mkey), errmsg.Status)
		}
	}
	if len(results.Results) == 0 {
		return &FirewallInterfacePolicy{}, fmt.Errorf("error getting FirewallInterfacePolicy '%s': not found", strconv.Itoa(mkey))
	}

	res = results.Results[0]
	return
}

// Create a new FirewallInterfacePolicy
func (c *WebClient) CreateFirewallInterfacePolicy(obj *FirewallInterfacePolicy) (id int, err error) {
	var errmsg Result
	var results FirewallInterfacePolicyResults
	_, err = c.napping.Post(c.URL+"/api/v2/firewall/interface-policy", obj, &results, &errmsg)
	if err != nil {
		return 0, fmt.Errorf("error creating FirewallInterfacePolicy '%s': %s", strconv.Itoa(obj.Policyid), err.Error())
	}
	if results.HTTPStatus == 200 {
		return
	}
	if errmsg.HTTPStatus != 200 {
		return 0, fmt.Errorf("error creating FirewallInterfacePolicy '%s': %s", strconv.Itoa(obj.Policyid), errmsg.Status)
	}

	return
}

// Update a FirewallInterfacePolicy
func (c *WebClient) UpdateFirewallInterfacePolicy(obj *FirewallInterfacePolicy) (err error) {
	var errmsg Result
	var results FirewallInterfacePolicyResults
	_, err = c.napping.Put(c.URL+"/api/v2/firewall/interface-policy/"+strconv.Itoa(obj.Policyid), obj, &results, &errmsg)
	if err != nil {
		return fmt.Errorf("error updating FirewallInterfacePolicy '%s': %s", strconv.Itoa(obj.Policyid), err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return fmt.Errorf("error updating FirewallInterfacePolicy '%s': not found", strconv.Itoa(obj.Policyid))
		} else {
			return fmt.Errorf("error updating FirewallInterfacePolicy '%s': %s", strconv.Itoa(obj.Policyid), errmsg.Status)
		}
	}

	return
}

// Delete a FirewallInterfacePolicy by name
func (c *WebClient) DeleteFirewallInterfacePolicy(mkey int) (err error) {
	var errmsg Result
	var results FirewallInterfacePolicyResults
	_, err = c.napping.Delete(c.URL+"/api/v2/firewall/interface-policy/"+strconv.Itoa(mkey), nil, &results, &errmsg)
	if err != nil {
		return fmt.Errorf("error deleting FirewallInterfacePolicy '%s': %s", mkey, err.Error())
	}
	if results.HTTPStatus == 200 {
		return
	}
	if errmsg.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return fmt.Errorf("error deleting FirewallInterfacePolicy '%s': not found", mkey)
		}
		return fmt.Errorf("error deleting FirewallInterfacePolicy '%s': %s", mkey, errmsg.Status)
	}

	return
}

// List all FirewallInterfacePolicys
func (c *FakeClient) ListFirewallInterfacePolicys() (res []*FirewallInterfacePolicy, err error) {
	for _, r := range c.FirewallInterfacePolicys {
		res = append(res, r)
	}
	return
}

// Get a FirewallInterfacePolicy by name
func (c *FakeClient) GetFirewallInterfacePolicy(mkey int) (*FirewallInterfacePolicy, error) {
	if res, ok := c.FirewallInterfacePolicys[mkey]; ok {
		return res, nil
	} else {
		return &FirewallInterfacePolicy{}, fmt.Errorf("error getting FirewallInterfacePolicy '%s': not found", strconv.Itoa(mkey))
	}
}

// Create a new FirewallInterfacePolicy
func (c *FakeClient) CreateFirewallInterfacePolicy(obj *FirewallInterfacePolicy) (id int, err error) {
	id = c.FirewallInterfacePolicyCounter
	c.FirewallInterfacePolicyCounter++
	c.FirewallInterfacePolicys[id] = obj
	return
}

// Update a FirewallInterfacePolicy
func (c *FakeClient) UpdateFirewallInterfacePolicy(obj *FirewallInterfacePolicy) (err error) {
	c.FirewallInterfacePolicys[obj.Policyid] = obj
	return nil
}

// Delete a FirewallInterfacePolicy by name
func (c *FakeClient) DeleteFirewallInterfacePolicy(mkey int) (err error) {
	delete(c.FirewallInterfacePolicys, mkey)
	return nil
}

// Policy address type (IPv4 or IPv6).
type FirewallInterfacePolicy6AddressType string

// Enable/disable application control.
type FirewallInterfacePolicy6ApplicationListStatus string

// Enable/disable antivirus.
type FirewallInterfacePolicy6AvProfileStatus string

// Enable/disable DLP.
type FirewallInterfacePolicy6DlpSensorStatus string

// Enable/disable DSRI.
type FirewallInterfacePolicy6Dsri string

// IPv6 address object to limit traffic monitoring to network traffic sent to the specified address or range.
type FirewallInterfacePolicy6Dstaddr6 struct {

	// Address name.
	Name string `json:"name,omitempty"`
}

// Enable/disable IPS.
type FirewallInterfacePolicy6IpsSensorStatus string

// Logging type to be used in this policy (Options: all | utm | disable, Default: utm).
type FirewallInterfacePolicy6Logtraffic string

// Enable/disable scanning for connections to Botnet servers.
type FirewallInterfacePolicy6ScanBotnetConnections string

// Service name.
type FirewallInterfacePolicy6Service6 struct {

	// Address name.
	Name string `json:"name,omitempty"`
}

// Enable/disable antispam.
type FirewallInterfacePolicy6SpamfilterProfileStatus string

// IPv6 address object to limit traffic monitoring to network traffic sent from the specified address or range.
type FirewallInterfacePolicy6Srcaddr6 struct {

	// Address name.
	Name string `json:"name,omitempty"`
}

// Enable/disable this policy.
type FirewallInterfacePolicy6Status string

// Enable/disable web filtering.
type FirewallInterfacePolicy6WebfilterProfileStatus string

const (
	// IPv4.
	FirewallInterfacePolicy6AddressTypeIpv4 FirewallInterfacePolicy6AddressType = "ipv4"

	// IPv6.
	FirewallInterfacePolicy6AddressTypeIpv6 FirewallInterfacePolicy6AddressType = "ipv6"
)

const (
	// Enable application control
	FirewallInterfacePolicy6ApplicationListStatusEnable FirewallInterfacePolicy6ApplicationListStatus = "enable"

	// Disable application control
	FirewallInterfacePolicy6ApplicationListStatusDisable FirewallInterfacePolicy6ApplicationListStatus = "disable"
)

const (
	// Enable antivirus
	FirewallInterfacePolicy6AvProfileStatusEnable FirewallInterfacePolicy6AvProfileStatus = "enable"

	// Disable antivirus
	FirewallInterfacePolicy6AvProfileStatusDisable FirewallInterfacePolicy6AvProfileStatus = "disable"
)

const (
	// Enable setting.
	FirewallInterfacePolicy6DlpSensorStatusEnable FirewallInterfacePolicy6DlpSensorStatus = "enable"

	// Disable setting.
	FirewallInterfacePolicy6DlpSensorStatusDisable FirewallInterfacePolicy6DlpSensorStatus = "disable"
)

const (
	// Enable DSRI.
	FirewallInterfacePolicy6DsriEnable FirewallInterfacePolicy6Dsri = "enable"

	// Disable DSRI.
	FirewallInterfacePolicy6DsriDisable FirewallInterfacePolicy6Dsri = "disable"
)

const (
	// Enable IPS.
	FirewallInterfacePolicy6IpsSensorStatusEnable FirewallInterfacePolicy6IpsSensorStatus = "enable"

	// Disable IPS.
	FirewallInterfacePolicy6IpsSensorStatusDisable FirewallInterfacePolicy6IpsSensorStatus = "disable"
)

const (
	// Log all sessions accepted or denied by this policy.
	FirewallInterfacePolicy6LogtrafficAll FirewallInterfacePolicy6Logtraffic = "all"

	// Log traffic that has a security profile applied to it.
	FirewallInterfacePolicy6LogtrafficUtm FirewallInterfacePolicy6Logtraffic = "utm"

	// Disable all logging for this policy.
	FirewallInterfacePolicy6LogtrafficDisable FirewallInterfacePolicy6Logtraffic = "disable"
)

const (
	// Do not scan for connections to botnet servers.
	FirewallInterfacePolicy6ScanBotnetConnectionsDisable FirewallInterfacePolicy6ScanBotnetConnections = "disable"

	// Block connections to botnet servers.
	FirewallInterfacePolicy6ScanBotnetConnectionsBlock FirewallInterfacePolicy6ScanBotnetConnections = "block"

	// Log connections to botnet servers.
	FirewallInterfacePolicy6ScanBotnetConnectionsMonitor FirewallInterfacePolicy6ScanBotnetConnections = "monitor"
)

const (
	// Enable antispam.
	FirewallInterfacePolicy6SpamfilterProfileStatusEnable FirewallInterfacePolicy6SpamfilterProfileStatus = "enable"

	// Disable antispam.
	FirewallInterfacePolicy6SpamfilterProfileStatusDisable FirewallInterfacePolicy6SpamfilterProfileStatus = "disable"
)

const (
	// Enable this policy.
	FirewallInterfacePolicy6StatusEnable FirewallInterfacePolicy6Status = "enable"

	// Disable this policy.
	FirewallInterfacePolicy6StatusDisable FirewallInterfacePolicy6Status = "disable"
)

const (
	// Enable web filtering.
	FirewallInterfacePolicy6WebfilterProfileStatusEnable FirewallInterfacePolicy6WebfilterProfileStatus = "enable"

	// Disable web filtering.
	FirewallInterfacePolicy6WebfilterProfileStatusDisable FirewallInterfacePolicy6WebfilterProfileStatus = "disable"
)

// Configure IPv6 interface policies.
type FirewallInterfacePolicy6 struct {

	// Policy address type (IPv4 or IPv6).
	AddressType FirewallInterfacePolicy6AddressType `json:"address-type,omitempty"`

	// Application list name.
	ApplicationList string `json:"application-list,omitempty"`

	// Enable/disable application control.
	ApplicationListStatus FirewallInterfacePolicy6ApplicationListStatus `json:"application-list-status,omitempty"`

	// Antivirus profile.
	AvProfile string `json:"av-profile,omitempty"`

	// Enable/disable antivirus.
	AvProfileStatus FirewallInterfacePolicy6AvProfileStatus `json:"av-profile-status,omitempty"`

	// Comments.
	Comments string `json:"comments,omitempty"`

	// DLP sensor name.
	DlpSensor string `json:"dlp-sensor,omitempty"`

	// Enable/disable DLP.
	DlpSensorStatus FirewallInterfacePolicy6DlpSensorStatus `json:"dlp-sensor-status,omitempty"`

	// Enable/disable DSRI.
	Dsri FirewallInterfacePolicy6Dsri `json:"dsri,omitempty"`

	// IPv6 address object to limit traffic monitoring to network traffic sent to the specified address or range.
	Dstaddr6 []FirewallInterfacePolicy6Dstaddr6 `json:"dstaddr6,omitempty"`

	// Monitored interface name from available interfaces.
	Interface string `json:"interface,omitempty"`

	// IPS sensor name.
	IpsSensor string `json:"ips-sensor,omitempty"`

	// Enable/disable IPS.
	IpsSensorStatus FirewallInterfacePolicy6IpsSensorStatus `json:"ips-sensor-status,omitempty"`

	// Label.
	Label string `json:"label,omitempty"`

	// Logging type to be used in this policy (Options: all | utm | disable, Default: utm).
	Logtraffic FirewallInterfacePolicy6Logtraffic `json:"logtraffic,omitempty"`

	// Policy ID.
	Policyid int `json:"policyid,omitempty"`

	// Enable/disable scanning for connections to Botnet servers.
	ScanBotnetConnections FirewallInterfacePolicy6ScanBotnetConnections `json:"scan-botnet-connections,omitempty"`

	// Service name.
	Service6 []FirewallInterfacePolicy6Service6 `json:"service6,omitempty"`

	// Antispam profile.
	SpamfilterProfile string `json:"spamfilter-profile,omitempty"`

	// Enable/disable antispam.
	SpamfilterProfileStatus FirewallInterfacePolicy6SpamfilterProfileStatus `json:"spamfilter-profile-status,omitempty"`

	// IPv6 address object to limit traffic monitoring to network traffic sent from the specified address or range.
	Srcaddr6 []FirewallInterfacePolicy6Srcaddr6 `json:"srcaddr6,omitempty"`

	// Enable/disable this policy.
	Status FirewallInterfacePolicy6Status `json:"status,omitempty"`

	// Web filter profile.
	WebfilterProfile string `json:"webfilter-profile,omitempty"`

	// Enable/disable web filtering.
	WebfilterProfileStatus FirewallInterfacePolicy6WebfilterProfileStatus `json:"webfilter-profile-status,omitempty"`
}

// Returns the value that identifies a FirewallInterfacePolicy6
func (x *FirewallInterfacePolicy6) MKey() int {
	return x.Policyid
}

// The results of a Get or List operation
type FirewallInterfacePolicy6Results struct {
	Results []*FirewallInterfacePolicy6 `json:"results"`
	Mkey    int                         `json:"mkey"`
	Result
}

// List all FirewallInterfacePolicy6s
func (c *WebClient) ListFirewallInterfacePolicy6s() (res []*FirewallInterfacePolicy6, err error) {
	var errmsg Result
	var results FirewallInterfacePolicy6Results
	_, err = c.napping.Get(c.URL+"/api/v2/firewall/interface-policy6", nil, &results, nil)
	if err != nil {
		return []*FirewallInterfacePolicy6{}, fmt.Errorf("error listing FirewallInterfacePolicy6s: %s", err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return []*FirewallInterfacePolicy6{}, fmt.Errorf("error listing FirewallInterfacePolicy6: not found")
		} else {
			return []*FirewallInterfacePolicy6{}, fmt.Errorf("error listing FirewallInterfacePolicy6: %s", errmsg.Status)
		}
	}
	res = results.Results
	return
}

// Get a FirewallInterfacePolicy6 by name
func (c *WebClient) GetFirewallInterfacePolicy6(mkey int) (res *FirewallInterfacePolicy6, err error) {
	var errmsg Result
	var results FirewallInterfacePolicy6Results
	_, err = c.napping.Get(c.URL+"/api/v2/firewall/interface-policy6/"+strconv.Itoa(mkey), nil, &results, &errmsg)
	if err != nil {
		return &FirewallInterfacePolicy6{}, fmt.Errorf("error getting FirewallInterfacePolicy6 '%s': %s", strconv.Itoa(mkey), err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return &FirewallInterfacePolicy6{}, fmt.Errorf("error getting FirewallInterfacePolicy6 '%s': not found", strconv.Itoa(mkey))
		} else {
			return &FirewallInterfacePolicy6{}, fmt.Errorf("error getting FirewallInterfacePolicy6 '%s': %s", strconv.Itoa(mkey), errmsg.Status)
		}
	}
	if len(results.Results) == 0 {
		return &FirewallInterfacePolicy6{}, fmt.Errorf("error getting FirewallInterfacePolicy6 '%s': not found", strconv.Itoa(mkey))
	}

	res = results.Results[0]
	return
}

// Create a new FirewallInterfacePolicy6
func (c *WebClient) CreateFirewallInterfacePolicy6(obj *FirewallInterfacePolicy6) (id int, err error) {
	var errmsg Result
	var results FirewallInterfacePolicy6Results
	_, err = c.napping.Post(c.URL+"/api/v2/firewall/interface-policy6", obj, &results, &errmsg)
	if err != nil {
		return 0, fmt.Errorf("error creating FirewallInterfacePolicy6 '%s': %s", strconv.Itoa(obj.Policyid), err.Error())
	}
	if results.HTTPStatus == 200 {
		return
	}
	if errmsg.HTTPStatus != 200 {
		return 0, fmt.Errorf("error creating FirewallInterfacePolicy6 '%s': %s", strconv.Itoa(obj.Policyid), errmsg.Status)
	}

	return
}

// Update a FirewallInterfacePolicy6
func (c *WebClient) UpdateFirewallInterfacePolicy6(obj *FirewallInterfacePolicy6) (err error) {
	var errmsg Result
	var results FirewallInterfacePolicy6Results
	_, err = c.napping.Put(c.URL+"/api/v2/firewall/interface-policy6/"+strconv.Itoa(obj.Policyid), obj, &results, &errmsg)
	if err != nil {
		return fmt.Errorf("error updating FirewallInterfacePolicy6 '%s': %s", strconv.Itoa(obj.Policyid), err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return fmt.Errorf("error updating FirewallInterfacePolicy6 '%s': not found", strconv.Itoa(obj.Policyid))
		} else {
			return fmt.Errorf("error updating FirewallInterfacePolicy6 '%s': %s", strconv.Itoa(obj.Policyid), errmsg.Status)
		}
	}

	return
}

// Delete a FirewallInterfacePolicy6 by name
func (c *WebClient) DeleteFirewallInterfacePolicy6(mkey int) (err error) {
	var errmsg Result
	var results FirewallInterfacePolicy6Results
	_, err = c.napping.Delete(c.URL+"/api/v2/firewall/interface-policy6/"+strconv.Itoa(mkey), nil, &results, &errmsg)
	if err != nil {
		return fmt.Errorf("error deleting FirewallInterfacePolicy6 '%s': %s", mkey, err.Error())
	}
	if results.HTTPStatus == 200 {
		return
	}
	if errmsg.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return fmt.Errorf("error deleting FirewallInterfacePolicy6 '%s': not found", mkey)
		}
		return fmt.Errorf("error deleting FirewallInterfacePolicy6 '%s': %s", mkey, errmsg.Status)
	}

	return
}

// List all FirewallInterfacePolicy6s
func (c *FakeClient) ListFirewallInterfacePolicy6s() (res []*FirewallInterfacePolicy6, err error) {
	for _, r := range c.FirewallInterfacePolicy6s {
		res = append(res, r)
	}
	return
}

// Get a FirewallInterfacePolicy6 by name
func (c *FakeClient) GetFirewallInterfacePolicy6(mkey int) (*FirewallInterfacePolicy6, error) {
	if res, ok := c.FirewallInterfacePolicy6s[mkey]; ok {
		return res, nil
	} else {
		return &FirewallInterfacePolicy6{}, fmt.Errorf("error getting FirewallInterfacePolicy6 '%s': not found", strconv.Itoa(mkey))
	}
}

// Create a new FirewallInterfacePolicy6
func (c *FakeClient) CreateFirewallInterfacePolicy6(obj *FirewallInterfacePolicy6) (id int, err error) {
	id = c.FirewallInterfacePolicy6Counter
	c.FirewallInterfacePolicy6Counter++
	c.FirewallInterfacePolicy6s[id] = obj
	return
}

// Update a FirewallInterfacePolicy6
func (c *FakeClient) UpdateFirewallInterfacePolicy6(obj *FirewallInterfacePolicy6) (err error) {
	c.FirewallInterfacePolicy6s[obj.Policyid] = obj
	return nil
}

// Delete a FirewallInterfacePolicy6 by name
func (c *FakeClient) DeleteFirewallInterfacePolicy6(mkey int) (err error) {
	delete(c.FirewallInterfacePolicy6s, mkey)
	return nil
}

// Anomaly name.
type FirewallDoSPolicyAnomaly struct {

	// Action taken when the threshold is reached.
	Action string `json:"action,omitempty"`

	// Enable/disable logging for this anomaly.
	Log string `json:"log,omitempty"`

	// Anomaly name.
	Name string `json:"name,omitempty"`

	// Quarantine method.
	Quarantine string `json:"quarantine,omitempty"`

	// Duration of quarantine, from 1 minute to 364 days, 23 hours, and 59 minutes from now. (format: ###d##h##m, default = 5m). Requires quarantine set to attacker.
	QuarantineExpiry string `json:"quarantine-expiry,omitempty"`

	// Enable/disable quarantine logging.
	QuarantineLog string `json:"quarantine-log,omitempty"`

	// Enable/disable the active status of this anomaly sensor.
	Status string `json:"status,omitempty"`

	// Number of detected instances per minute which triggers action (1 - 2147483647, default = 1000). Note that each anomaly has a different threshold value assigned to it.
	Threshold int `json:"threshold,omitempty"`

	// Anomaly default threshold.
	Threshold_Default int `json:"threshold(default),omitempty"`
}

// Destination address name from available addresses.
type FirewallDoSPolicyDstaddr struct {

	// Address name.
	Name string `json:"name,omitempty"`
}

// Service object from available options.
type FirewallDoSPolicyService struct {

	// Service name.
	Name string `json:"name,omitempty"`
}

// Source address name from available addresses.
type FirewallDoSPolicySrcaddr struct {

	// Service name.
	Name string `json:"name,omitempty"`
}

// Enable/disable this policy.
type FirewallDoSPolicyStatus string

const (
	// Enable this policy.
	FirewallDoSPolicyStatusEnable FirewallDoSPolicyStatus = "enable"

	// Disable this policy.
	FirewallDoSPolicyStatusDisable FirewallDoSPolicyStatus = "disable"
)

// Configure IPv4 DoS policies.
type FirewallDoSPolicy struct {

	// Anomaly name.
	Anomaly []FirewallDoSPolicyAnomaly `json:"anomaly,omitempty"`

	// Comment.
	Comments string `json:"comments,omitempty"`

	// Destination address name from available addresses.
	Dstaddr []FirewallDoSPolicyDstaddr `json:"dstaddr,omitempty"`

	// Incoming interface name from available interfaces.
	Interface string `json:"interface,omitempty"`

	// Policy ID.
	Policyid int `json:"policyid,omitempty"`

	// Service object from available options.
	Service []FirewallDoSPolicyService `json:"service,omitempty"`

	// Source address name from available addresses.
	Srcaddr []FirewallDoSPolicySrcaddr `json:"srcaddr,omitempty"`

	// Enable/disable this policy.
	Status FirewallDoSPolicyStatus `json:"status,omitempty"`
}

// Returns the value that identifies a FirewallDoSPolicy
func (x *FirewallDoSPolicy) MKey() int {
	return x.Policyid
}

// The results of a Get or List operation
type FirewallDoSPolicyResults struct {
	Results []*FirewallDoSPolicy `json:"results"`
	Mkey    int                  `json:"mkey"`
	Result
}

// List all FirewallDoSPolicys
func (c *WebClient) ListFirewallDoSPolicys() (res []*FirewallDoSPolicy, err error) {
	var errmsg Result
	var results FirewallDoSPolicyResults
	_, err = c.napping.Get(c.URL+"/api/v2/firewall/DoS-policy", nil, &results, nil)
	if err != nil {
		return []*FirewallDoSPolicy{}, fmt.Errorf("error listing FirewallDoSPolicys: %s", err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return []*FirewallDoSPolicy{}, fmt.Errorf("error listing FirewallDoSPolicy: not found")
		} else {
			return []*FirewallDoSPolicy{}, fmt.Errorf("error listing FirewallDoSPolicy: %s", errmsg.Status)
		}
	}
	res = results.Results
	return
}

// Get a FirewallDoSPolicy by name
func (c *WebClient) GetFirewallDoSPolicy(mkey int) (res *FirewallDoSPolicy, err error) {
	var errmsg Result
	var results FirewallDoSPolicyResults
	_, err = c.napping.Get(c.URL+"/api/v2/firewall/DoS-policy/"+strconv.Itoa(mkey), nil, &results, &errmsg)
	if err != nil {
		return &FirewallDoSPolicy{}, fmt.Errorf("error getting FirewallDoSPolicy '%s': %s", strconv.Itoa(mkey), err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return &FirewallDoSPolicy{}, fmt.Errorf("error getting FirewallDoSPolicy '%s': not found", strconv.Itoa(mkey))
		} else {
			return &FirewallDoSPolicy{}, fmt.Errorf("error getting FirewallDoSPolicy '%s': %s", strconv.Itoa(mkey), errmsg.Status)
		}
	}
	if len(results.Results) == 0 {
		return &FirewallDoSPolicy{}, fmt.Errorf("error getting FirewallDoSPolicy '%s': not found", strconv.Itoa(mkey))
	}

	res = results.Results[0]
	return
}

// Create a new FirewallDoSPolicy
func (c *WebClient) CreateFirewallDoSPolicy(obj *FirewallDoSPolicy) (id int, err error) {
	var errmsg Result
	var results FirewallDoSPolicyResults
	_, err = c.napping.Post(c.URL+"/api/v2/firewall/DoS-policy", obj, &results, &errmsg)
	if err != nil {
		return 0, fmt.Errorf("error creating FirewallDoSPolicy '%s': %s", strconv.Itoa(obj.Policyid), err.Error())
	}
	if results.HTTPStatus == 200 {
		return
	}
	if errmsg.HTTPStatus != 200 {
		return 0, fmt.Errorf("error creating FirewallDoSPolicy '%s': %s", strconv.Itoa(obj.Policyid), errmsg.Status)
	}

	return
}

// Update a FirewallDoSPolicy
func (c *WebClient) UpdateFirewallDoSPolicy(obj *FirewallDoSPolicy) (err error) {
	var errmsg Result
	var results FirewallDoSPolicyResults
	_, err = c.napping.Put(c.URL+"/api/v2/firewall/DoS-policy/"+strconv.Itoa(obj.Policyid), obj, &results, &errmsg)
	if err != nil {
		return fmt.Errorf("error updating FirewallDoSPolicy '%s': %s", strconv.Itoa(obj.Policyid), err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return fmt.Errorf("error updating FirewallDoSPolicy '%s': not found", strconv.Itoa(obj.Policyid))
		} else {
			return fmt.Errorf("error updating FirewallDoSPolicy '%s': %s", strconv.Itoa(obj.Policyid), errmsg.Status)
		}
	}

	return
}

// Delete a FirewallDoSPolicy by name
func (c *WebClient) DeleteFirewallDoSPolicy(mkey int) (err error) {
	var errmsg Result
	var results FirewallDoSPolicyResults
	_, err = c.napping.Delete(c.URL+"/api/v2/firewall/DoS-policy/"+strconv.Itoa(mkey), nil, &results, &errmsg)
	if err != nil {
		return fmt.Errorf("error deleting FirewallDoSPolicy '%s': %s", mkey, err.Error())
	}
	if results.HTTPStatus == 200 {
		return
	}
	if errmsg.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return fmt.Errorf("error deleting FirewallDoSPolicy '%s': not found", mkey)
		}
		return fmt.Errorf("error deleting FirewallDoSPolicy '%s': %s", mkey, errmsg.Status)
	}

	return
}

// List all FirewallDoSPolicys
func (c *FakeClient) ListFirewallDoSPolicys() (res []*FirewallDoSPolicy, err error) {
	for _, r := range c.FirewallDoSPolicys {
		res = append(res, r)
	}
	return
}

// Get a FirewallDoSPolicy by name
func (c *FakeClient) GetFirewallDoSPolicy(mkey int) (*FirewallDoSPolicy, error) {
	if res, ok := c.FirewallDoSPolicys[mkey]; ok {
		return res, nil
	} else {
		return &FirewallDoSPolicy{}, fmt.Errorf("error getting FirewallDoSPolicy '%s': not found", strconv.Itoa(mkey))
	}
}

// Create a new FirewallDoSPolicy
func (c *FakeClient) CreateFirewallDoSPolicy(obj *FirewallDoSPolicy) (id int, err error) {
	id = c.FirewallDoSPolicyCounter
	c.FirewallDoSPolicyCounter++
	c.FirewallDoSPolicys[id] = obj
	return
}

// Update a FirewallDoSPolicy
func (c *FakeClient) UpdateFirewallDoSPolicy(obj *FirewallDoSPolicy) (err error) {
	c.FirewallDoSPolicys[obj.Policyid] = obj
	return nil
}

// Delete a FirewallDoSPolicy by name
func (c *FakeClient) DeleteFirewallDoSPolicy(mkey int) (err error) {
	delete(c.FirewallDoSPolicys, mkey)
	return nil
}

// Anomaly name.
type FirewallDoSPolicy6Anomaly struct {

	// Action taken when the threshold is reached.
	Action string `json:"action,omitempty"`

	// Enable/disable logging for this anomaly.
	Log string `json:"log,omitempty"`

	// Anomaly name.
	Name string `json:"name,omitempty"`

	// Quarantine method.
	Quarantine string `json:"quarantine,omitempty"`

	// Duration of quarantine, from 1 minute to 364 days, 23 hours, and 59 minutes from now. (format: ###d##h##m, default = 5m). Requires quarantine set to attacker.
	QuarantineExpiry string `json:"quarantine-expiry,omitempty"`

	// Enable/disable quarantine logging.
	QuarantineLog string `json:"quarantine-log,omitempty"`

	// Enable/disable the active status of this anomaly sensor.
	Status string `json:"status,omitempty"`

	// Number of detected instances per minute which triggers action (1 - 2147483647, default = 1000). Note that each anomaly has a different threshold value assigned to it.
	Threshold int `json:"threshold,omitempty"`

	// Anomaly default threshold.
	Threshold_Default int `json:"threshold(default),omitempty"`
}

// Destination address name from available addresses.
type FirewallDoSPolicy6Dstaddr struct {

	// Address name.
	Name string `json:"name,omitempty"`
}

// Service object from available options.
type FirewallDoSPolicy6Service struct {

	// Service name.
	Name string `json:"name,omitempty"`
}

// Source address name from available addresses.
type FirewallDoSPolicy6Srcaddr struct {

	// Service name.
	Name string `json:"name,omitempty"`
}

// Enable/disable this policy.
type FirewallDoSPolicy6Status string

const (
	// Enable this policy.
	FirewallDoSPolicy6StatusEnable FirewallDoSPolicy6Status = "enable"

	// Disable this policy.
	FirewallDoSPolicy6StatusDisable FirewallDoSPolicy6Status = "disable"
)

// Configure IPv6 DoS policies.
type FirewallDoSPolicy6 struct {

	// Anomaly name.
	Anomaly []FirewallDoSPolicy6Anomaly `json:"anomaly,omitempty"`

	// Comment.
	Comments string `json:"comments,omitempty"`

	// Destination address name from available addresses.
	Dstaddr []FirewallDoSPolicy6Dstaddr `json:"dstaddr,omitempty"`

	// Incoming interface name from available interfaces.
	Interface string `json:"interface,omitempty"`

	// Policy ID.
	Policyid int `json:"policyid,omitempty"`

	// Service object from available options.
	Service []FirewallDoSPolicy6Service `json:"service,omitempty"`

	// Source address name from available addresses.
	Srcaddr []FirewallDoSPolicy6Srcaddr `json:"srcaddr,omitempty"`

	// Enable/disable this policy.
	Status FirewallDoSPolicy6Status `json:"status,omitempty"`
}

// Returns the value that identifies a FirewallDoSPolicy6
func (x *FirewallDoSPolicy6) MKey() int {
	return x.Policyid
}

// The results of a Get or List operation
type FirewallDoSPolicy6Results struct {
	Results []*FirewallDoSPolicy6 `json:"results"`
	Mkey    int                   `json:"mkey"`
	Result
}

// List all FirewallDoSPolicy6s
func (c *WebClient) ListFirewallDoSPolicy6s() (res []*FirewallDoSPolicy6, err error) {
	var errmsg Result
	var results FirewallDoSPolicy6Results
	_, err = c.napping.Get(c.URL+"/api/v2/firewall/DoS-policy6", nil, &results, nil)
	if err != nil {
		return []*FirewallDoSPolicy6{}, fmt.Errorf("error listing FirewallDoSPolicy6s: %s", err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return []*FirewallDoSPolicy6{}, fmt.Errorf("error listing FirewallDoSPolicy6: not found")
		} else {
			return []*FirewallDoSPolicy6{}, fmt.Errorf("error listing FirewallDoSPolicy6: %s", errmsg.Status)
		}
	}
	res = results.Results
	return
}

// Get a FirewallDoSPolicy6 by name
func (c *WebClient) GetFirewallDoSPolicy6(mkey int) (res *FirewallDoSPolicy6, err error) {
	var errmsg Result
	var results FirewallDoSPolicy6Results
	_, err = c.napping.Get(c.URL+"/api/v2/firewall/DoS-policy6/"+strconv.Itoa(mkey), nil, &results, &errmsg)
	if err != nil {
		return &FirewallDoSPolicy6{}, fmt.Errorf("error getting FirewallDoSPolicy6 '%s': %s", strconv.Itoa(mkey), err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return &FirewallDoSPolicy6{}, fmt.Errorf("error getting FirewallDoSPolicy6 '%s': not found", strconv.Itoa(mkey))
		} else {
			return &FirewallDoSPolicy6{}, fmt.Errorf("error getting FirewallDoSPolicy6 '%s': %s", strconv.Itoa(mkey), errmsg.Status)
		}
	}
	if len(results.Results) == 0 {
		return &FirewallDoSPolicy6{}, fmt.Errorf("error getting FirewallDoSPolicy6 '%s': not found", strconv.Itoa(mkey))
	}

	res = results.Results[0]
	return
}

// Create a new FirewallDoSPolicy6
func (c *WebClient) CreateFirewallDoSPolicy6(obj *FirewallDoSPolicy6) (id int, err error) {
	var errmsg Result
	var results FirewallDoSPolicy6Results
	_, err = c.napping.Post(c.URL+"/api/v2/firewall/DoS-policy6", obj, &results, &errmsg)
	if err != nil {
		return 0, fmt.Errorf("error creating FirewallDoSPolicy6 '%s': %s", strconv.Itoa(obj.Policyid), err.Error())
	}
	if results.HTTPStatus == 200 {
		return
	}
	if errmsg.HTTPStatus != 200 {
		return 0, fmt.Errorf("error creating FirewallDoSPolicy6 '%s': %s", strconv.Itoa(obj.Policyid), errmsg.Status)
	}

	return
}

// Update a FirewallDoSPolicy6
func (c *WebClient) UpdateFirewallDoSPolicy6(obj *FirewallDoSPolicy6) (err error) {
	var errmsg Result
	var results FirewallDoSPolicy6Results
	_, err = c.napping.Put(c.URL+"/api/v2/firewall/DoS-policy6/"+strconv.Itoa(obj.Policyid), obj, &results, &errmsg)
	if err != nil {
		return fmt.Errorf("error updating FirewallDoSPolicy6 '%s': %s", strconv.Itoa(obj.Policyid), err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return fmt.Errorf("error updating FirewallDoSPolicy6 '%s': not found", strconv.Itoa(obj.Policyid))
		} else {
			return fmt.Errorf("error updating FirewallDoSPolicy6 '%s': %s", strconv.Itoa(obj.Policyid), errmsg.Status)
		}
	}

	return
}

// Delete a FirewallDoSPolicy6 by name
func (c *WebClient) DeleteFirewallDoSPolicy6(mkey int) (err error) {
	var errmsg Result
	var results FirewallDoSPolicy6Results
	_, err = c.napping.Delete(c.URL+"/api/v2/firewall/DoS-policy6/"+strconv.Itoa(mkey), nil, &results, &errmsg)
	if err != nil {
		return fmt.Errorf("error deleting FirewallDoSPolicy6 '%s': %s", mkey, err.Error())
	}
	if results.HTTPStatus == 200 {
		return
	}
	if errmsg.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return fmt.Errorf("error deleting FirewallDoSPolicy6 '%s': not found", mkey)
		}
		return fmt.Errorf("error deleting FirewallDoSPolicy6 '%s': %s", mkey, errmsg.Status)
	}

	return
}

// List all FirewallDoSPolicy6s
func (c *FakeClient) ListFirewallDoSPolicy6s() (res []*FirewallDoSPolicy6, err error) {
	for _, r := range c.FirewallDoSPolicy6s {
		res = append(res, r)
	}
	return
}

// Get a FirewallDoSPolicy6 by name
func (c *FakeClient) GetFirewallDoSPolicy6(mkey int) (*FirewallDoSPolicy6, error) {
	if res, ok := c.FirewallDoSPolicy6s[mkey]; ok {
		return res, nil
	} else {
		return &FirewallDoSPolicy6{}, fmt.Errorf("error getting FirewallDoSPolicy6 '%s': not found", strconv.Itoa(mkey))
	}
}

// Create a new FirewallDoSPolicy6
func (c *FakeClient) CreateFirewallDoSPolicy6(obj *FirewallDoSPolicy6) (id int, err error) {
	id = c.FirewallDoSPolicy6Counter
	c.FirewallDoSPolicy6Counter++
	c.FirewallDoSPolicy6s[id] = obj
	return
}

// Update a FirewallDoSPolicy6
func (c *FakeClient) UpdateFirewallDoSPolicy6(obj *FirewallDoSPolicy6) (err error) {
	c.FirewallDoSPolicy6s[obj.Policyid] = obj
	return nil
}

// Delete a FirewallDoSPolicy6 by name
func (c *FakeClient) DeleteFirewallDoSPolicy6(mkey int) (err error) {
	delete(c.FirewallDoSPolicy6s, mkey)
	return nil
}

// Configuration method to edit Denial of Service (DoS) anomaly settings.
type FirewallSnifferAnomaly struct {

	// Action taken when the threshold is reached.
	Action string `json:"action,omitempty"`

	// Enable/disable logging for this anomaly.
	Log string `json:"log,omitempty"`

	// Anomaly name.
	Name string `json:"name,omitempty"`

	// Quarantine method.
	Quarantine string `json:"quarantine,omitempty"`

	// Duration of quarantine, from 1 minute to 364 days, 23 hours, and 59 minutes from now. (format: ###d##h##m, default = 5m). Requires quarantine set to attacker.
	QuarantineExpiry string `json:"quarantine-expiry,omitempty"`

	// Enable/disable quarantine logging.
	QuarantineLog string `json:"quarantine-log,omitempty"`

	// Enable/disable the active status of this anomaly sensor.
	Status string `json:"status,omitempty"`

	// Number of detected instances per minute which triggers action (1 - 2147483647, default = 1000). Note that each anomaly has a different threshold value assigned to it.
	Threshold int `json:"threshold,omitempty"`

	// Anomaly default threshold.
	Threshold_Default int `json:"threshold(default),omitempty"`
}

// Enable/disable application control profile.
type FirewallSnifferApplicationListStatus string

// Enable/disable antivirus profile.
type FirewallSnifferAvProfileStatus string

// Enable/disable DLP sensor.
type FirewallSnifferDlpSensorStatus string

// Enable/disable DSRI.
type FirewallSnifferDsri string

// Enable/disable IPS DoS anomaly detection.
type FirewallSnifferIpsDosStatus string

// Enable/disable IPS sensor.
type FirewallSnifferIpsSensorStatus string

// Enable/disable sniffing IPv6 packets.
type FirewallSnifferIpv6 string

// Either log all sessions, only sessions that have a security profile applied, or disable all logging for this policy.
type FirewallSnifferLogtraffic string

// Enable/disable sniffing non-IP packets.
type FirewallSnifferNonIp string

// Enable/disable scanning of connections to Botnet servers.
type FirewallSnifferScanBotnetConnections string

// Enable/disable spam filter.
type FirewallSnifferSpamfilterProfileStatus string

// Enable/disable the active status of the sniffer.
type FirewallSnifferStatus string

// Enable/disable web filter profile.
type FirewallSnifferWebfilterProfileStatus string

const (
	// Enable setting.
	FirewallSnifferApplicationListStatusEnable FirewallSnifferApplicationListStatus = "enable"

	// Disable setting.
	FirewallSnifferApplicationListStatusDisable FirewallSnifferApplicationListStatus = "disable"
)

const (
	// Enable setting.
	FirewallSnifferAvProfileStatusEnable FirewallSnifferAvProfileStatus = "enable"

	// Disable setting.
	FirewallSnifferAvProfileStatusDisable FirewallSnifferAvProfileStatus = "disable"
)

const (
	// Enable setting.
	FirewallSnifferDlpSensorStatusEnable FirewallSnifferDlpSensorStatus = "enable"

	// Disable setting.
	FirewallSnifferDlpSensorStatusDisable FirewallSnifferDlpSensorStatus = "disable"
)

const (
	// Enable DSRI.
	FirewallSnifferDsriEnable FirewallSnifferDsri = "enable"

	// Disable DSRI.
	FirewallSnifferDsriDisable FirewallSnifferDsri = "disable"
)

const (
	// Enable setting.
	FirewallSnifferIpsDosStatusEnable FirewallSnifferIpsDosStatus = "enable"

	// Disable setting.
	FirewallSnifferIpsDosStatusDisable FirewallSnifferIpsDosStatus = "disable"
)

const (
	// Enable setting.
	FirewallSnifferIpsSensorStatusEnable FirewallSnifferIpsSensorStatus = "enable"

	// Disable setting.
	FirewallSnifferIpsSensorStatusDisable FirewallSnifferIpsSensorStatus = "disable"
)

const (
	// Enable sniffer for IPv6 packets.
	FirewallSnifferIpv6Enable FirewallSnifferIpv6 = "enable"

	// Disable sniffer for IPv6 packets.
	FirewallSnifferIpv6Disable FirewallSnifferIpv6 = "disable"
)

const (
	// Log all sessions accepted or denied by this policy.
	FirewallSnifferLogtrafficAll FirewallSnifferLogtraffic = "all"

	// Log traffic that has a security profile applied to it.
	FirewallSnifferLogtrafficUtm FirewallSnifferLogtraffic = "utm"

	// Disable all logging for this policy.
	FirewallSnifferLogtrafficDisable FirewallSnifferLogtraffic = "disable"
)

const (
	// Enable sniffer for non-IP packets.
	FirewallSnifferNonIpEnable FirewallSnifferNonIp = "enable"

	// Disable sniffer for non-IP packets.
	FirewallSnifferNonIpDisable FirewallSnifferNonIp = "disable"
)

const (
	// Do not scan connections to botnet servers.
	FirewallSnifferScanBotnetConnectionsDisable FirewallSnifferScanBotnetConnections = "disable"

	// Block connections to botnet servers.
	FirewallSnifferScanBotnetConnectionsBlock FirewallSnifferScanBotnetConnections = "block"

	// Log connections to botnet servers.
	FirewallSnifferScanBotnetConnectionsMonitor FirewallSnifferScanBotnetConnections = "monitor"
)

const (
	// Enable setting.
	FirewallSnifferSpamfilterProfileStatusEnable FirewallSnifferSpamfilterProfileStatus = "enable"

	// Disable setting.
	FirewallSnifferSpamfilterProfileStatusDisable FirewallSnifferSpamfilterProfileStatus = "disable"
)

const (
	// Enable sniffer status.
	FirewallSnifferStatusEnable FirewallSnifferStatus = "enable"

	// Disable sniffer status.
	FirewallSnifferStatusDisable FirewallSnifferStatus = "disable"
)

const (
	// Enable setting.
	FirewallSnifferWebfilterProfileStatusEnable FirewallSnifferWebfilterProfileStatus = "enable"

	// Disable setting.
	FirewallSnifferWebfilterProfileStatusDisable FirewallSnifferWebfilterProfileStatus = "disable"
)

// Configure sniffer.
type FirewallSniffer struct {

	// Configuration method to edit Denial of Service (DoS) anomaly settings.
	Anomaly []FirewallSnifferAnomaly `json:"anomaly,omitempty"`

	// Name of an existing application list.
	ApplicationList string `json:"application-list,omitempty"`

	// Enable/disable application control profile.
	ApplicationListStatus FirewallSnifferApplicationListStatus `json:"application-list-status,omitempty"`

	// Name of an existing antivirus profile.
	AvProfile string `json:"av-profile,omitempty"`

	// Enable/disable antivirus profile.
	AvProfileStatus FirewallSnifferAvProfileStatus `json:"av-profile-status,omitempty"`

	// Name of an existing DLP sensor.
	DlpSensor string `json:"dlp-sensor,omitempty"`

	// Enable/disable DLP sensor.
	DlpSensorStatus FirewallSnifferDlpSensorStatus `json:"dlp-sensor-status,omitempty"`

	// Enable/disable DSRI.
	Dsri FirewallSnifferDsri `json:"dsri,omitempty"`

	// Hosts to filter for in sniffer traffic (Format examples: 1.1.1.1, 2.2.2.0/24, 3.3.3.3/255.255.255.0, 4.4.4.0-4.4.4.240).
	Host string `json:"host,omitempty"`

	// Sniffer ID.
	Id int `json:"id,omitempty"`

	// Interface name that traffic sniffing will take place on.
	Interface string `json:"interface,omitempty"`

	// Enable/disable IPS DoS anomaly detection.
	IpsDosStatus FirewallSnifferIpsDosStatus `json:"ips-dos-status,omitempty"`

	// Name of an existing IPS sensor.
	IpsSensor string `json:"ips-sensor,omitempty"`

	// Enable/disable IPS sensor.
	IpsSensorStatus FirewallSnifferIpsSensorStatus `json:"ips-sensor-status,omitempty"`

	// Enable/disable sniffing IPv6 packets.
	Ipv6 FirewallSnifferIpv6 `json:"ipv6,omitempty"`

	// Either log all sessions, only sessions that have a security profile applied, or disable all logging for this policy.
	Logtraffic FirewallSnifferLogtraffic `json:"logtraffic,omitempty"`

	// Maximum packet count (1 - 1000000, default = 10000).
	MaxPacketCount int `json:"max-packet-count,omitempty"`

	// Enable/disable sniffing non-IP packets.
	NonIp FirewallSnifferNonIp `json:"non-ip,omitempty"`

	// Ports to sniff (Format examples: 10, :20, 30:40, 50-, 100-200).
	Port string `json:"port,omitempty"`

	// Integer value for the protocol type as defined by IANA (0 - 255).
	Protocol string `json:"protocol,omitempty"`

	// Enable/disable scanning of connections to Botnet servers.
	ScanBotnetConnections FirewallSnifferScanBotnetConnections `json:"scan-botnet-connections,omitempty"`

	// Name of an existing spam filter profile.
	SpamfilterProfile string `json:"spamfilter-profile,omitempty"`

	// Enable/disable spam filter.
	SpamfilterProfileStatus FirewallSnifferSpamfilterProfileStatus `json:"spamfilter-profile-status,omitempty"`

	// Enable/disable the active status of the sniffer.
	Status FirewallSnifferStatus `json:"status,omitempty"`

	// List of VLANs to sniff.
	Vlan string `json:"vlan,omitempty"`

	// Name of an existing web filter profile.
	WebfilterProfile string `json:"webfilter-profile,omitempty"`

	// Enable/disable web filter profile.
	WebfilterProfileStatus FirewallSnifferWebfilterProfileStatus `json:"webfilter-profile-status,omitempty"`
}

// Returns the value that identifies a FirewallSniffer
func (x *FirewallSniffer) MKey() int {
	return x.Id
}

// The results of a Get or List operation
type FirewallSnifferResults struct {
	Results []*FirewallSniffer `json:"results"`
	Mkey    int                `json:"mkey"`
	Result
}

// List all FirewallSniffers
func (c *WebClient) ListFirewallSniffers() (res []*FirewallSniffer, err error) {
	var errmsg Result
	var results FirewallSnifferResults
	_, err = c.napping.Get(c.URL+"/api/v2/firewall/sniffer", nil, &results, nil)
	if err != nil {
		return []*FirewallSniffer{}, fmt.Errorf("error listing FirewallSniffers: %s", err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return []*FirewallSniffer{}, fmt.Errorf("error listing FirewallSniffer: not found")
		} else {
			return []*FirewallSniffer{}, fmt.Errorf("error listing FirewallSniffer: %s", errmsg.Status)
		}
	}
	res = results.Results
	return
}

// Get a FirewallSniffer by name
func (c *WebClient) GetFirewallSniffer(mkey int) (res *FirewallSniffer, err error) {
	var errmsg Result
	var results FirewallSnifferResults
	_, err = c.napping.Get(c.URL+"/api/v2/firewall/sniffer/"+strconv.Itoa(mkey), nil, &results, &errmsg)
	if err != nil {
		return &FirewallSniffer{}, fmt.Errorf("error getting FirewallSniffer '%s': %s", strconv.Itoa(mkey), err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return &FirewallSniffer{}, fmt.Errorf("error getting FirewallSniffer '%s': not found", strconv.Itoa(mkey))
		} else {
			return &FirewallSniffer{}, fmt.Errorf("error getting FirewallSniffer '%s': %s", strconv.Itoa(mkey), errmsg.Status)
		}
	}
	if len(results.Results) == 0 {
		return &FirewallSniffer{}, fmt.Errorf("error getting FirewallSniffer '%s': not found", strconv.Itoa(mkey))
	}

	res = results.Results[0]
	return
}

// Create a new FirewallSniffer
func (c *WebClient) CreateFirewallSniffer(obj *FirewallSniffer) (id int, err error) {
	var errmsg Result
	var results FirewallSnifferResults
	_, err = c.napping.Post(c.URL+"/api/v2/firewall/sniffer", obj, &results, &errmsg)
	if err != nil {
		return 0, fmt.Errorf("error creating FirewallSniffer '%s': %s", strconv.Itoa(obj.Id), err.Error())
	}
	if results.HTTPStatus == 200 {
		return
	}
	if errmsg.HTTPStatus != 200 {
		return 0, fmt.Errorf("error creating FirewallSniffer '%s': %s", strconv.Itoa(obj.Id), errmsg.Status)
	}

	return
}

// Update a FirewallSniffer
func (c *WebClient) UpdateFirewallSniffer(obj *FirewallSniffer) (err error) {
	var errmsg Result
	var results FirewallSnifferResults
	_, err = c.napping.Put(c.URL+"/api/v2/firewall/sniffer/"+strconv.Itoa(obj.Id), obj, &results, &errmsg)
	if err != nil {
		return fmt.Errorf("error updating FirewallSniffer '%s': %s", strconv.Itoa(obj.Id), err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return fmt.Errorf("error updating FirewallSniffer '%s': not found", strconv.Itoa(obj.Id))
		} else {
			return fmt.Errorf("error updating FirewallSniffer '%s': %s", strconv.Itoa(obj.Id), errmsg.Status)
		}
	}

	return
}

// Delete a FirewallSniffer by name
func (c *WebClient) DeleteFirewallSniffer(mkey int) (err error) {
	var errmsg Result
	var results FirewallSnifferResults
	_, err = c.napping.Delete(c.URL+"/api/v2/firewall/sniffer/"+strconv.Itoa(mkey), nil, &results, &errmsg)
	if err != nil {
		return fmt.Errorf("error deleting FirewallSniffer '%s': %s", mkey, err.Error())
	}
	if results.HTTPStatus == 200 {
		return
	}
	if errmsg.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return fmt.Errorf("error deleting FirewallSniffer '%s': not found", mkey)
		}
		return fmt.Errorf("error deleting FirewallSniffer '%s': %s", mkey, errmsg.Status)
	}

	return
}

// List all FirewallSniffers
func (c *FakeClient) ListFirewallSniffers() (res []*FirewallSniffer, err error) {
	for _, r := range c.FirewallSniffers {
		res = append(res, r)
	}
	return
}

// Get a FirewallSniffer by name
func (c *FakeClient) GetFirewallSniffer(mkey int) (*FirewallSniffer, error) {
	if res, ok := c.FirewallSniffers[mkey]; ok {
		return res, nil
	} else {
		return &FirewallSniffer{}, fmt.Errorf("error getting FirewallSniffer '%s': not found", strconv.Itoa(mkey))
	}
}

// Create a new FirewallSniffer
func (c *FakeClient) CreateFirewallSniffer(obj *FirewallSniffer) (id int, err error) {
	id = c.FirewallSnifferCounter
	c.FirewallSnifferCounter++
	c.FirewallSniffers[id] = obj
	return
}

// Update a FirewallSniffer
func (c *FakeClient) UpdateFirewallSniffer(obj *FirewallSniffer) (err error) {
	c.FirewallSniffers[obj.Id] = obj
	return nil
}

// Delete a FirewallSniffer by name
func (c *FakeClient) DeleteFirewallSniffer(mkey int) (err error) {
	delete(c.FirewallSniffers, mkey)
	return nil
}

// Destination address name from available addresses.
type FirewallCentralSnatMapDstAddr struct {

	// Address name.
	Name string `json:"name,omitempty"`
}

// Destination interface name from available interfaces.
type FirewallCentralSnatMapDstintf struct {

	// Interface name.
	Name string `json:"name,omitempty"`
}

// Enable/disable source NAT.
type FirewallCentralSnatMapNat string

// Name of the IP pools to be used to translate addresses from available IP Pools.
type FirewallCentralSnatMapNatIppool struct {

	// IP pool name.
	Name string `json:"name,omitempty"`
}

// Original address.
type FirewallCentralSnatMapOrigAddr struct {

	// Address name.
	Name string `json:"name,omitempty"`
}

// Source interface name from available interfaces.
type FirewallCentralSnatMapSrcintf struct {

	// Interface name.
	Name string `json:"name,omitempty"`
}

// Enable/disable the active status of this policy.
type FirewallCentralSnatMapStatus string

const (
	// Disable source NAT.
	FirewallCentralSnatMapNatDisable FirewallCentralSnatMapNat = "disable"

	// Enable source NAT.
	FirewallCentralSnatMapNatEnable FirewallCentralSnatMapNat = "enable"
)

const (
	// Enable this policy.
	FirewallCentralSnatMapStatusEnable FirewallCentralSnatMapStatus = "enable"

	// Disable this policy.
	FirewallCentralSnatMapStatusDisable FirewallCentralSnatMapStatus = "disable"
)

// Configure central SNAT policies.
type FirewallCentralSnatMap struct {

	// Destination address name from available addresses.
	DstAddr []FirewallCentralSnatMapDstAddr `json:"dst-addr,omitempty"`

	// Destination interface name from available interfaces.
	Dstintf []FirewallCentralSnatMapDstintf `json:"dstintf,omitempty"`

	// Enable/disable source NAT.
	Nat FirewallCentralSnatMapNat `json:"nat,omitempty"`

	// Name of the IP pools to be used to translate addresses from available IP Pools.
	NatIppool []FirewallCentralSnatMapNatIppool `json:"nat-ippool,omitempty"`

	// Translated port or port range (0 to 65535).
	NatPort string `json:"nat-port,omitempty"`

	// Original address.
	OrigAddr []FirewallCentralSnatMapOrigAddr `json:"orig-addr,omitempty"`

	// Original TCP port (0 to 65535).
	OrigPort int `json:"orig-port,omitempty"`

	// Policy ID.
	Policyid int `json:"policyid,omitempty"`

	// Integer value for the protocol type (0 - 255).
	Protocol int `json:"protocol,omitempty"`

	// Source interface name from available interfaces.
	Srcintf []FirewallCentralSnatMapSrcintf `json:"srcintf,omitempty"`

	// Enable/disable the active status of this policy.
	Status FirewallCentralSnatMapStatus `json:"status,omitempty"`
}

// Returns the value that identifies a FirewallCentralSnatMap
func (x *FirewallCentralSnatMap) MKey() int {
	return x.Policyid
}

// The results of a Get or List operation
type FirewallCentralSnatMapResults struct {
	Results []*FirewallCentralSnatMap `json:"results"`
	Mkey    int                       `json:"mkey"`
	Result
}

// List all FirewallCentralSnatMaps
func (c *WebClient) ListFirewallCentralSnatMaps() (res []*FirewallCentralSnatMap, err error) {
	var errmsg Result
	var results FirewallCentralSnatMapResults
	_, err = c.napping.Get(c.URL+"/api/v2/firewall/central-snat-map", nil, &results, nil)
	if err != nil {
		return []*FirewallCentralSnatMap{}, fmt.Errorf("error listing FirewallCentralSnatMaps: %s", err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return []*FirewallCentralSnatMap{}, fmt.Errorf("error listing FirewallCentralSnatMap: not found")
		} else {
			return []*FirewallCentralSnatMap{}, fmt.Errorf("error listing FirewallCentralSnatMap: %s", errmsg.Status)
		}
	}
	res = results.Results
	return
}

// Get a FirewallCentralSnatMap by name
func (c *WebClient) GetFirewallCentralSnatMap(mkey int) (res *FirewallCentralSnatMap, err error) {
	var errmsg Result
	var results FirewallCentralSnatMapResults
	_, err = c.napping.Get(c.URL+"/api/v2/firewall/central-snat-map/"+strconv.Itoa(mkey), nil, &results, &errmsg)
	if err != nil {
		return &FirewallCentralSnatMap{}, fmt.Errorf("error getting FirewallCentralSnatMap '%s': %s", strconv.Itoa(mkey), err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return &FirewallCentralSnatMap{}, fmt.Errorf("error getting FirewallCentralSnatMap '%s': not found", strconv.Itoa(mkey))
		} else {
			return &FirewallCentralSnatMap{}, fmt.Errorf("error getting FirewallCentralSnatMap '%s': %s", strconv.Itoa(mkey), errmsg.Status)
		}
	}
	if len(results.Results) == 0 {
		return &FirewallCentralSnatMap{}, fmt.Errorf("error getting FirewallCentralSnatMap '%s': not found", strconv.Itoa(mkey))
	}

	res = results.Results[0]
	return
}

// Create a new FirewallCentralSnatMap
func (c *WebClient) CreateFirewallCentralSnatMap(obj *FirewallCentralSnatMap) (id int, err error) {
	var errmsg Result
	var results FirewallCentralSnatMapResults
	_, err = c.napping.Post(c.URL+"/api/v2/firewall/central-snat-map", obj, &results, &errmsg)
	if err != nil {
		return 0, fmt.Errorf("error creating FirewallCentralSnatMap '%s': %s", strconv.Itoa(obj.Policyid), err.Error())
	}
	if results.HTTPStatus == 200 {
		return
	}
	if errmsg.HTTPStatus != 200 {
		return 0, fmt.Errorf("error creating FirewallCentralSnatMap '%s': %s", strconv.Itoa(obj.Policyid), errmsg.Status)
	}

	return
}

// Update a FirewallCentralSnatMap
func (c *WebClient) UpdateFirewallCentralSnatMap(obj *FirewallCentralSnatMap) (err error) {
	var errmsg Result
	var results FirewallCentralSnatMapResults
	_, err = c.napping.Put(c.URL+"/api/v2/firewall/central-snat-map/"+strconv.Itoa(obj.Policyid), obj, &results, &errmsg)
	if err != nil {
		return fmt.Errorf("error updating FirewallCentralSnatMap '%s': %s", strconv.Itoa(obj.Policyid), err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return fmt.Errorf("error updating FirewallCentralSnatMap '%s': not found", strconv.Itoa(obj.Policyid))
		} else {
			return fmt.Errorf("error updating FirewallCentralSnatMap '%s': %s", strconv.Itoa(obj.Policyid), errmsg.Status)
		}
	}

	return
}

// Delete a FirewallCentralSnatMap by name
func (c *WebClient) DeleteFirewallCentralSnatMap(mkey int) (err error) {
	var errmsg Result
	var results FirewallCentralSnatMapResults
	_, err = c.napping.Delete(c.URL+"/api/v2/firewall/central-snat-map/"+strconv.Itoa(mkey), nil, &results, &errmsg)
	if err != nil {
		return fmt.Errorf("error deleting FirewallCentralSnatMap '%s': %s", mkey, err.Error())
	}
	if results.HTTPStatus == 200 {
		return
	}
	if errmsg.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return fmt.Errorf("error deleting FirewallCentralSnatMap '%s': not found", mkey)
		}
		return fmt.Errorf("error deleting FirewallCentralSnatMap '%s': %s", mkey, errmsg.Status)
	}

	return
}

// List all FirewallCentralSnatMaps
func (c *FakeClient) ListFirewallCentralSnatMaps() (res []*FirewallCentralSnatMap, err error) {
	for _, r := range c.FirewallCentralSnatMaps {
		res = append(res, r)
	}
	return
}

// Get a FirewallCentralSnatMap by name
func (c *FakeClient) GetFirewallCentralSnatMap(mkey int) (*FirewallCentralSnatMap, error) {
	if res, ok := c.FirewallCentralSnatMaps[mkey]; ok {
		return res, nil
	} else {
		return &FirewallCentralSnatMap{}, fmt.Errorf("error getting FirewallCentralSnatMap '%s': not found", strconv.Itoa(mkey))
	}
}

// Create a new FirewallCentralSnatMap
func (c *FakeClient) CreateFirewallCentralSnatMap(obj *FirewallCentralSnatMap) (id int, err error) {
	id = c.FirewallCentralSnatMapCounter
	c.FirewallCentralSnatMapCounter++
	c.FirewallCentralSnatMaps[id] = obj
	return
}

// Update a FirewallCentralSnatMap
func (c *FakeClient) UpdateFirewallCentralSnatMap(obj *FirewallCentralSnatMap) (err error) {
	c.FirewallCentralSnatMaps[obj.Policyid] = obj
	return nil
}

// Delete a FirewallCentralSnatMap by name
func (c *FakeClient) DeleteFirewallCentralSnatMap(mkey int) (err error) {
	delete(c.FirewallCentralSnatMaps, mkey)
	return nil
}

// IP translation type (option: SCTP).
type FirewallIpTranslationType string

const (
	// SCTP
	FirewallIpTranslationTypeSCTP FirewallIpTranslationType = "SCTP"
)

// Configure firewall IP-translation.
type FirewallIpTranslation struct {

	// Final IPv4 address (inclusive) in the range of the addresses to be translated (format xxx.xxx.xxx.xxx, default: 0.0.0.0).
	Endip string `json:"endip,omitempty"`

	// Address to be used as the starting point for translation in the range (format xxx.xxx.xxx.xxx, default: 0.0.0.0).
	MapStartip string `json:"map-startip,omitempty"`

	// First IPv4 address (inclusive) in the range of the addresses to be translated (format xxx.xxx.xxx.xxx, default: 0.0.0.0).
	Startip string `json:"startip,omitempty"`

	// IP translation ID.
	Transid int `json:"transid,omitempty"`

	// IP translation type (option: SCTP).
	Type FirewallIpTranslationType `json:"type,omitempty"`
}

// Returns the value that identifies a FirewallIpTranslation
func (x *FirewallIpTranslation) MKey() int {
	return x.Transid
}

// The results of a Get or List operation
type FirewallIpTranslationResults struct {
	Results []*FirewallIpTranslation `json:"results"`
	Mkey    int                      `json:"mkey"`
	Result
}

// List all FirewallIpTranslations
func (c *WebClient) ListFirewallIpTranslations() (res []*FirewallIpTranslation, err error) {
	var errmsg Result
	var results FirewallIpTranslationResults
	_, err = c.napping.Get(c.URL+"/api/v2/firewall/ip-translation", nil, &results, nil)
	if err != nil {
		return []*FirewallIpTranslation{}, fmt.Errorf("error listing FirewallIpTranslations: %s", err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return []*FirewallIpTranslation{}, fmt.Errorf("error listing FirewallIpTranslation: not found")
		} else {
			return []*FirewallIpTranslation{}, fmt.Errorf("error listing FirewallIpTranslation: %s", errmsg.Status)
		}
	}
	res = results.Results
	return
}

// Get a FirewallIpTranslation by name
func (c *WebClient) GetFirewallIpTranslation(mkey int) (res *FirewallIpTranslation, err error) {
	var errmsg Result
	var results FirewallIpTranslationResults
	_, err = c.napping.Get(c.URL+"/api/v2/firewall/ip-translation/"+strconv.Itoa(mkey), nil, &results, &errmsg)
	if err != nil {
		return &FirewallIpTranslation{}, fmt.Errorf("error getting FirewallIpTranslation '%s': %s", strconv.Itoa(mkey), err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return &FirewallIpTranslation{}, fmt.Errorf("error getting FirewallIpTranslation '%s': not found", strconv.Itoa(mkey))
		} else {
			return &FirewallIpTranslation{}, fmt.Errorf("error getting FirewallIpTranslation '%s': %s", strconv.Itoa(mkey), errmsg.Status)
		}
	}
	if len(results.Results) == 0 {
		return &FirewallIpTranslation{}, fmt.Errorf("error getting FirewallIpTranslation '%s': not found", strconv.Itoa(mkey))
	}

	res = results.Results[0]
	return
}

// Create a new FirewallIpTranslation
func (c *WebClient) CreateFirewallIpTranslation(obj *FirewallIpTranslation) (id int, err error) {
	var errmsg Result
	var results FirewallIpTranslationResults
	_, err = c.napping.Post(c.URL+"/api/v2/firewall/ip-translation", obj, &results, &errmsg)
	if err != nil {
		return 0, fmt.Errorf("error creating FirewallIpTranslation '%s': %s", strconv.Itoa(obj.Transid), err.Error())
	}
	if results.HTTPStatus == 200 {
		return
	}
	if errmsg.HTTPStatus != 200 {
		return 0, fmt.Errorf("error creating FirewallIpTranslation '%s': %s", strconv.Itoa(obj.Transid), errmsg.Status)
	}

	return
}

// Update a FirewallIpTranslation
func (c *WebClient) UpdateFirewallIpTranslation(obj *FirewallIpTranslation) (err error) {
	var errmsg Result
	var results FirewallIpTranslationResults
	_, err = c.napping.Put(c.URL+"/api/v2/firewall/ip-translation/"+strconv.Itoa(obj.Transid), obj, &results, &errmsg)
	if err != nil {
		return fmt.Errorf("error updating FirewallIpTranslation '%s': %s", strconv.Itoa(obj.Transid), err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return fmt.Errorf("error updating FirewallIpTranslation '%s': not found", strconv.Itoa(obj.Transid))
		} else {
			return fmt.Errorf("error updating FirewallIpTranslation '%s': %s", strconv.Itoa(obj.Transid), errmsg.Status)
		}
	}

	return
}

// Delete a FirewallIpTranslation by name
func (c *WebClient) DeleteFirewallIpTranslation(mkey int) (err error) {
	var errmsg Result
	var results FirewallIpTranslationResults
	_, err = c.napping.Delete(c.URL+"/api/v2/firewall/ip-translation/"+strconv.Itoa(mkey), nil, &results, &errmsg)
	if err != nil {
		return fmt.Errorf("error deleting FirewallIpTranslation '%s': %s", mkey, err.Error())
	}
	if results.HTTPStatus == 200 {
		return
	}
	if errmsg.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return fmt.Errorf("error deleting FirewallIpTranslation '%s': not found", mkey)
		}
		return fmt.Errorf("error deleting FirewallIpTranslation '%s': %s", mkey, errmsg.Status)
	}

	return
}

// List all FirewallIpTranslations
func (c *FakeClient) ListFirewallIpTranslations() (res []*FirewallIpTranslation, err error) {
	for _, r := range c.FirewallIpTranslations {
		res = append(res, r)
	}
	return
}

// Get a FirewallIpTranslation by name
func (c *FakeClient) GetFirewallIpTranslation(mkey int) (*FirewallIpTranslation, error) {
	if res, ok := c.FirewallIpTranslations[mkey]; ok {
		return res, nil
	} else {
		return &FirewallIpTranslation{}, fmt.Errorf("error getting FirewallIpTranslation '%s': not found", strconv.Itoa(mkey))
	}
}

// Create a new FirewallIpTranslation
func (c *FakeClient) CreateFirewallIpTranslation(obj *FirewallIpTranslation) (id int, err error) {
	id = c.FirewallIpTranslationCounter
	c.FirewallIpTranslationCounter++
	c.FirewallIpTranslations[id] = obj
	return
}

// Update a FirewallIpTranslation
func (c *FakeClient) UpdateFirewallIpTranslation(obj *FirewallIpTranslation) (err error) {
	c.FirewallIpTranslations[obj.Transid] = obj
	return nil
}

// Delete a FirewallIpTranslation by name
func (c *FakeClient) DeleteFirewallIpTranslation(mkey int) (err error) {
	delete(c.FirewallIpTranslations, mkey)
	return nil
}

// Either global or VDOM IP address range for the CA certificate.
type CertificateCaRange string

// CA certificate source type.
type CertificateCaSource string

// Enable/disable as a trusted CA.
type CertificateCaTrusted string

const (
	// Global range.
	CertificateCaRangeGlobal CertificateCaRange = "global"

	// VDOM IP address range.
	CertificateCaRangeVdom CertificateCaRange = "vdom"
)

const (
	// Factory installed certificate.
	CertificateCaSourceFactory CertificateCaSource = "factory"

	// User generated certificate.
	CertificateCaSourceUser CertificateCaSource = "user"

	// Bundle file certificate.
	CertificateCaSourceBundle CertificateCaSource = "bundle"

	// FortiGuard generated certificate.
	CertificateCaSourceFortiguard CertificateCaSource = "fortiguard"
)

const (
	// Trusted CA.
	CertificateCaTrustedEnable CertificateCaTrusted = "enable"

	// Untrusted CA.
	CertificateCaTrustedDisable CertificateCaTrusted = "disable"
)

// CA certificate.
type CertificateCa struct {

	// Number of days to wait before requesting an updated CA certificate (0 - 4294967295, 0 = disabled).
	AutoUpdateDays int `json:"auto-update-days,omitempty"`

	// Number of days before an expiry-warning message is generated (0 - 4294967295, 0 = disabled).
	AutoUpdateDaysWarning int `json:"auto-update-days-warning,omitempty"`

	// CA certificate as a PEM file.
	Ca string `json:"ca,omitempty"`

	// Time at which CA was last updated.
	LastUpdated int `json:"last-updated,omitempty"`

	// Name.
	Name string `json:"name,omitempty"`

	// Either global or VDOM IP address range for the CA certificate.
	Range CertificateCaRange `json:"range,omitempty"`

	// URL of the SCEP server.
	ScepUrl string `json:"scep-url,omitempty"`

	// CA certificate source type.
	Source CertificateCaSource `json:"source,omitempty"`

	// Source IP address for communications to the SCEP server.
	SourceIp string `json:"source-ip,omitempty"`

	// Enable/disable as a trusted CA.
	Trusted CertificateCaTrusted `json:"trusted,omitempty"`
}

// Returns the value that identifies a CertificateCa
func (x *CertificateCa) MKey() string {
	return x.Name
}

// The results of a Get or List operation
type CertificateCaResults struct {
	Results []*CertificateCa `json:"results"`
	Mkey    string           `json:"mkey"`
	Result
}

// List all CertificateCas
func (c *WebClient) ListCertificateCas() (res []*CertificateCa, err error) {
	var errmsg Result
	var results CertificateCaResults
	_, err = c.napping.Get(c.URL+"/api/v2/certificate/ca", nil, &results, nil)
	if err != nil {
		return []*CertificateCa{}, fmt.Errorf("error listing CertificateCas: %s", err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return []*CertificateCa{}, fmt.Errorf("error listing CertificateCa: not found")
		} else {
			return []*CertificateCa{}, fmt.Errorf("error listing CertificateCa: %s", errmsg.Status)
		}
	}
	res = results.Results
	return
}

// Get a CertificateCa by name
func (c *WebClient) GetCertificateCa(mkey string) (res *CertificateCa, err error) {
	var errmsg Result
	var results CertificateCaResults
	_, err = c.napping.Get(c.URL+"/api/v2/certificate/ca/"+mkey, nil, &results, &errmsg)
	if err != nil {
		return &CertificateCa{}, fmt.Errorf("error getting CertificateCa '%s': %s", mkey, err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return &CertificateCa{}, fmt.Errorf("error getting CertificateCa '%s': not found", mkey)
		} else {
			return &CertificateCa{}, fmt.Errorf("error getting CertificateCa '%s': %s", mkey, errmsg.Status)
		}
	}
	if len(results.Results) == 0 {
		return &CertificateCa{}, fmt.Errorf("error getting CertificateCa '%s': not found", mkey)
	}

	res = results.Results[0]
	return
}

// Create a new CertificateCa
func (c *WebClient) CreateCertificateCa(obj *CertificateCa) (id string, err error) {
	var errmsg Result
	var results CertificateCaResults
	_, err = c.napping.Post(c.URL+"/api/v2/certificate/ca", obj, &results, &errmsg)
	if err != nil {
		return "", fmt.Errorf("error creating CertificateCa '%s': %s", obj.Name, err.Error())
	}
	if results.HTTPStatus == 200 {
		return
	}
	if errmsg.HTTPStatus != 200 {
		return "", fmt.Errorf("error creating CertificateCa '%s': %s", obj.Name, errmsg.Status)
	}

	return
}

// Update a CertificateCa
func (c *WebClient) UpdateCertificateCa(obj *CertificateCa) (err error) {
	var errmsg Result
	var results CertificateCaResults
	_, err = c.napping.Put(c.URL+"/api/v2/certificate/ca/"+obj.Name, obj, &results, &errmsg)
	if err != nil {
		return fmt.Errorf("error updating CertificateCa '%s': %s", obj.Name, err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return fmt.Errorf("error updating CertificateCa '%s': not found", obj.Name)
		} else {
			return fmt.Errorf("error updating CertificateCa '%s': %s", obj.Name, errmsg.Status)
		}
	}

	return
}

// Delete a CertificateCa by name
func (c *WebClient) DeleteCertificateCa(mkey string) (err error) {
	var errmsg Result
	var results CertificateCaResults
	_, err = c.napping.Delete(c.URL+"/api/v2/certificate/ca/"+mkey, nil, &results, &errmsg)
	if err != nil {
		return fmt.Errorf("error deleting CertificateCa '%s': %s", mkey, err.Error())
	}
	if results.HTTPStatus == 200 {
		return
	}
	if errmsg.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return fmt.Errorf("error deleting CertificateCa '%s': not found", mkey)
		}
		return fmt.Errorf("error deleting CertificateCa '%s': %s", mkey, errmsg.Status)
	}

	return
}

// List all CertificateCas
func (c *FakeClient) ListCertificateCas() (res []*CertificateCa, err error) {
	for _, r := range c.CertificateCas {
		res = append(res, r)
	}
	return
}

// Get a CertificateCa by name
func (c *FakeClient) GetCertificateCa(mkey string) (*CertificateCa, error) {
	if res, ok := c.CertificateCas[mkey]; ok {
		return res, nil
	} else {
		return &CertificateCa{}, fmt.Errorf("error getting CertificateCa '%s': not found", mkey)
	}
}

// Create a new CertificateCa
func (c *FakeClient) CreateCertificateCa(obj *CertificateCa) (id string, err error) {
	id = obj.Name
	c.CertificateCas[id] = obj
	return
}

// Update a CertificateCa
func (c *FakeClient) UpdateCertificateCa(obj *CertificateCa) (err error) {
	c.CertificateCas[obj.Name] = obj
	return nil
}

// Delete a CertificateCa by name
func (c *FakeClient) DeleteCertificateCa(mkey string) (err error) {
	delete(c.CertificateCas, mkey)
	return nil
}

// IKE local ID type.
type CertificateLocalIkeLocalidType string

// Name encoding method for auto-regeneration.
type CertificateLocalNameEncoding string

// Either a global or VDOM IP address range for the certificate.
type CertificateLocalRange string

// Certificate source type.
type CertificateLocalSource string

const (
	// ASN.1 distinguished name.
	CertificateLocalIkeLocalidTypeAsn1dn CertificateLocalIkeLocalidType = "asn1dn"

	// Fully qualified domain name.
	CertificateLocalIkeLocalidTypeFqdn CertificateLocalIkeLocalidType = "fqdn"
)

const (
	// Printable encoding (default).
	CertificateLocalNameEncodingPrintable CertificateLocalNameEncoding = "printable"

	// UTF-8 encoding.
	CertificateLocalNameEncodingUtf8 CertificateLocalNameEncoding = "utf8"
)

const (
	// Global range.
	CertificateLocalRangeGlobal CertificateLocalRange = "global"

	// VDOM IP address range.
	CertificateLocalRangeVdom CertificateLocalRange = "vdom"
)

const (
	// Factory installed certificate.
	CertificateLocalSourceFactory CertificateLocalSource = "factory"

	// User generated certificate.
	CertificateLocalSourceUser CertificateLocalSource = "user"

	// Bundle file certificate.
	CertificateLocalSourceBundle CertificateLocalSource = "bundle"

	// FortiGuard generated certificate.
	CertificateLocalSourceFortiguard CertificateLocalSource = "fortiguard"
)

// Local keys and certificates.
type CertificateLocal struct {

	// Number of days to wait before expiry of an updated local certificate is requested (0 = disabled).
	AutoRegenerateDays int `json:"auto-regenerate-days,omitempty"`

	// Number of days to wait before an expiry warning message is generated (0 = disabled).
	AutoRegenerateDaysWarning int `json:"auto-regenerate-days-warning,omitempty"`

	// CA identifier of the CA server for signing via SCEP.
	CaIdentifier string `json:"ca-identifier,omitempty"`

	// PEM format certificate.
	Certificate string `json:"certificate,omitempty"`

	// Comment.
	Comments string `json:"comments,omitempty"`

	// Certificate Signing Request.
	Csr string `json:"csr,omitempty"`

	// Local ID the FortiGate uses for authentication as a VPN client.
	IkeLocalid string `json:"ike-localid,omitempty"`

	// IKE local ID type.
	IkeLocalidType CertificateLocalIkeLocalidType `json:"ike-localid-type,omitempty"`

	// Time at which certificate was last updated.
	LastUpdated int `json:"last-updated,omitempty"`

	// Name.
	Name string `json:"name,omitempty"`

	// Name encoding method for auto-regeneration.
	NameEncoding CertificateLocalNameEncoding `json:"name-encoding,omitempty"`

	// Password as a PEM file.
	Password string `json:"password,omitempty"`

	// PEM format key, encrypted with a password.
	PrivateKey string `json:"private-key,omitempty"`

	// Either a global or VDOM IP address range for the certificate.
	Range CertificateLocalRange `json:"range,omitempty"`

	// SCEP server challenge password for auto-regeneration.
	ScepPassword string `json:"scep-password,omitempty"`

	// SCEP server URL.
	ScepUrl string `json:"scep-url,omitempty"`

	// Certificate source type.
	Source CertificateLocalSource `json:"source,omitempty"`

	// Source IP address for communications to the SCEP server.
	SourceIp string `json:"source-ip,omitempty"`

	// Certificate Signing Request State.
	State string `json:"state,omitempty"`
}

// Returns the value that identifies a CertificateLocal
func (x *CertificateLocal) MKey() string {
	return x.Name
}

// The results of a Get or List operation
type CertificateLocalResults struct {
	Results []*CertificateLocal `json:"results"`
	Mkey    string              `json:"mkey"`
	Result
}

// List all CertificateLocals
func (c *WebClient) ListCertificateLocals() (res []*CertificateLocal, err error) {
	var errmsg Result
	var results CertificateLocalResults
	_, err = c.napping.Get(c.URL+"/api/v2/certificate/local", nil, &results, nil)
	if err != nil {
		return []*CertificateLocal{}, fmt.Errorf("error listing CertificateLocals: %s", err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return []*CertificateLocal{}, fmt.Errorf("error listing CertificateLocal: not found")
		} else {
			return []*CertificateLocal{}, fmt.Errorf("error listing CertificateLocal: %s", errmsg.Status)
		}
	}
	res = results.Results
	return
}

// Get a CertificateLocal by name
func (c *WebClient) GetCertificateLocal(mkey string) (res *CertificateLocal, err error) {
	var errmsg Result
	var results CertificateLocalResults
	_, err = c.napping.Get(c.URL+"/api/v2/certificate/local/"+mkey, nil, &results, &errmsg)
	if err != nil {
		return &CertificateLocal{}, fmt.Errorf("error getting CertificateLocal '%s': %s", mkey, err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return &CertificateLocal{}, fmt.Errorf("error getting CertificateLocal '%s': not found", mkey)
		} else {
			return &CertificateLocal{}, fmt.Errorf("error getting CertificateLocal '%s': %s", mkey, errmsg.Status)
		}
	}
	if len(results.Results) == 0 {
		return &CertificateLocal{}, fmt.Errorf("error getting CertificateLocal '%s': not found", mkey)
	}

	res = results.Results[0]
	return
}

// Create a new CertificateLocal
func (c *WebClient) CreateCertificateLocal(obj *CertificateLocal) (id string, err error) {
	var errmsg Result
	var results CertificateLocalResults
	_, err = c.napping.Post(c.URL+"/api/v2/certificate/local", obj, &results, &errmsg)
	if err != nil {
		return "", fmt.Errorf("error creating CertificateLocal '%s': %s", obj.Name, err.Error())
	}
	if results.HTTPStatus == 200 {
		return
	}
	if errmsg.HTTPStatus != 200 {
		return "", fmt.Errorf("error creating CertificateLocal '%s': %s", obj.Name, errmsg.Status)
	}

	return
}

// Update a CertificateLocal
func (c *WebClient) UpdateCertificateLocal(obj *CertificateLocal) (err error) {
	var errmsg Result
	var results CertificateLocalResults
	_, err = c.napping.Put(c.URL+"/api/v2/certificate/local/"+obj.Name, obj, &results, &errmsg)
	if err != nil {
		return fmt.Errorf("error updating CertificateLocal '%s': %s", obj.Name, err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return fmt.Errorf("error updating CertificateLocal '%s': not found", obj.Name)
		} else {
			return fmt.Errorf("error updating CertificateLocal '%s': %s", obj.Name, errmsg.Status)
		}
	}

	return
}

// Delete a CertificateLocal by name
func (c *WebClient) DeleteCertificateLocal(mkey string) (err error) {
	var errmsg Result
	var results CertificateLocalResults
	_, err = c.napping.Delete(c.URL+"/api/v2/certificate/local/"+mkey, nil, &results, &errmsg)
	if err != nil {
		return fmt.Errorf("error deleting CertificateLocal '%s': %s", mkey, err.Error())
	}
	if results.HTTPStatus == 200 {
		return
	}
	if errmsg.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return fmt.Errorf("error deleting CertificateLocal '%s': not found", mkey)
		}
		return fmt.Errorf("error deleting CertificateLocal '%s': %s", mkey, errmsg.Status)
	}

	return
}

// List all CertificateLocals
func (c *FakeClient) ListCertificateLocals() (res []*CertificateLocal, err error) {
	for _, r := range c.CertificateLocals {
		res = append(res, r)
	}
	return
}

// Get a CertificateLocal by name
func (c *FakeClient) GetCertificateLocal(mkey string) (*CertificateLocal, error) {
	if res, ok := c.CertificateLocals[mkey]; ok {
		return res, nil
	} else {
		return &CertificateLocal{}, fmt.Errorf("error getting CertificateLocal '%s': not found", mkey)
	}
}

// Create a new CertificateLocal
func (c *FakeClient) CreateCertificateLocal(obj *CertificateLocal) (id string, err error) {
	id = obj.Name
	c.CertificateLocals[id] = obj
	return
}

// Update a CertificateLocal
func (c *FakeClient) UpdateCertificateLocal(obj *CertificateLocal) (err error) {
	c.CertificateLocals[obj.Name] = obj
	return nil
}

// Delete a CertificateLocal by name
func (c *FakeClient) DeleteCertificateLocal(mkey string) (err error) {
	delete(c.CertificateLocals, mkey)
	return nil
}

// Either global or VDOM IP address range for the certificate.
type CertificateCrlRange string

// Certificate source type.
type CertificateCrlSource string

const (
	// Global range.
	CertificateCrlRangeGlobal CertificateCrlRange = "global"

	// VDOM IP address range.
	CertificateCrlRangeVdom CertificateCrlRange = "vdom"
)

const (
	// Factory installed certificate.
	CertificateCrlSourceFactory CertificateCrlSource = "factory"

	// User generated certificate.
	CertificateCrlSourceUser CertificateCrlSource = "user"

	// Bundle file certificate.
	CertificateCrlSourceBundle CertificateCrlSource = "bundle"

	// FortiGuard generated certificate.
	CertificateCrlSourceFortiguard CertificateCrlSource = "fortiguard"
)

// Certificate Revocation List as a PEM file.
type CertificateCrl struct {

	// Certificate Revocation List as a PEM file.
	Crl string `json:"crl,omitempty"`

	// HTTP server URL for CRL auto-update.
	HttpUrl string `json:"http-url,omitempty"`

	// Time at which CRL was last updated.
	LastUpdated int `json:"last-updated,omitempty"`

	// LDAP server user password.
	LdapPassword string `json:"ldap-password,omitempty"`

	// LDAP server name for CRL auto-update.
	LdapServer string `json:"ldap-server,omitempty"`

	// LDAP server user name.
	LdapUsername string `json:"ldap-username,omitempty"`

	// Name.
	Name string `json:"name,omitempty"`

	// Either global or VDOM IP address range for the certificate.
	Range CertificateCrlRange `json:"range,omitempty"`

	// Local certificate for SCEP communication for CRL auto-update.
	ScepCert string `json:"scep-cert,omitempty"`

	// SCEP server URL for CRL auto-update.
	ScepUrl string `json:"scep-url,omitempty"`

	// Certificate source type.
	Source CertificateCrlSource `json:"source,omitempty"`

	// Source IP address for communications to a HTTP or SCEP CA server.
	SourceIp string `json:"source-ip,omitempty"`

	// Time in seconds before the FortiGate checks for an updated CRL. Set to 0 to update only when it expires.
	UpdateInterval int `json:"update-interval,omitempty"`

	// VDOM for CRL update.
	UpdateVdom string `json:"update-vdom,omitempty"`
}

// Returns the value that identifies a CertificateCrl
func (x *CertificateCrl) MKey() string {
	return x.Name
}

// The results of a Get or List operation
type CertificateCrlResults struct {
	Results []*CertificateCrl `json:"results"`
	Mkey    string            `json:"mkey"`
	Result
}

// List all CertificateCrls
func (c *WebClient) ListCertificateCrls() (res []*CertificateCrl, err error) {
	var errmsg Result
	var results CertificateCrlResults
	_, err = c.napping.Get(c.URL+"/api/v2/certificate/crl", nil, &results, nil)
	if err != nil {
		return []*CertificateCrl{}, fmt.Errorf("error listing CertificateCrls: %s", err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return []*CertificateCrl{}, fmt.Errorf("error listing CertificateCrl: not found")
		} else {
			return []*CertificateCrl{}, fmt.Errorf("error listing CertificateCrl: %s", errmsg.Status)
		}
	}
	res = results.Results
	return
}

// Get a CertificateCrl by name
func (c *WebClient) GetCertificateCrl(mkey string) (res *CertificateCrl, err error) {
	var errmsg Result
	var results CertificateCrlResults
	_, err = c.napping.Get(c.URL+"/api/v2/certificate/crl/"+mkey, nil, &results, &errmsg)
	if err != nil {
		return &CertificateCrl{}, fmt.Errorf("error getting CertificateCrl '%s': %s", mkey, err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return &CertificateCrl{}, fmt.Errorf("error getting CertificateCrl '%s': not found", mkey)
		} else {
			return &CertificateCrl{}, fmt.Errorf("error getting CertificateCrl '%s': %s", mkey, errmsg.Status)
		}
	}
	if len(results.Results) == 0 {
		return &CertificateCrl{}, fmt.Errorf("error getting CertificateCrl '%s': not found", mkey)
	}

	res = results.Results[0]
	return
}

// Create a new CertificateCrl
func (c *WebClient) CreateCertificateCrl(obj *CertificateCrl) (id string, err error) {
	var errmsg Result
	var results CertificateCrlResults
	_, err = c.napping.Post(c.URL+"/api/v2/certificate/crl", obj, &results, &errmsg)
	if err != nil {
		return "", fmt.Errorf("error creating CertificateCrl '%s': %s", obj.Name, err.Error())
	}
	if results.HTTPStatus == 200 {
		return
	}
	if errmsg.HTTPStatus != 200 {
		return "", fmt.Errorf("error creating CertificateCrl '%s': %s", obj.Name, errmsg.Status)
	}

	return
}

// Update a CertificateCrl
func (c *WebClient) UpdateCertificateCrl(obj *CertificateCrl) (err error) {
	var errmsg Result
	var results CertificateCrlResults
	_, err = c.napping.Put(c.URL+"/api/v2/certificate/crl/"+obj.Name, obj, &results, &errmsg)
	if err != nil {
		return fmt.Errorf("error updating CertificateCrl '%s': %s", obj.Name, err.Error())
	}
	if results.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return fmt.Errorf("error updating CertificateCrl '%s': not found", obj.Name)
		} else {
			return fmt.Errorf("error updating CertificateCrl '%s': %s", obj.Name, errmsg.Status)
		}
	}

	return
}

// Delete a CertificateCrl by name
func (c *WebClient) DeleteCertificateCrl(mkey string) (err error) {
	var errmsg Result
	var results CertificateCrlResults
	_, err = c.napping.Delete(c.URL+"/api/v2/certificate/crl/"+mkey, nil, &results, &errmsg)
	if err != nil {
		return fmt.Errorf("error deleting CertificateCrl '%s': %s", mkey, err.Error())
	}
	if results.HTTPStatus == 200 {
		return
	}
	if errmsg.HTTPStatus != 200 {
		if errmsg.HTTPStatus == 404 {
			return fmt.Errorf("error deleting CertificateCrl '%s': not found", mkey)
		}
		return fmt.Errorf("error deleting CertificateCrl '%s': %s", mkey, errmsg.Status)
	}

	return
}

// List all CertificateCrls
func (c *FakeClient) ListCertificateCrls() (res []*CertificateCrl, err error) {
	for _, r := range c.CertificateCrls {
		res = append(res, r)
	}
	return
}

// Get a CertificateCrl by name
func (c *FakeClient) GetCertificateCrl(mkey string) (*CertificateCrl, error) {
	if res, ok := c.CertificateCrls[mkey]; ok {
		return res, nil
	} else {
		return &CertificateCrl{}, fmt.Errorf("error getting CertificateCrl '%s': not found", mkey)
	}
}

// Create a new CertificateCrl
func (c *FakeClient) CreateCertificateCrl(obj *CertificateCrl) (id string, err error) {
	id = obj.Name
	c.CertificateCrls[id] = obj
	return
}

// Update a CertificateCrl
func (c *FakeClient) UpdateCertificateCrl(obj *CertificateCrl) (err error) {
	c.CertificateCrls[obj.Name] = obj
	return nil
}

// Delete a CertificateCrl by name
func (c *FakeClient) DeleteCertificateCrl(mkey string) (err error) {
	delete(c.CertificateCrls, mkey)
	return nil
}
